from palm.palm import ProtoBase, is_string, RepeatedSequence, ProtoValueError

_PB_type = type
_PB_finalizers = []


# Enumeration: Activity

ACT_INVALID = -1

ACT_RESET = 0

ACT_IDLE = 1

ACT_TRANSITION = 2

ACT_COVER = 3

ACT_COVER_MED = 4

ACT_COVER_LOW = 5

ACT_WALK = 6

ACT_WALK_AIM = 7

ACT_WALK_CROUCH = 8

ACT_WALK_CROUCH_AIM = 9

ACT_RUN = 10

ACT_RUN_AIM = 11

ACT_RUN_CROUCH = 12

ACT_RUN_CROUCH_AIM = 13

ACT_RUN_PROTECTED = 14

ACT_SCRIPT_CUSTOM_MOVE = 15

ACT_RANGE_ATTACK1 = 16

ACT_RANGE_ATTACK2 = 17

ACT_RANGE_ATTACK1_LOW = 18

ACT_RANGE_ATTACK2_LOW = 19

ACT_DIESIMPLE = 20

ACT_DIEBACKWARD = 21

ACT_DIEFORWARD = 22

ACT_DIEVIOLENT = 23

ACT_DIERAGDOLL = 24

ACT_FLY = 25

ACT_HOVER = 26

ACT_GLIDE = 27

ACT_SWIM = 28

ACT_JUMP = 29

ACT_HOP = 30

ACT_LEAP = 31

ACT_LAND = 32

ACT_CLIMB_UP = 33

ACT_CLIMB_DOWN = 34

ACT_CLIMB_DISMOUNT = 35

ACT_SHIPLADDER_UP = 36

ACT_SHIPLADDER_DOWN = 37

ACT_STRAFE_LEFT = 38

ACT_STRAFE_RIGHT = 39

ACT_ROLL_LEFT = 40

ACT_ROLL_RIGHT = 41

ACT_TURN_LEFT = 42

ACT_TURN_RIGHT = 43

ACT_CROUCH = 44

ACT_CROUCHIDLE = 45

ACT_STAND = 46

ACT_USE = 47

ACT_ALIEN_BURROW_IDLE = 48

ACT_ALIEN_BURROW_OUT = 49

ACT_SIGNAL1 = 50

ACT_SIGNAL2 = 51

ACT_SIGNAL3 = 52

ACT_SIGNAL_ADVANCE = 53

ACT_SIGNAL_FORWARD = 54

ACT_SIGNAL_GROUP = 55

ACT_SIGNAL_HALT = 56

ACT_SIGNAL_LEFT = 57

ACT_SIGNAL_RIGHT = 58

ACT_SIGNAL_TAKECOVER = 59

ACT_LOOKBACK_RIGHT = 60

ACT_LOOKBACK_LEFT = 61

ACT_COWER = 62

ACT_SMALL_FLINCH = 63

ACT_BIG_FLINCH = 64

ACT_MELEE_ATTACK1 = 65

ACT_MELEE_ATTACK2 = 66

ACT_RELOAD = 67

ACT_RELOAD_START = 68

ACT_RELOAD_FINISH = 69

ACT_RELOAD_LOW = 70

ACT_ARM = 71

ACT_DISARM = 72

ACT_DROP_WEAPON = 73

ACT_DROP_WEAPON_SHOTGUN = 74

ACT_PICKUP_GROUND = 75

ACT_PICKUP_RACK = 76

ACT_IDLE_ANGRY = 77

ACT_IDLE_RELAXED = 78

ACT_IDLE_STIMULATED = 79

ACT_IDLE_AGITATED = 80

ACT_IDLE_STEALTH = 81

ACT_IDLE_HURT = 82

ACT_WALK_RELAXED = 83

ACT_WALK_STIMULATED = 84

ACT_WALK_AGITATED = 85

ACT_WALK_STEALTH = 86

ACT_RUN_RELAXED = 87

ACT_RUN_STIMULATED = 88

ACT_RUN_AGITATED = 89

ACT_RUN_STEALTH = 90

ACT_IDLE_AIM_RELAXED = 91

ACT_IDLE_AIM_STIMULATED = 92

ACT_IDLE_AIM_AGITATED = 93

ACT_IDLE_AIM_STEALTH = 94

ACT_WALK_AIM_RELAXED = 95

ACT_WALK_AIM_STIMULATED = 96

ACT_WALK_AIM_AGITATED = 97

ACT_WALK_AIM_STEALTH = 98

ACT_RUN_AIM_RELAXED = 99

ACT_RUN_AIM_STIMULATED = 100

ACT_RUN_AIM_AGITATED = 101

ACT_RUN_AIM_STEALTH = 102

ACT_CROUCHIDLE_STIMULATED = 103

ACT_CROUCHIDLE_AIM_STIMULATED = 104

ACT_CROUCHIDLE_AGITATED = 105

ACT_WALK_HURT = 106

ACT_RUN_HURT = 107

ACT_SPECIAL_ATTACK1 = 108

ACT_SPECIAL_ATTACK2 = 109

ACT_COMBAT_IDLE = 110

ACT_WALK_SCARED = 111

ACT_RUN_SCARED = 112

ACT_VICTORY_DANCE = 113

ACT_DIE_HEADSHOT = 114

ACT_DIE_CHESTSHOT = 115

ACT_DIE_GUTSHOT = 116

ACT_DIE_BACKSHOT = 117

ACT_FLINCH_HEAD = 118

ACT_FLINCH_CHEST = 119

ACT_FLINCH_STOMACH = 120

ACT_FLINCH_LEFTARM = 121

ACT_FLINCH_RIGHTARM = 122

ACT_FLINCH_LEFTLEG = 123

ACT_FLINCH_RIGHTLEG = 124

ACT_FLINCH_PHYSICS = 125

ACT_FLINCH_HEAD_BACK = 126

ACT_FLINCH_CHEST_BACK = 127

ACT_FLINCH_STOMACH_BACK = 128

ACT_FLINCH_CROUCH_FRONT = 129

ACT_FLINCH_CROUCH_BACK = 130

ACT_FLINCH_CROUCH_LEFT = 131

ACT_FLINCH_CROUCH_RIGHT = 132

ACT_IDLE_ON_FIRE = 133

ACT_WALK_ON_FIRE = 134

ACT_RUN_ON_FIRE = 135

ACT_RAPPEL_LOOP = 136

ACT_180_LEFT = 137

ACT_180_RIGHT = 138

ACT_90_LEFT = 139

ACT_90_RIGHT = 140

ACT_STEP_LEFT = 141

ACT_STEP_RIGHT = 142

ACT_STEP_BACK = 143

ACT_STEP_FORE = 144

ACT_GESTURE_RANGE_ATTACK1 = 145

ACT_GESTURE_RANGE_ATTACK2 = 146

ACT_GESTURE_MELEE_ATTACK1 = 147

ACT_GESTURE_MELEE_ATTACK2 = 148

ACT_GESTURE_RANGE_ATTACK1_LOW = 149

ACT_GESTURE_RANGE_ATTACK2_LOW = 150

ACT_MELEE_ATTACK_SWING_GESTURE = 151

ACT_GESTURE_SMALL_FLINCH = 152

ACT_GESTURE_BIG_FLINCH = 153

ACT_GESTURE_FLINCH_BLAST = 154

ACT_GESTURE_FLINCH_BLAST_SHOTGUN = 155

ACT_GESTURE_FLINCH_BLAST_DAMAGED = 156

ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN = 157

ACT_GESTURE_FLINCH_HEAD = 158

ACT_GESTURE_FLINCH_CHEST = 159

ACT_GESTURE_FLINCH_STOMACH = 160

ACT_GESTURE_FLINCH_LEFTARM = 161

ACT_GESTURE_FLINCH_RIGHTARM = 162

ACT_GESTURE_FLINCH_LEFTLEG = 163

ACT_GESTURE_FLINCH_RIGHTLEG = 164

ACT_GESTURE_TURN_LEFT = 165

ACT_GESTURE_TURN_RIGHT = 166

ACT_GESTURE_TURN_LEFT45 = 167

ACT_GESTURE_TURN_RIGHT45 = 168

ACT_GESTURE_TURN_LEFT90 = 169

ACT_GESTURE_TURN_RIGHT90 = 170

ACT_GESTURE_TURN_LEFT45_FLAT = 171

ACT_GESTURE_TURN_RIGHT45_FLAT = 172

ACT_GESTURE_TURN_LEFT90_FLAT = 173

ACT_GESTURE_TURN_RIGHT90_FLAT = 174

ACT_BARNACLE_HIT = 175

ACT_BARNACLE_PULL = 176

ACT_BARNACLE_CHOMP = 177

ACT_BARNACLE_CHEW = 178

ACT_DO_NOT_DISTURB = 179

ACT_SPECIFIC_SEQUENCE = 180

ACT_VM_DRAW = 181

ACT_VM_HOLSTER = 182

ACT_VM_IDLE = 183

ACT_VM_FIDGET = 184

ACT_VM_PULLBACK = 185

ACT_VM_PULLBACK_HIGH = 186

ACT_VM_PULLBACK_LOW = 187

ACT_VM_THROW = 188

ACT_VM_PULLPIN = 189

ACT_VM_PRIMARYATTACK = 190

ACT_VM_SECONDARYATTACK = 191

ACT_VM_RELOAD = 192

ACT_VM_DRYFIRE = 193

ACT_VM_HITLEFT = 194

ACT_VM_HITLEFT2 = 195

ACT_VM_HITRIGHT = 196

ACT_VM_HITRIGHT2 = 197

ACT_VM_HITCENTER = 198

ACT_VM_HITCENTER2 = 199

ACT_VM_MISSLEFT = 200

ACT_VM_MISSLEFT2 = 201

ACT_VM_MISSRIGHT = 202

ACT_VM_MISSRIGHT2 = 203

ACT_VM_MISSCENTER = 204

ACT_VM_MISSCENTER2 = 205

ACT_VM_HAULBACK = 206

ACT_VM_SWINGHARD = 207

ACT_VM_SWINGMISS = 208

ACT_VM_SWINGHIT = 209

ACT_VM_IDLE_TO_LOWERED = 210

ACT_VM_IDLE_LOWERED = 211

ACT_VM_LOWERED_TO_IDLE = 212

ACT_VM_RECOIL1 = 213

ACT_VM_RECOIL2 = 214

ACT_VM_RECOIL3 = 215

ACT_VM_PICKUP = 216

ACT_VM_RELEASE = 217

ACT_VM_ATTACH_SILENCER = 218

ACT_VM_DETACH_SILENCER = 219

ACT_SLAM_STICKWALL_IDLE = 220

ACT_SLAM_STICKWALL_ND_IDLE = 221

ACT_SLAM_STICKWALL_ATTACH = 222

ACT_SLAM_STICKWALL_ATTACH2 = 223

ACT_SLAM_STICKWALL_ND_ATTACH = 224

ACT_SLAM_STICKWALL_ND_ATTACH2 = 225

ACT_SLAM_STICKWALL_DETONATE = 226

ACT_SLAM_STICKWALL_DETONATOR_HOLSTER = 227

ACT_SLAM_STICKWALL_DRAW = 228

ACT_SLAM_STICKWALL_ND_DRAW = 229

ACT_SLAM_STICKWALL_TO_THROW = 230

ACT_SLAM_STICKWALL_TO_THROW_ND = 231

ACT_SLAM_STICKWALL_TO_TRIPMINE_ND = 232

ACT_SLAM_THROW_IDLE = 233

ACT_SLAM_THROW_ND_IDLE = 234

ACT_SLAM_THROW_THROW = 235

ACT_SLAM_THROW_THROW2 = 236

ACT_SLAM_THROW_THROW_ND = 237

ACT_SLAM_THROW_THROW_ND2 = 238

ACT_SLAM_THROW_DRAW = 239

ACT_SLAM_THROW_ND_DRAW = 240

ACT_SLAM_THROW_TO_STICKWALL = 241

ACT_SLAM_THROW_TO_STICKWALL_ND = 242

ACT_SLAM_THROW_DETONATE = 243

ACT_SLAM_THROW_DETONATOR_HOLSTER = 244

ACT_SLAM_THROW_TO_TRIPMINE_ND = 245

ACT_SLAM_TRIPMINE_IDLE = 246

ACT_SLAM_TRIPMINE_DRAW = 247

ACT_SLAM_TRIPMINE_ATTACH = 248

ACT_SLAM_TRIPMINE_ATTACH2 = 249

ACT_SLAM_TRIPMINE_TO_STICKWALL_ND = 250

ACT_SLAM_TRIPMINE_TO_THROW_ND = 251

ACT_SLAM_DETONATOR_IDLE = 252

ACT_SLAM_DETONATOR_DRAW = 253

ACT_SLAM_DETONATOR_DETONATE = 254

ACT_SLAM_DETONATOR_HOLSTER = 255

ACT_SLAM_DETONATOR_STICKWALL_DRAW = 256

ACT_SLAM_DETONATOR_THROW_DRAW = 257

ACT_SHOTGUN_RELOAD_START = 258

ACT_SHOTGUN_RELOAD_FINISH = 259

ACT_SHOTGUN_PUMP = 260

ACT_SMG2_IDLE2 = 261

ACT_SMG2_FIRE2 = 262

ACT_SMG2_DRAW2 = 263

ACT_SMG2_RELOAD2 = 264

ACT_SMG2_DRYFIRE2 = 265

ACT_SMG2_TOAUTO = 266

ACT_SMG2_TOBURST = 267

ACT_PHYSCANNON_UPGRADE = 268

ACT_RANGE_ATTACK_AR1 = 269

ACT_RANGE_ATTACK_AR2 = 270

ACT_RANGE_ATTACK_AR2_LOW = 271

ACT_RANGE_ATTACK_AR2_GRENADE = 272

ACT_RANGE_ATTACK_HMG1 = 273

ACT_RANGE_ATTACK_ML = 274

ACT_RANGE_ATTACK_SMG1 = 275

ACT_RANGE_ATTACK_SMG1_LOW = 276

ACT_RANGE_ATTACK_SMG2 = 277

ACT_RANGE_ATTACK_SHOTGUN = 278

ACT_RANGE_ATTACK_SHOTGUN_LOW = 279

ACT_RANGE_ATTACK_PISTOL = 280

ACT_RANGE_ATTACK_PISTOL_LOW = 281

ACT_RANGE_ATTACK_SLAM = 282

ACT_RANGE_ATTACK_TRIPWIRE = 283

ACT_RANGE_ATTACK_THROW = 284

ACT_RANGE_ATTACK_SNIPER_RIFLE = 285

ACT_RANGE_ATTACK_RPG = 286

ACT_MELEE_ATTACK_SWING = 287

ACT_RANGE_AIM_LOW = 288

ACT_RANGE_AIM_SMG1_LOW = 289

ACT_RANGE_AIM_PISTOL_LOW = 290

ACT_RANGE_AIM_AR2_LOW = 291

ACT_COVER_PISTOL_LOW = 292

ACT_COVER_SMG1_LOW = 293

ACT_GESTURE_RANGE_ATTACK_AR1 = 294

ACT_GESTURE_RANGE_ATTACK_AR2 = 295

ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE = 296

ACT_GESTURE_RANGE_ATTACK_HMG1 = 297

ACT_GESTURE_RANGE_ATTACK_ML = 298

ACT_GESTURE_RANGE_ATTACK_SMG1 = 299

ACT_GESTURE_RANGE_ATTACK_SMG1_LOW = 300

ACT_GESTURE_RANGE_ATTACK_SMG2 = 301

ACT_GESTURE_RANGE_ATTACK_SHOTGUN = 302

ACT_GESTURE_RANGE_ATTACK_PISTOL = 303

ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW = 304

ACT_GESTURE_RANGE_ATTACK_SLAM = 305

ACT_GESTURE_RANGE_ATTACK_TRIPWIRE = 306

ACT_GESTURE_RANGE_ATTACK_THROW = 307

ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE = 308

ACT_GESTURE_MELEE_ATTACK_SWING = 309

ACT_IDLE_RIFLE = 310

ACT_IDLE_SMG1 = 311

ACT_IDLE_ANGRY_SMG1 = 312

ACT_IDLE_PISTOL = 313

ACT_IDLE_ANGRY_PISTOL = 314

ACT_IDLE_ANGRY_SHOTGUN = 315

ACT_IDLE_STEALTH_PISTOL = 316

ACT_IDLE_PACKAGE = 317

ACT_WALK_PACKAGE = 318

ACT_IDLE_SUITCASE = 319

ACT_WALK_SUITCASE = 320

ACT_IDLE_SMG1_RELAXED = 321

ACT_IDLE_SMG1_STIMULATED = 322

ACT_WALK_RIFLE_RELAXED = 323

ACT_RUN_RIFLE_RELAXED = 324

ACT_WALK_RIFLE_STIMULATED = 325

ACT_RUN_RIFLE_STIMULATED = 326

ACT_IDLE_AIM_RIFLE_STIMULATED = 327

ACT_WALK_AIM_RIFLE_STIMULATED = 328

ACT_RUN_AIM_RIFLE_STIMULATED = 329

ACT_IDLE_SHOTGUN_RELAXED = 330

ACT_IDLE_SHOTGUN_STIMULATED = 331

ACT_IDLE_SHOTGUN_AGITATED = 332

ACT_WALK_ANGRY = 333

ACT_POLICE_HARASS1 = 334

ACT_POLICE_HARASS2 = 335

ACT_IDLE_MANNEDGUN = 336

ACT_IDLE_MELEE = 337

ACT_IDLE_ANGRY_MELEE = 338

ACT_IDLE_RPG_RELAXED = 339

ACT_IDLE_RPG = 340

ACT_IDLE_ANGRY_RPG = 341

ACT_COVER_LOW_RPG = 342

ACT_WALK_RPG = 343

ACT_RUN_RPG = 344

ACT_WALK_CROUCH_RPG = 345

ACT_RUN_CROUCH_RPG = 346

ACT_WALK_RPG_RELAXED = 347

ACT_RUN_RPG_RELAXED = 348

ACT_WALK_RIFLE = 349

ACT_WALK_AIM_RIFLE = 350

ACT_WALK_CROUCH_RIFLE = 351

ACT_WALK_CROUCH_AIM_RIFLE = 352

ACT_RUN_RIFLE = 353

ACT_RUN_AIM_RIFLE = 354

ACT_RUN_CROUCH_RIFLE = 355

ACT_RUN_CROUCH_AIM_RIFLE = 356

ACT_RUN_STEALTH_PISTOL = 357

ACT_WALK_AIM_SHOTGUN = 358

ACT_RUN_AIM_SHOTGUN = 359

ACT_WALK_PISTOL = 360

ACT_RUN_PISTOL = 361

ACT_WALK_AIM_PISTOL = 362

ACT_RUN_AIM_PISTOL = 363

ACT_WALK_STEALTH_PISTOL = 364

ACT_WALK_AIM_STEALTH_PISTOL = 365

ACT_RUN_AIM_STEALTH_PISTOL = 366

ACT_RELOAD_PISTOL = 367

ACT_RELOAD_PISTOL_LOW = 368

ACT_RELOAD_SMG1 = 369

ACT_RELOAD_SMG1_LOW = 370

ACT_RELOAD_SHOTGUN = 371

ACT_RELOAD_SHOTGUN_LOW = 372

ACT_GESTURE_RELOAD = 373

ACT_GESTURE_RELOAD_PISTOL = 374

ACT_GESTURE_RELOAD_SMG1 = 375

ACT_GESTURE_RELOAD_SHOTGUN = 376

ACT_BUSY_LEAN_LEFT = 377

ACT_BUSY_LEAN_LEFT_ENTRY = 378

ACT_BUSY_LEAN_LEFT_EXIT = 379

ACT_BUSY_LEAN_BACK = 380

ACT_BUSY_LEAN_BACK_ENTRY = 381

ACT_BUSY_LEAN_BACK_EXIT = 382

ACT_BUSY_SIT_GROUND = 383

ACT_BUSY_SIT_GROUND_ENTRY = 384

ACT_BUSY_SIT_GROUND_EXIT = 385

ACT_BUSY_SIT_CHAIR = 386

ACT_BUSY_SIT_CHAIR_ENTRY = 387

ACT_BUSY_SIT_CHAIR_EXIT = 388

ACT_BUSY_STAND = 389

ACT_BUSY_QUEUE = 390

ACT_DUCK_DODGE = 391

ACT_DIE_BARNACLE_SWALLOW = 392

ACT_GESTURE_BARNACLE_STRANGLE = 393

ACT_PHYSCANNON_DETACH = 394

ACT_PHYSCANNON_ANIMATE = 395

ACT_PHYSCANNON_ANIMATE_PRE = 396

ACT_PHYSCANNON_ANIMATE_POST = 397

ACT_DIE_FRONTSIDE = 398

ACT_DIE_RIGHTSIDE = 399

ACT_DIE_BACKSIDE = 400

ACT_DIE_LEFTSIDE = 401

ACT_OPEN_DOOR = 402

ACT_DI_ALYX_ZOMBIE_MELEE = 403

ACT_DI_ALYX_ZOMBIE_TORSO_MELEE = 404

ACT_DI_ALYX_HEADCRAB_MELEE = 405

ACT_DI_ALYX_ANTLION = 406

ACT_DI_ALYX_ZOMBIE_SHOTGUN64 = 407

ACT_DI_ALYX_ZOMBIE_SHOTGUN26 = 408

ACT_READINESS_RELAXED_TO_STIMULATED = 409

ACT_READINESS_RELAXED_TO_STIMULATED_WALK = 410

ACT_READINESS_AGITATED_TO_STIMULATED = 411

ACT_READINESS_STIMULATED_TO_RELAXED = 412

ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED = 413

ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK = 414

ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED = 415

ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED = 416

ACT_IDLE_CARRY = 417

ACT_WALK_CARRY = 418

ACT_DOTA_IDLE = 419

ACT_DOTA_IDLE_RARE = 421

ACT_DOTA_RUN = 422

ACT_DOTA_ATTACK = 424

ACT_DOTA_ATTACK2 = 425

ACT_DOTA_ATTACK_EVENT = 426

ACT_DOTA_DIE = 427

ACT_DOTA_FLINCH = 428

ACT_DOTA_FLAIL = 429

ACT_DOTA_DISABLED = 430

ACT_DOTA_CAST_ABILITY_1 = 431

ACT_DOTA_CAST_ABILITY_2 = 432

ACT_DOTA_CAST_ABILITY_3 = 433

ACT_DOTA_CAST_ABILITY_4 = 434

ACT_DOTA_CAST_ABILITY_5 = 435

ACT_DOTA_CAST_ABILITY_6 = 436

ACT_DOTA_OVERRIDE_ABILITY_1 = 437

ACT_DOTA_OVERRIDE_ABILITY_2 = 438

ACT_DOTA_OVERRIDE_ABILITY_3 = 439

ACT_DOTA_OVERRIDE_ABILITY_4 = 440

ACT_DOTA_CHANNEL_ABILITY_1 = 441

ACT_DOTA_CHANNEL_ABILITY_2 = 442

ACT_DOTA_CHANNEL_ABILITY_3 = 443

ACT_DOTA_CHANNEL_ABILITY_4 = 444

ACT_DOTA_CHANNEL_ABILITY_5 = 445

ACT_DOTA_CHANNEL_ABILITY_6 = 446

ACT_DOTA_CHANNEL_END_ABILITY_1 = 447

ACT_DOTA_CHANNEL_END_ABILITY_2 = 448

ACT_DOTA_CHANNEL_END_ABILITY_3 = 449

ACT_DOTA_CHANNEL_END_ABILITY_4 = 450

ACT_DOTA_CHANNEL_END_ABILITY_5 = 451

ACT_DOTA_CHANNEL_END_ABILITY_6 = 452

ACT_DOTA_CONSTANT_LAYER = 453

ACT_DOTA_CAPTURE = 454

ACT_DOTA_SPAWN = 455

ACT_DOTA_KILLTAUNT = 456

ACT_DOTA_TAUNT = 457

ACT_DOTA_THIRST = 458

ACT_DOTA_CAST_DRAGONBREATH = 459

ACT_DOTA_ECHO_SLAM = 460

ACT_DOTA_CAST_ABILITY_1_END = 461

ACT_DOTA_CAST_ABILITY_2_END = 462

ACT_DOTA_CAST_ABILITY_3_END = 463

ACT_DOTA_CAST_ABILITY_4_END = 464

ACT_MIRANA_LEAP_END = 465

ACT_WAVEFORM_START = 466

ACT_WAVEFORM_END = 467

ACT_DOTA_CAST_ABILITY_ROT = 468

ACT_DOTA_DIE_SPECIAL = 469

ACT_DOTA_RATTLETRAP_BATTERYASSAULT = 470

ACT_DOTA_RATTLETRAP_POWERCOGS = 471

ACT_DOTA_RATTLETRAP_HOOKSHOT_START = 472

ACT_DOTA_RATTLETRAP_HOOKSHOT_LOOP = 473

ACT_DOTA_RATTLETRAP_HOOKSHOT_END = 474

ACT_STORM_SPIRIT_OVERLOAD_RUN_OVERRIDE = 475

ACT_DOTA_TINKER_REARM1 = 476

ACT_DOTA_TINKER_REARM2 = 477

ACT_DOTA_TINKER_REARM3 = 478

ACT_TINY_AVALANCHE = 479

ACT_TINY_TOSS = 480

ACT_TINY_GROWL = 481

ACT_DOTA_WEAVERBUG_ATTACH = 482

ACT_DOTA_CAST_WILD_AXES_END = 483

ACT_DOTA_CAST_LIFE_BREAK_START = 484

ACT_DOTA_CAST_LIFE_BREAK_END = 485

ACT_DOTA_NIGHTSTALKER_TRANSITION = 486

ACT_DOTA_LIFESTEALER_RAGE = 487

ACT_DOTA_LIFESTEALER_OPEN_WOUNDS = 488

ACT_DOTA_SAND_KING_BURROW_IN = 489

ACT_DOTA_SAND_KING_BURROW_OUT = 490

ACT_DOTA_EARTHSHAKER_TOTEM_ATTACK = 491

ACT_DOTA_WHEEL_LAYER = 492

ACT_DOTA_ALCHEMIST_CHEMICAL_RAGE_START = 493

ACT_DOTA_ALCHEMIST_CONCOCTION = 494

ACT_DOTA_JAKIRO_LIQUIDFIRE_START = 495

ACT_DOTA_JAKIRO_LIQUIDFIRE_LOOP = 496

ACT_DOTA_LIFESTEALER_INFEST = 497

ACT_DOTA_LIFESTEALER_INFEST_END = 498

ACT_DOTA_LASSO_LOOP = 499

ACT_DOTA_ALCHEMIST_CONCOCTION_THROW = 500

ACT_DOTA_ALCHEMIST_CHEMICAL_RAGE_END = 501

ACT_DOTA_CAST_COLD_SNAP = 502

ACT_DOTA_CAST_GHOST_WALK = 503

ACT_DOTA_CAST_TORNADO = 504

ACT_DOTA_CAST_EMP = 505

ACT_DOTA_CAST_ALACRITY = 506

ACT_DOTA_CAST_CHAOS_METEOR = 507

ACT_DOTA_CAST_SUN_STRIKE = 508

ACT_DOTA_CAST_FORGE_SPIRIT = 509

ACT_DOTA_CAST_ICE_WALL = 510

ACT_DOTA_CAST_DEAFENING_BLAST = 511

ACT_DOTA_VICTORY = 512

ACT_DOTA_DEFEAT = 513

ACT_DOTA_SPIRIT_BREAKER_CHARGE_POSE = 514

ACT_DOTA_SPIRIT_BREAKER_CHARGE_END = 515

ACT_DOTA_TELEPORT = 516

ACT_DOTA_TELEPORT_END = 517

ACT_DOTA_CAST_REFRACTION = 518

ACT_DOTA_CAST_ABILITY_7 = 519

ACT_DOTA_CANCEL_SIREN_SONG = 520

ACT_DOTA_CHANNEL_ABILITY_7 = 521

ACT_DOTA_LOADOUT = 522

ACT_DOTA_FORCESTAFF_END = 523

ACT_DOTA_POOF_END = 524

ACT_DOTA_SLARK_POUNCE = 525

ACT_DOTA_MAGNUS_SKEWER_START = 526

ACT_DOTA_MAGNUS_SKEWER_END = 527

ACT_DOTA_MEDUSA_STONE_GAZE = 528

ACT_DOTA_RELAX_START = 529

ACT_DOTA_RELAX_LOOP = 530

ACT_DOTA_RELAX_END = 531

ACT_DOTA_CENTAUR_STAMPEDE = 532

ACT_DOTA_BELLYACHE_START = 533

ACT_DOTA_BELLYACHE_LOOP = 534

ACT_DOTA_BELLYACHE_END = 535

ACT_DOTA_ROQUELAIRE_LAND = 536

ACT_DOTA_ROQUELAIRE_LAND_IDLE = 537

ACT_DOTA_GREEVIL_CAST = 538

ACT_DOTA_GREEVIL_OVERRIDE_ABILITY = 539

ACT_DOTA_GREEVIL_HOOK_START = 540

ACT_DOTA_GREEVIL_HOOK_END = 541

ACT_DOTA_GREEVIL_BLINK_BONE = 542

ACT_DOTA_IDLE_SLEEPING = 543

ACT_DOTA_INTRO = 544

ACT_DOTA_GESTURE_POINT = 545

ACT_DOTA_GESTURE_ACCENT = 546

ACT_DOTA_SLEEPING_END = 547

ACT_DOTA_AMBUSH = 548

ACT_DOTA_ITEM_LOOK = 549

ACT_DOTA_STARTLE = 550

ACT_DOTA_FRUSTRATION = 551

ACT_DOTA_TELEPORT_REACT = 552

ACT_DOTA_TELEPORT_END_REACT = 553

ACT_DOTA_SHRUG = 554

ACT_DOTA_RELAX_LOOP_END = 555

ACT_DOTA_PRESENT_ITEM = 556

ACT_DOTA_IDLE_IMPATIENT = 557

ACT_DOTA_SHARPEN_WEAPON = 558

ACT_DOTA_SHARPEN_WEAPON_OUT = 559

ACT_DOTA_IDLE_SLEEPING_END = 560

ACT_DOTA_BRIDGE_DESTROY = 561

ACT_DOTA_TAUNT_SNIPER = 562

ACT_DOTA_DEATH_BY_SNIPER = 563

ACT_DOTA_LOOK_AROUND = 564

ACT_DOTA_CAGED_CREEP_RAGE = 565

ACT_DOTA_CAGED_CREEP_RAGE_OUT = 566

ACT_DOTA_CAGED_CREEP_SMASH = 567

ACT_DOTA_CAGED_CREEP_SMASH_OUT = 568

ACT_DOTA_IDLE_IMPATIENT_SWORD_TAP = 569

ACT_DOTA_INTRO_LOOP = 570

ACT_DOTA_BRIDGE_THREAT = 571

ACT_DOTA_DAGON = 572

ACT_DOTA_CAST_ABILITY_2_ES_ROLL_START = 573

ACT_DOTA_CAST_ABILITY_2_ES_ROLL = 574

ACT_DOTA_CAST_ABILITY_2_ES_ROLL_END = 575

ACT_DOTA_NIAN_PIN_START = 576

ACT_DOTA_NIAN_PIN_LOOP = 577

ACT_DOTA_NIAN_PIN_END = 578

ACT_DOTA_LEAP_STUN = 579

ACT_DOTA_LEAP_SWIPE = 580

ACT_DOTA_NIAN_INTRO_LEAP = 581

ACT_DOTA_AREA_DENY = 582

ACT_DOTA_NIAN_PIN_TO_STUN = 583

ACT_DOTA_RAZE_1 = 584

ACT_DOTA_RAZE_2 = 585

ACT_DOTA_RAZE_3 = 586

ACT_DOTA_UNDYING_DECAY = 587

ACT_DOTA_UNDYING_SOUL_RIP = 588

ACT_DOTA_UNDYING_TOMBSTONE = 589

ACT_DOTA_WHIRLING_AXES_RANGED = 590

ACT_DOTA_SHALLOW_GRAVE = 591

ACT_DOTA_COLD_FEET = 592

ACT_DOTA_ICE_VORTEX = 593

ACT_DOTA_CHILLING_TOUCH = 594

ACT_DOTA_ENFEEBLE = 595

ACT_DOTA_FATAL_BONDS = 596

ACT_DOTA_MIDNIGHT_PULSE = 597

ACT_DOTA_ANCESTRAL_SPIRIT = 598

ACT_DOTA_THUNDER_STRIKE = 599

ACT_DOTA_KINETIC_FIELD = 600

ACT_DOTA_STATIC_STORM = 601

TYPE_Activity = ProtoBase.TYPE_int32

_Activity__map = {93: 'ACT_IDLE_AIM_AGITATED', 76: 'ACT_PICKUP_RACK', 176: 'ACT_BARNACLE_PULL', 163: 'ACT_GESTURE_FLINCH_LEFTLEG', 233: 'ACT_SLAM_THROW_IDLE', 455: 'ACT_DOTA_SPAWN', 576: 'ACT_DOTA_NIAN_PIN_START', 299: 'ACT_GESTURE_RANGE_ATTACK_SMG1', 301: 'ACT_GESTURE_RANGE_ATTACK_SMG2', 202: 'ACT_VM_MISSRIGHT', 231: 'ACT_SLAM_STICKWALL_TO_THROW_ND', 13: 'ACT_RUN_CROUCH_AIM', 356: 'ACT_RUN_CROUCH_AIM_RIFLE', 419: 'ACT_DOTA_IDLE', 594: 'ACT_DOTA_CHILLING_TOUCH', 160: 'ACT_GESTURE_FLINCH_STOMACH', 560: 'ACT_DOTA_IDLE_SLEEPING_END', 121: 'ACT_FLINCH_LEFTARM', 529: 'ACT_DOTA_RELAX_START', 9: 'ACT_WALK_CROUCH_AIM', 55: 'ACT_SIGNAL_GROUP', 115: 'ACT_DIE_CHESTSHOT', 390: 'ACT_BUSY_QUEUE', 456: 'ACT_DOTA_KILLTAUNT', 534: 'ACT_DOTA_BELLYACHE_LOOP', 444: 'ACT_DOTA_CHANNEL_ABILITY_4', 293: 'ACT_COVER_SMG1_LOW', 322: 'ACT_IDLE_SMG1_STIMULATED', 460: 'ACT_DOTA_ECHO_SLAM', 146: 'ACT_GESTURE_RANGE_ATTACK2', 518: 'ACT_DOTA_CAST_REFRACTION', 410: 'ACT_READINESS_RELAXED_TO_STIMULATED_WALK', 145: 'ACT_GESTURE_RANGE_ATTACK1', 441: 'ACT_DOTA_CHANNEL_ABILITY_1', 595: 'ACT_DOTA_ENFEEBLE', 577: 'ACT_DOTA_NIAN_PIN_LOOP', 565: 'ACT_DOTA_CAGED_CREEP_RAGE', 317: 'ACT_IDLE_PACKAGE', 571: 'ACT_DOTA_BRIDGE_THREAT', 42: 'ACT_TURN_LEFT', 580: 'ACT_DOTA_LEAP_SWIPE', 421: 'ACT_DOTA_IDLE_RARE', 488: 'ACT_DOTA_LIFESTEALER_OPEN_WOUNDS', 432: 'ACT_DOTA_CAST_ABILITY_2', 329: 'ACT_RUN_AIM_RIFLE_STIMULATED', 275: 'ACT_RANGE_ATTACK_SMG1', 287: 'ACT_MELEE_ATTACK_SWING', 433: 'ACT_DOTA_CAST_ABILITY_3', 462: 'ACT_DOTA_CAST_ABILITY_2_END', 320: 'ACT_WALK_SUITCASE', 72: 'ACT_DISARM', 228: 'ACT_SLAM_STICKWALL_DRAW', 247: 'ACT_SLAM_TRIPMINE_DRAW', 133: 'ACT_IDLE_ON_FIRE', 370: 'ACT_RELOAD_SMG1_LOW', 251: 'ACT_SLAM_TRIPMINE_TO_THROW_ND', 21: 'ACT_DIEBACKWARD', 381: 'ACT_BUSY_LEAN_BACK_ENTRY', 241: 'ACT_SLAM_THROW_TO_STICKWALL', 278: 'ACT_RANGE_ATTACK_SHOTGUN', 142: 'ACT_STEP_RIGHT', 47: 'ACT_USE', 481: 'ACT_TINY_GROWL', 96: 'ACT_WALK_AIM_STIMULATED', 198: 'ACT_VM_HITCENTER', 56: 'ACT_SIGNAL_HALT', 357: 'ACT_RUN_STEALTH_PISTOL', 466: 'ACT_WAVEFORM_START', 492: 'ACT_DOTA_WHEEL_LAYER', 258: 'ACT_SHOTGUN_RELOAD_START', 4: 'ACT_COVER_MED', 318: 'ACT_WALK_PACKAGE', 414: 'ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK', 0: 'ACT_RESET', 547: 'ACT_DOTA_SLEEPING_END', 195: 'ACT_VM_HITLEFT2', 60: 'ACT_LOOKBACK_RIGHT', 405: 'ACT_DI_ALYX_HEADCRAB_MELEE', 335: 'ACT_POLICE_HARASS2', 334: 'ACT_POLICE_HARASS1', 51: 'ACT_SIGNAL2', 52: 'ACT_SIGNAL3', 50: 'ACT_SIGNAL1', 461: 'ACT_DOTA_CAST_ABILITY_1_END', 454: 'ACT_DOTA_CAPTURE', 102: 'ACT_RUN_AIM_STEALTH', 559: 'ACT_DOTA_SHARPEN_WEAPON_OUT', 37: 'ACT_SHIPLADDER_DOWN', 69: 'ACT_RELOAD_FINISH', 238: 'ACT_SLAM_THROW_THROW_ND2', 226: 'ACT_SLAM_STICKWALL_DETONATE', 401: 'ACT_DIE_LEFTSIDE', 220: 'ACT_SLAM_STICKWALL_IDLE', 470: 'ACT_DOTA_RATTLETRAP_BATTERYASSAULT', 361: 'ACT_RUN_PISTOL', 564: 'ACT_DOTA_LOOK_AROUND', 240: 'ACT_SLAM_THROW_ND_DRAW', 483: 'ACT_DOTA_CAST_WILD_AXES_END', 139: 'ACT_90_LEFT', 407: 'ACT_DI_ALYX_ZOMBIE_SHOTGUN64', 132: 'ACT_FLINCH_CROUCH_RIGHT', 359: 'ACT_RUN_AIM_SHOTGUN', 99: 'ACT_RUN_AIM_RELAXED', 495: 'ACT_DOTA_JAKIRO_LIQUIDFIRE_START', 511: 'ACT_DOTA_CAST_DEAFENING_BLAST', 306: 'ACT_GESTURE_RANGE_ATTACK_TRIPWIRE', 526: 'ACT_DOTA_MAGNUS_SKEWER_START', 112: 'ACT_RUN_SCARED', 387: 'ACT_BUSY_SIT_CHAIR_ENTRY', 186: 'ACT_VM_PULLBACK_HIGH', 123: 'ACT_FLINCH_LEFTLEG', 257: 'ACT_SLAM_DETONATOR_THROW_DRAW', 79: 'ACT_IDLE_STIMULATED', 221: 'ACT_SLAM_STICKWALL_ND_IDLE', 277: 'ACT_RANGE_ATTACK_SMG2', 525: 'ACT_DOTA_SLARK_POUNCE', 574: 'ACT_DOTA_CAST_ABILITY_2_ES_ROLL', 342: 'ACT_COVER_LOW_RPG', 49: 'ACT_ALIEN_BURROW_OUT', 260: 'ACT_SHOTGUN_PUMP', 266: 'ACT_SMG2_TOAUTO', 208: 'ACT_VM_SWINGMISS', 197: 'ACT_VM_HITRIGHT2', 122: 'ACT_FLINCH_RIGHTARM', 388: 'ACT_BUSY_SIT_CHAIR_EXIT', 73: 'ACT_DROP_WEAPON', 510: 'ACT_DOTA_CAST_ICE_WALL', 291: 'ACT_RANGE_AIM_AR2_LOW', 587: 'ACT_DOTA_UNDYING_DECAY', 189: 'ACT_VM_PULLPIN', 327: 'ACT_IDLE_AIM_RIFLE_STIMULATED', 464: 'ACT_DOTA_CAST_ABILITY_4_END', 482: 'ACT_DOTA_WEAVERBUG_ATTACH', 489: 'ACT_DOTA_SAND_KING_BURROW_IN', 25: 'ACT_FLY', 349: 'ACT_WALK_RIFLE', 138: 'ACT_180_RIGHT', 10: 'ACT_RUN', 68: 'ACT_RELOAD_START', 181: 'ACT_VM_DRAW', 41: 'ACT_ROLL_RIGHT', 487: 'ACT_DOTA_LIFESTEALER_RAGE', 270: 'ACT_RANGE_ATTACK_AR2', 313: 'ACT_IDLE_PISTOL', 592: 'ACT_DOTA_COLD_FEET', 170: 'ACT_GESTURE_TURN_RIGHT90', 347: 'ACT_WALK_RPG_RELAXED', 288: 'ACT_RANGE_AIM_LOW', 111: 'ACT_WALK_SCARED', 103: 'ACT_CROUCHIDLE_STIMULATED', 188: 'ACT_VM_THROW', 289: 'ACT_RANGE_AIM_SMG1_LOW', 28: 'ACT_SWIM', 31: 'ACT_LEAP', 272: 'ACT_RANGE_ATTACK_AR2_GRENADE', 561: 'ACT_DOTA_BRIDGE_DESTROY', 120: 'ACT_FLINCH_STOMACH', 59: 'ACT_SIGNAL_TAKECOVER', 502: 'ACT_DOTA_CAST_COLD_SNAP', 17: 'ACT_RANGE_ATTACK2', 229: 'ACT_SLAM_STICKWALL_ND_DRAW', 16: 'ACT_RANGE_ATTACK1', 437: 'ACT_DOTA_OVERRIDE_ABILITY_1', 439: 'ACT_DOTA_OVERRIDE_ABILITY_3', 438: 'ACT_DOTA_OVERRIDE_ABILITY_2', 440: 'ACT_DOTA_OVERRIDE_ABILITY_4', 223: 'ACT_SLAM_STICKWALL_ATTACH2', 284: 'ACT_RANGE_ATTACK_THROW', 369: 'ACT_RELOAD_SMG1', 281: 'ACT_RANGE_ATTACK_PISTOL_LOW', 246: 'ACT_SLAM_TRIPMINE_IDLE', 119: 'ACT_FLINCH_CHEST', 311: 'ACT_IDLE_SMG1', 413: 'ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED', 408: 'ACT_DI_ALYX_ZOMBIE_SHOTGUN26', 23: 'ACT_DIEVIOLENT', 508: 'ACT_DOTA_CAST_SUN_STRIKE', 217: 'ACT_VM_RELEASE', 124: 'ACT_FLINCH_RIGHTLEG', -1: 'ACT_INVALID', 157: 'ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN', 307: 'ACT_GESTURE_RANGE_ATTACK_THROW', 252: 'ACT_SLAM_DETONATOR_IDLE', 116: 'ACT_DIE_GUTSHOT', 500: 'ACT_DOTA_ALCHEMIST_CONCOCTION_THROW', 476: 'ACT_DOTA_TINKER_REARM1', 341: 'ACT_IDLE_ANGRY_RPG', 343: 'ACT_WALK_RPG', 75: 'ACT_PICKUP_GROUND', 125: 'ACT_FLINCH_PHYSICS', 162: 'ACT_GESTURE_FLINCH_RIGHTARM', 46: 'ACT_STAND', 474: 'ACT_DOTA_RATTLETRAP_HOOKSHOT_END', 397: 'ACT_PHYSCANNON_ANIMATE_POST', 269: 'ACT_RANGE_ATTACK_AR1', 566: 'ACT_DOTA_CAGED_CREEP_RAGE_OUT', 144: 'ACT_STEP_FORE', 379: 'ACT_BUSY_LEAN_LEFT_EXIT', 256: 'ACT_SLAM_DETONATOR_STICKWALL_DRAW', 15: 'ACT_SCRIPT_CUSTOM_MOVE', 101: 'ACT_RUN_AIM_AGITATED', 546: 'ACT_DOTA_GESTURE_ACCENT', 368: 'ACT_RELOAD_PISTOL_LOW', 524: 'ACT_DOTA_POOF_END', 164: 'ACT_GESTURE_FLINCH_RIGHTLEG', 274: 'ACT_RANGE_ATTACK_ML', 469: 'ACT_DOTA_DIE_SPECIAL', 26: 'ACT_HOVER', 324: 'ACT_RUN_RIFLE_RELAXED', 224: 'ACT_SLAM_STICKWALL_ND_ATTACH', 549: 'ACT_DOTA_ITEM_LOOK', 371: 'ACT_RELOAD_SHOTGUN', 386: 'ACT_BUSY_SIT_CHAIR', 64: 'ACT_BIG_FLINCH', 427: 'ACT_DOTA_DIE', 532: 'ACT_DOTA_CENTAUR_STAMPEDE', 367: 'ACT_RELOAD_PISTOL', 154: 'ACT_GESTURE_FLINCH_BLAST', 58: 'ACT_SIGNAL_RIGHT', 78: 'ACT_IDLE_RELAXED', 27: 'ACT_GLIDE', 430: 'ACT_DOTA_DISABLED', 80: 'ACT_IDLE_AGITATED', 375: 'ACT_GESTURE_RELOAD_SMG1', 425: 'ACT_DOTA_ATTACK2', 465: 'ACT_MIRANA_LEAP_END', 213: 'ACT_VM_RECOIL1', 215: 'ACT_VM_RECOIL3', 214: 'ACT_VM_RECOIL2', 259: 'ACT_SHOTGUN_RELOAD_FINISH', 552: 'ACT_DOTA_TELEPORT_REACT', 250: 'ACT_SLAM_TRIPMINE_TO_STICKWALL_ND', 225: 'ACT_SLAM_STICKWALL_ND_ATTACH2', 428: 'ACT_DOTA_FLINCH', 107: 'ACT_RUN_HURT', 591: 'ACT_DOTA_SHALLOW_GRAVE', 304: 'ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW', 545: 'ACT_DOTA_GESTURE_POINT', 503: 'ACT_DOTA_CAST_GHOST_WALK', 568: 'ACT_DOTA_CAGED_CREEP_SMASH_OUT', 286: 'ACT_RANGE_ATTACK_RPG', 276: 'ACT_RANGE_ATTACK_SMG1_LOW', 200: 'ACT_VM_MISSLEFT', 244: 'ACT_SLAM_THROW_DETONATOR_HOLSTER', 237: 'ACT_SLAM_THROW_THROW_ND', 172: 'ACT_GESTURE_TURN_RIGHT45_FLAT', 585: 'ACT_DOTA_RAZE_2', 340: 'ACT_IDLE_RPG', 584: 'ACT_DOTA_RAZE_1', 34: 'ACT_CLIMB_DOWN', 137: 'ACT_180_LEFT', 97: 'ACT_WALK_AIM_AGITATED', 178: 'ACT_BARNACLE_CHEW', 7: 'ACT_WALK_AIM', 235: 'ACT_SLAM_THROW_THROW', 44: 'ACT_CROUCH', 150: 'ACT_GESTURE_RANGE_ATTACK2_LOW', 589: 'ACT_DOTA_UNDYING_TOMBSTONE', 380: 'ACT_BUSY_LEAN_BACK', 36: 'ACT_SHIPLADDER_UP', 424: 'ACT_DOTA_ATTACK', 184: 'ACT_VM_FIDGET', 406: 'ACT_DI_ALYX_ANTLION', 393: 'ACT_GESTURE_BARNACLE_STRANGLE', 193: 'ACT_VM_DRYFIRE', 558: 'ACT_DOTA_SHARPEN_WEAPON', 358: 'ACT_WALK_AIM_SHOTGUN', 203: 'ACT_VM_MISSRIGHT2', 542: 'ACT_DOTA_GREEVIL_BLINK_BONE', 540: 'ACT_DOTA_GREEVIL_HOOK_START', 486: 'ACT_DOTA_NIGHTSTALKER_TRANSITION', 544: 'ACT_DOTA_INTRO', 158: 'ACT_GESTURE_FLINCH_HEAD', 563: 'ACT_DOTA_DEATH_BY_SNIPER', 599: 'ACT_DOTA_THUNDER_STRIKE', 396: 'ACT_PHYSCANNON_ANIMATE_PRE', 280: 'ACT_RANGE_ATTACK_PISTOL', 458: 'ACT_DOTA_THIRST', 187: 'ACT_VM_PULLBACK_LOW', 431: 'ACT_DOTA_CAST_ABILITY_1', 135: 'ACT_RUN_ON_FIRE', 169: 'ACT_GESTURE_TURN_LEFT90', 106: 'ACT_WALK_HURT', 54: 'ACT_SIGNAL_FORWARD', 586: 'ACT_DOTA_RAZE_3', 243: 'ACT_SLAM_THROW_DETONATE', 399: 'ACT_DIE_RIGHTSIDE', 506: 'ACT_DOTA_CAST_ALACRITY', 207: 'ACT_VM_SWINGHARD', 57: 'ACT_SIGNAL_LEFT', 267: 'ACT_SMG2_TOBURST', 411: 'ACT_READINESS_AGITATED_TO_STIMULATED', 53: 'ACT_SIGNAL_ADVANCE', 575: 'ACT_DOTA_CAST_ABILITY_2_ES_ROLL_END', 543: 'ACT_DOTA_IDLE_SLEEPING', 537: 'ACT_DOTA_ROQUELAIRE_LAND_IDLE', 177: 'ACT_BARNACLE_CHOMP', 376: 'ACT_GESTURE_RELOAD_SHOTGUN', 245: 'ACT_SLAM_THROW_TO_TRIPMINE_ND', 194: 'ACT_VM_HITLEFT', 118: 'ACT_FLINCH_HEAD', 501: 'ACT_DOTA_ALCHEMIST_CHEMICAL_RAGE_END', 20: 'ACT_DIESIMPLE', 512: 'ACT_DOTA_VICTORY', 533: 'ACT_DOTA_BELLYACHE_START', 236: 'ACT_SLAM_THROW_THROW2', 385: 'ACT_BUSY_SIT_GROUND_EXIT', 382: 'ACT_BUSY_LEAN_BACK_EXIT', 490: 'ACT_DOTA_SAND_KING_BURROW_OUT', 514: 'ACT_DOTA_SPIRIT_BREAKER_CHARGE_POSE', 302: 'ACT_GESTURE_RANGE_ATTACK_SHOTGUN', 593: 'ACT_DOTA_ICE_VORTEX', 332: 'ACT_IDLE_SHOTGUN_AGITATED', 355: 'ACT_RUN_CROUCH_RIFLE', 581: 'ACT_DOTA_NIAN_INTRO_LEAP', 70: 'ACT_RELOAD_LOW', 328: 'ACT_WALK_AIM_RIFLE_STIMULATED', 209: 'ACT_VM_SWINGHIT', 516: 'ACT_DOTA_TELEPORT', 29: 'ACT_JUMP', 554: 'ACT_DOTA_SHRUG', 364: 'ACT_WALK_STEALTH_PISTOL', 394: 'ACT_PHYSCANNON_DETACH', 265: 'ACT_SMG2_DRYFIRE2', 300: 'ACT_GESTURE_RANGE_ATTACK_SMG1_LOW', 350: 'ACT_WALK_AIM_RIFLE', 467: 'ACT_WAVEFORM_END', 553: 'ACT_DOTA_TELEPORT_END_REACT', 384: 'ACT_BUSY_SIT_GROUND_ENTRY', 264: 'ACT_SMG2_RELOAD2', 417: 'ACT_IDLE_CARRY', 377: 'ACT_BUSY_LEAN_LEFT', 471: 'ACT_DOTA_RATTLETRAP_POWERCOGS', 588: 'ACT_DOTA_UNDYING_SOUL_RIP', 520: 'ACT_DOTA_CANCEL_SIREN_SONG', 373: 'ACT_GESTURE_RELOAD', 165: 'ACT_GESTURE_TURN_LEFT', 305: 'ACT_GESTURE_RANGE_ATTACK_SLAM', 539: 'ACT_DOTA_GREEVIL_OVERRIDE_ABILITY', 67: 'ACT_RELOAD', 422: 'ACT_DOTA_RUN', 504: 'ACT_DOTA_CAST_TORNADO', 86: 'ACT_WALK_STEALTH', 232: 'ACT_SLAM_STICKWALL_TO_TRIPMINE_ND', 279: 'ACT_RANGE_ATTACK_SHOTGUN_LOW', 598: 'ACT_DOTA_ANCESTRAL_SPIRIT', 183: 'ACT_VM_IDLE', 498: 'ACT_DOTA_LIFESTEALER_INFEST_END', 249: 'ACT_SLAM_TRIPMINE_ATTACH2', 484: 'ACT_DOTA_CAST_LIFE_BREAK_START', 346: 'ACT_RUN_CROUCH_RPG', 134: 'ACT_WALK_ON_FIRE', 242: 'ACT_SLAM_THROW_TO_STICKWALL_ND', 84: 'ACT_WALK_STIMULATED', 159: 'ACT_GESTURE_FLINCH_CHEST', 152: 'ACT_GESTURE_SMALL_FLINCH', 597: 'ACT_DOTA_MIDNIGHT_PULSE', 95: 'ACT_WALK_AIM_RELAXED', 248: 'ACT_SLAM_TRIPMINE_ATTACH', 555: 'ACT_DOTA_RELAX_LOOP_END', 395: 'ACT_PHYSCANNON_ANIMATE', 83: 'ACT_WALK_RELAXED', 108: 'ACT_SPECIAL_ATTACK1', 63: 'ACT_SMALL_FLINCH', 98: 'ACT_WALK_AIM_STEALTH', 219: 'ACT_VM_DETACH_SILENCER', 206: 'ACT_VM_HAULBACK', 363: 'ACT_RUN_AIM_PISTOL', 173: 'ACT_GESTURE_TURN_LEFT90_FLAT', 315: 'ACT_IDLE_ANGRY_SHOTGUN', 90: 'ACT_RUN_STEALTH', 153: 'ACT_GESTURE_BIG_FLINCH', 24: 'ACT_DIERAGDOLL', 255: 'ACT_SLAM_DETONATOR_HOLSTER', 192: 'ACT_VM_RELOAD', 48: 'ACT_ALIEN_BURROW_IDLE', 415: 'ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED', 129: 'ACT_FLINCH_CROUCH_FRONT', 403: 'ACT_DI_ALYX_ZOMBIE_MELEE', 174: 'ACT_GESTURE_TURN_RIGHT90_FLAT', 308: 'ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE', 600: 'ACT_DOTA_KINETIC_FIELD', 453: 'ACT_DOTA_CONSTANT_LAYER', 473: 'ACT_DOTA_RATTLETRAP_HOOKSHOT_LOOP', 312: 'ACT_IDLE_ANGRY_SMG1', 30: 'ACT_HOP', 426: 'ACT_DOTA_ATTACK_EVENT', 185: 'ACT_VM_PULLBACK', 354: 'ACT_RUN_AIM_RIFLE', 331: 'ACT_IDLE_SHOTGUN_STIMULATED', 596: 'ACT_DOTA_FATAL_BONDS', 205: 'ACT_VM_MISSCENTER2', 536: 'ACT_DOTA_ROQUELAIRE_LAND', 212: 'ACT_VM_LOWERED_TO_IDLE', 573: 'ACT_DOTA_CAST_ABILITY_2_ES_ROLL_START', 114: 'ACT_DIE_HEADSHOT', 491: 'ACT_DOTA_EARTHSHAKER_TOTEM_ATTACK', 155: 'ACT_GESTURE_FLINCH_BLAST_SHOTGUN', 391: 'ACT_DUCK_DODGE', 113: 'ACT_VICTORY_DANCE', 590: 'ACT_DOTA_WHIRLING_AXES_RANGED', 316: 'ACT_IDLE_STEALTH_PISTOL', 140: 'ACT_90_RIGHT', 254: 'ACT_SLAM_DETONATOR_DETONATE', 65: 'ACT_MELEE_ATTACK1', 409: 'ACT_READINESS_RELAXED_TO_STIMULATED', 66: 'ACT_MELEE_ATTACK2', 449: 'ACT_DOTA_CHANNEL_END_ABILITY_3', 448: 'ACT_DOTA_CHANNEL_END_ABILITY_2', 447: 'ACT_DOTA_CHANNEL_END_ABILITY_1', 452: 'ACT_DOTA_CHANNEL_END_ABILITY_6', 451: 'ACT_DOTA_CHANNEL_END_ABILITY_5', 450: 'ACT_DOTA_CHANNEL_END_ABILITY_4', 126: 'ACT_FLINCH_HEAD_BACK', 110: 'ACT_COMBAT_IDLE', 445: 'ACT_DOTA_CHANNEL_ABILITY_5', 290: 'ACT_RANGE_AIM_PISTOL_LOW', 521: 'ACT_DOTA_CHANNEL_ABILITY_7', 446: 'ACT_DOTA_CHANNEL_ABILITY_6', 227: 'ACT_SLAM_STICKWALL_DETONATOR_HOLSTER', 443: 'ACT_DOTA_CHANNEL_ABILITY_3', 442: 'ACT_DOTA_CHANNEL_ABILITY_2', 149: 'ACT_GESTURE_RANGE_ATTACK1_LOW', 601: 'ACT_DOTA_STATIC_STORM', 6: 'ACT_WALK', 507: 'ACT_DOTA_CAST_CHAOS_METEOR', 569: 'ACT_DOTA_IDLE_IMPATIENT_SWORD_TAP', 127: 'ACT_FLINCH_CHEST_BACK', 104: 'ACT_CROUCHIDLE_AIM_STIMULATED', 151: 'ACT_MELEE_ATTACK_SWING_GESTURE', 298: 'ACT_GESTURE_RANGE_ATTACK_ML', 383: 'ACT_BUSY_SIT_GROUND', 323: 'ACT_WALK_RIFLE_RELAXED', 583: 'ACT_DOTA_NIAN_PIN_TO_STUN', 92: 'ACT_IDLE_AIM_STIMULATED', 333: 'ACT_WALK_ANGRY', 497: 'ACT_DOTA_LIFESTEALER_INFEST', 372: 'ACT_RELOAD_SHOTGUN_LOW', 378: 'ACT_BUSY_LEAN_LEFT_ENTRY', 499: 'ACT_DOTA_LASSO_LOOP', 321: 'ACT_IDLE_SMG1_RELAXED', 319: 'ACT_IDLE_SUITCASE', 496: 'ACT_DOTA_JAKIRO_LIQUIDFIRE_LOOP', 515: 'ACT_DOTA_SPIRIT_BREAKER_CHARGE_END', 485: 'ACT_DOTA_CAST_LIFE_BREAK_END', 218: 'ACT_VM_ATTACH_SILENCER', 38: 'ACT_STRAFE_LEFT', 91: 'ACT_IDLE_AIM_RELAXED', 366: 'ACT_RUN_AIM_STEALTH_PISTOL', 572: 'ACT_DOTA_DAGON', 345: 'ACT_WALK_CROUCH_RPG', 528: 'ACT_DOTA_MEDUSA_STONE_GAZE', 268: 'ACT_PHYSCANNON_UPGRADE', 190: 'ACT_VM_PRIMARYATTACK', 196: 'ACT_VM_HITRIGHT', 14: 'ACT_RUN_PROTECTED', 5: 'ACT_COVER_LOW', 392: 'ACT_DIE_BARNACLE_SWALLOW', 33: 'ACT_CLIMB_UP', 309: 'ACT_GESTURE_MELEE_ATTACK_SWING', 182: 'ACT_VM_HOLSTER', 147: 'ACT_GESTURE_MELEE_ATTACK1', 148: 'ACT_GESTURE_MELEE_ATTACK2', 167: 'ACT_GESTURE_TURN_LEFT45', 239: 'ACT_SLAM_THROW_DRAW', 339: 'ACT_IDLE_RPG_RELAXED', 562: 'ACT_DOTA_TAUNT_SNIPER', 109: 'ACT_SPECIAL_ATTACK2', 348: 'ACT_RUN_RPG_RELAXED', 88: 'ACT_RUN_STIMULATED', 360: 'ACT_WALK_PISTOL', 191: 'ACT_VM_SECONDARYATTACK', 130: 'ACT_FLINCH_CROUCH_BACK', 210: 'ACT_VM_IDLE_TO_LOWERED', 105: 'ACT_CROUCHIDLE_AGITATED', 541: 'ACT_DOTA_GREEVIL_HOOK_END', 71: 'ACT_ARM', 161: 'ACT_GESTURE_FLINCH_LEFTARM', 344: 'ACT_RUN_RPG', 527: 'ACT_DOTA_MAGNUS_SKEWER_END', 418: 'ACT_WALK_CARRY', 472: 'ACT_DOTA_RATTLETRAP_HOOKSHOT_START', 74: 'ACT_DROP_WEAPON_SHOTGUN', 579: 'ACT_DOTA_LEAP_STUN', 156: 'ACT_GESTURE_FLINCH_BLAST_DAMAGED', 582: 'ACT_DOTA_AREA_DENY', 166: 'ACT_GESTURE_TURN_RIGHT', 273: 'ACT_RANGE_ATTACK_HMG1', 282: 'ACT_RANGE_ATTACK_SLAM', 77: 'ACT_IDLE_ANGRY', 143: 'ACT_STEP_BACK', 136: 'ACT_RAPPEL_LOOP', 45: 'ACT_CROUCHIDLE', 12: 'ACT_RUN_CROUCH', 338: 'ACT_IDLE_ANGRY_MELEE', 522: 'ACT_DOTA_LOADOUT', 131: 'ACT_FLINCH_CROUCH_LEFT', 39: 'ACT_STRAFE_RIGHT', 365: 'ACT_WALK_AIM_STEALTH_PISTOL', 494: 'ACT_DOTA_ALCHEMIST_CONCOCTION', 457: 'ACT_DOTA_TAUNT', 117: 'ACT_DIE_BACKSHOT', 22: 'ACT_DIEFORWARD', 479: 'ACT_TINY_AVALANCHE', 171: 'ACT_GESTURE_TURN_LEFT45_FLAT', 509: 'ACT_DOTA_CAST_FORGE_SPIRIT', 253: 'ACT_SLAM_DETONATOR_DRAW', 434: 'ACT_DOTA_CAST_ABILITY_4', 435: 'ACT_DOTA_CAST_ABILITY_5', 436: 'ACT_DOTA_CAST_ABILITY_6', 519: 'ACT_DOTA_CAST_ABILITY_7', 478: 'ACT_DOTA_TINKER_REARM3', 222: 'ACT_SLAM_STICKWALL_ATTACH', 201: 'ACT_VM_MISSLEFT2', 351: 'ACT_WALK_CROUCH_RIFLE', 32: 'ACT_LAND', 292: 'ACT_COVER_PISTOL_LOW', 493: 'ACT_DOTA_ALCHEMIST_CHEMICAL_RAGE_START', 94: 'ACT_IDLE_AIM_STEALTH', 285: 'ACT_RANGE_ATTACK_SNIPER_RIFLE', 330: 'ACT_IDLE_SHOTGUN_RELAXED', 283: 'ACT_RANGE_ATTACK_TRIPWIRE', 416: 'ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED', 263: 'ACT_SMG2_DRAW2', 477: 'ACT_DOTA_TINKER_REARM2', 297: 'ACT_GESTURE_RANGE_ATTACK_HMG1', 578: 'ACT_DOTA_NIAN_PIN_END', 230: 'ACT_SLAM_STICKWALL_TO_THROW', 480: 'ACT_TINY_TOSS', 517: 'ACT_DOTA_TELEPORT_END', 89: 'ACT_RUN_AGITATED', 362: 'ACT_WALK_AIM_PISTOL', 374: 'ACT_GESTURE_RELOAD_PISTOL', 314: 'ACT_IDLE_ANGRY_PISTOL', 463: 'ACT_DOTA_CAST_ABILITY_3_END', 128: 'ACT_FLINCH_STOMACH_BACK', 204: 'ACT_VM_MISSCENTER', 326: 'ACT_RUN_RIFLE_STIMULATED', 505: 'ACT_DOTA_CAST_EMP', 535: 'ACT_DOTA_BELLYACHE_END', 40: 'ACT_ROLL_LEFT', 404: 'ACT_DI_ALYX_ZOMBIE_TORSO_MELEE', 11: 'ACT_RUN_AIM', 556: 'ACT_DOTA_PRESENT_ITEM', 567: 'ACT_DOTA_CAGED_CREEP_SMASH', 531: 'ACT_DOTA_RELAX_END', 557: 'ACT_DOTA_IDLE_IMPATIENT', 271: 'ACT_RANGE_ATTACK_AR2_LOW', 468: 'ACT_DOTA_CAST_ABILITY_ROT', 550: 'ACT_DOTA_STARTLE', 18: 'ACT_RANGE_ATTACK1_LOW', 295: 'ACT_GESTURE_RANGE_ATTACK_AR2', 294: 'ACT_GESTURE_RANGE_ATTACK_AR1', 475: 'ACT_STORM_SPIRIT_OVERLOAD_RUN_OVERRIDE', 3: 'ACT_COVER', 19: 'ACT_RANGE_ATTACK2_LOW', 523: 'ACT_DOTA_FORCESTAFF_END', 2: 'ACT_TRANSITION', 402: 'ACT_OPEN_DOOR', 168: 'ACT_GESTURE_TURN_RIGHT45', 352: 'ACT_WALK_CROUCH_AIM_RIFLE', 199: 'ACT_VM_HITCENTER2', 175: 'ACT_BARNACLE_HIT', 310: 'ACT_IDLE_RIFLE', 530: 'ACT_DOTA_RELAX_LOOP', 296: 'ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE', 211: 'ACT_VM_IDLE_LOWERED', 398: 'ACT_DIE_FRONTSIDE', 216: 'ACT_VM_PICKUP', 262: 'ACT_SMG2_FIRE2', 180: 'ACT_SPECIFIC_SEQUENCE', 513: 'ACT_DOTA_DEFEAT', 100: 'ACT_RUN_AIM_STIMULATED', 389: 'ACT_BUSY_STAND', 85: 'ACT_WALK_AGITATED', 429: 'ACT_DOTA_FLAIL', 400: 'ACT_DIE_BACKSIDE', 261: 'ACT_SMG2_IDLE2', 412: 'ACT_READINESS_STIMULATED_TO_RELAXED', 548: 'ACT_DOTA_AMBUSH', 1: 'ACT_IDLE', 538: 'ACT_DOTA_GREEVIL_CAST', 8: 'ACT_WALK_CROUCH', 35: 'ACT_CLIMB_DISMOUNT', 62: 'ACT_COWER', 303: 'ACT_GESTURE_RANGE_ATTACK_PISTOL', 336: 'ACT_IDLE_MANNEDGUN', 179: 'ACT_DO_NOT_DISTURB', 353: 'ACT_RUN_RIFLE', 337: 'ACT_IDLE_MELEE', 61: 'ACT_LOOKBACK_LEFT', 81: 'ACT_IDLE_STEALTH', 82: 'ACT_IDLE_HURT', 551: 'ACT_DOTA_FRUSTRATION', 234: 'ACT_SLAM_THROW_ND_IDLE', 141: 'ACT_STEP_LEFT', 43: 'ACT_TURN_RIGHT', 570: 'ACT_DOTA_INTRO_LOOP', 325: 'ACT_WALK_RIFLE_STIMULATED', 87: 'ACT_RUN_RELAXED', 459: 'ACT_DOTA_CAST_DRAGONBREATH'}

@classmethod
def get_Activity_name(cls, v):
    return cls._Activity__map[v]

# Enumeration: EDemoCommands

DEM_Error = -1

DEM_Stop = 0

DEM_FileHeader = 1

DEM_FileInfo = 2

DEM_SyncTick = 3

DEM_SendTables = 4

DEM_ClassInfo = 5

DEM_StringTables = 6

DEM_Packet = 7

DEM_SignonPacket = 8

DEM_ConsoleCmd = 9

DEM_CustomData = 10

DEM_CustomDataCallbacks = 11

DEM_UserCmd = 12

DEM_FullPacket = 13

DEM_SaveGame = 14

DEM_Max = 15

DEM_IsCompressed = 112

TYPE_EDemoCommands = ProtoBase.TYPE_int32

_EDemoCommands__map = {112: 'DEM_IsCompressed', 3: 'DEM_SyncTick', -1: 'DEM_Error', 5: 'DEM_ClassInfo', 2: 'DEM_FileInfo', 1: 'DEM_FileHeader', 7: 'DEM_Packet', 0: 'DEM_Stop', 8: 'DEM_SignonPacket', 13: 'DEM_FullPacket', 10: 'DEM_CustomData', 11: 'DEM_CustomDataCallbacks', 15: 'DEM_Max', 4: 'DEM_SendTables', 12: 'DEM_UserCmd', 14: 'DEM_SaveGame', 9: 'DEM_ConsoleCmd', 6: 'DEM_StringTables'}

@classmethod
def get_EDemoCommands_name(cls, v):
    return cls._EDemoCommands__map[v]

# Enumeration: EDOTAChatWheelMessage

k_EDOTA_CW_Ok = 0

k_EDOTA_CW_Care = 1

k_EDOTA_CW_GetBack = 2

k_EDOTA_CW_NeedWards = 3

k_EDOTA_CW_Stun = 4

k_EDOTA_CW_Help = 5

k_EDOTA_CW_Push = 6

k_EDOTA_CW_GoodJob = 7

k_EDOTA_CW_Missing = 8

k_EDOTA_CW_Missing_Top = 9

k_EDOTA_CW_Missing_Mid = 10

k_EDOTA_CW_Missing_Bottom = 11

k_EDOTA_CW_Go = 12

k_EDOTA_CW_Initiate = 13

k_EDOTA_CW_Follow = 14

k_EDOTA_CW_Group_Up = 15

k_EDOTA_CW_Spread_Out = 16

k_EDOTA_CW_Split_Farm = 17

k_EDOTA_CW_Attack = 18

k_EDOTA_CW_BRB = 19

k_EDOTA_CW_Dive = 20

k_EDOTA_CW_OMW = 21

k_EDOTA_CW_Get_Ready = 22

k_EDOTA_CW_Bait = 23

k_EDOTA_CW_Heal = 24

k_EDOTA_CW_Mana = 25

k_EDOTA_CW_OOM = 26

k_EDOTA_CW_Skill_Cooldown = 27

k_EDOTA_CW_Ulti_Ready = 28

k_EDOTA_CW_Enemy_Returned = 29

k_EDOTA_CW_All_Missing = 30

k_EDOTA_CW_Enemy_Incoming = 31

k_EDOTA_CW_Invis_Enemy = 32

k_EDOTA_CW_Enemy_Had_Rune = 33

k_EDOTA_CW_Split_Push = 34

k_EDOTA_CW_Coming_To_Gank = 35

k_EDOTA_CW_Request_Gank = 36

k_EDOTA_CW_Fight_Under_Tower = 37

k_EDOTA_CW_Deny_Tower = 38

k_EDOTA_CW_Buy_Courier = 39

k_EDOTA_CW_Upgrade_Courier = 40

k_EDOTA_CW_Need_Detection = 41

k_EDOTA_CW_They_Have_Detection = 42

k_EDOTA_CW_Buy_TP = 43

k_EDOTA_CW_Reuse_Courier = 44

k_EDOTA_CW_Deward = 45

k_EDOTA_CW_Building_Mek = 46

k_EDOTA_CW_Building_Pipe = 47

k_EDOTA_CW_Stack_And_Pull = 48

k_EDOTA_CW_Pull = 49

k_EDOTA_CW_Pulling = 50

k_EDOTA_CW_Stack = 51

k_EDOTA_CW_Jungling = 52

k_EDOTA_CW_Roshan = 53

k_EDOTA_CW_Affirmative = 54

k_EDOTA_CW_Wait = 55

k_EDOTA_CW_Pause = 56

k_EDOTA_CW_Current_Time = 57

k_EDOTA_CW_Check_Runes = 58

k_EDOTA_CW_Smoke_Gank = 59

k_EDOTA_CW_GLHF = 60

k_EDOTA_CW_Nice = 61

k_EDOTA_CW_Thanks = 62

k_EDOTA_CW_Sorry = 63

k_EDOTA_CW_No_Give_Up = 64

k_EDOTA_CW_Just_Happened = 65

k_EDOTA_CW_Game_Is_Hard = 66

k_EDOTA_CW_New_Meta = 67

k_EDOTA_CW_My_Bad = 68

k_EDOTA_CW_Regret = 69

k_EDOTA_CW_Relax = 70

k_EDOTA_CW_MissingHero = 71

k_EDOTA_CW_ReturnedHero = 72

TYPE_EDOTAChatWheelMessage = ProtoBase.TYPE_int32

_EDOTAChatWheelMessage__map = {60: 'k_EDOTA_CW_GLHF', 3: 'k_EDOTA_CW_NeedWards', 43: 'k_EDOTA_CW_Buy_TP', 66: 'k_EDOTA_CW_Game_Is_Hard', 17: 'k_EDOTA_CW_Split_Farm', 62: 'k_EDOTA_CW_Thanks', 13: 'k_EDOTA_CW_Initiate', 34: 'k_EDOTA_CW_Split_Push', 24: 'k_EDOTA_CW_Heal', 33: 'k_EDOTA_CW_Enemy_Had_Rune', 50: 'k_EDOTA_CW_Pulling', 41: 'k_EDOTA_CW_Need_Detection', 70: 'k_EDOTA_CW_Relax', 57: 'k_EDOTA_CW_Current_Time', 5: 'k_EDOTA_CW_Help', 2: 'k_EDOTA_CW_GetBack', 71: 'k_EDOTA_CW_MissingHero', 36: 'k_EDOTA_CW_Request_Gank', 7: 'k_EDOTA_CW_GoodJob', 23: 'k_EDOTA_CW_Bait', 54: 'k_EDOTA_CW_Affirmative', 18: 'k_EDOTA_CW_Attack', 11: 'k_EDOTA_CW_Missing_Bottom', 35: 'k_EDOTA_CW_Coming_To_Gank', 42: 'k_EDOTA_CW_They_Have_Detection', 45: 'k_EDOTA_CW_Deward', 37: 'k_EDOTA_CW_Fight_Under_Tower', 55: 'k_EDOTA_CW_Wait', 0: 'k_EDOTA_CW_Ok', 14: 'k_EDOTA_CW_Follow', 10: 'k_EDOTA_CW_Missing_Mid', 8: 'k_EDOTA_CW_Missing', 46: 'k_EDOTA_CW_Building_Mek', 67: 'k_EDOTA_CW_New_Meta', 22: 'k_EDOTA_CW_Get_Ready', 63: 'k_EDOTA_CW_Sorry', 68: 'k_EDOTA_CW_My_Bad', 51: 'k_EDOTA_CW_Stack', 56: 'k_EDOTA_CW_Pause', 39: 'k_EDOTA_CW_Buy_Courier', 64: 'k_EDOTA_CW_No_Give_Up', 21: 'k_EDOTA_CW_OMW', 69: 'k_EDOTA_CW_Regret', 28: 'k_EDOTA_CW_Ulti_Ready', 61: 'k_EDOTA_CW_Nice', 27: 'k_EDOTA_CW_Skill_Cooldown', 4: 'k_EDOTA_CW_Stun', 58: 'k_EDOTA_CW_Check_Runes', 16: 'k_EDOTA_CW_Spread_Out', 65: 'k_EDOTA_CW_Just_Happened', 12: 'k_EDOTA_CW_Go', 40: 'k_EDOTA_CW_Upgrade_Courier', 53: 'k_EDOTA_CW_Roshan', 59: 'k_EDOTA_CW_Smoke_Gank', 48: 'k_EDOTA_CW_Stack_And_Pull', 31: 'k_EDOTA_CW_Enemy_Incoming', 38: 'k_EDOTA_CW_Deny_Tower', 1: 'k_EDOTA_CW_Care', 49: 'k_EDOTA_CW_Pull', 26: 'k_EDOTA_CW_OOM', 15: 'k_EDOTA_CW_Group_Up', 19: 'k_EDOTA_CW_BRB', 72: 'k_EDOTA_CW_ReturnedHero', 52: 'k_EDOTA_CW_Jungling', 6: 'k_EDOTA_CW_Push', 25: 'k_EDOTA_CW_Mana', 30: 'k_EDOTA_CW_All_Missing', 29: 'k_EDOTA_CW_Enemy_Returned', 9: 'k_EDOTA_CW_Missing_Top', 47: 'k_EDOTA_CW_Building_Pipe', 20: 'k_EDOTA_CW_Dive', 32: 'k_EDOTA_CW_Invis_Enemy', 44: 'k_EDOTA_CW_Reuse_Courier'}

@classmethod
def get_EDOTAChatWheelMessage_name(cls, v):
    return cls._EDOTAChatWheelMessage__map[v]

# Enumeration: EDOTAStatPopupTypes

k_EDOTA_SPT_Textline = 0

k_EDOTA_SPT_Basic = 1

k_EDOTA_SPT_Poll = 2

TYPE_EDOTAStatPopupTypes = ProtoBase.TYPE_int32

_EDOTAStatPopupTypes__map = {1: 'k_EDOTA_SPT_Basic', 0: 'k_EDOTA_SPT_Textline', 2: 'k_EDOTA_SPT_Poll'}

@classmethod
def get_EDOTAStatPopupTypes_name(cls, v):
    return cls._EDOTAStatPopupTypes__map[v]

# Enumeration: DOTA_MODIFIER_ENTRY_TYPE

DOTA_MODIFIER_ENTRY_TYPE_ACTIVE = 1

DOTA_MODIFIER_ENTRY_TYPE_REMOVED = 2

TYPE_DOTA_MODIFIER_ENTRY_TYPE = ProtoBase.TYPE_int32

_DOTA_MODIFIER_ENTRY_TYPE__map = {1: 'DOTA_MODIFIER_ENTRY_TYPE_ACTIVE', 2: 'DOTA_MODIFIER_ENTRY_TYPE_REMOVED'}

@classmethod
def get_DOTA_MODIFIER_ENTRY_TYPE_name(cls, v):
    return cls._DOTA_MODIFIER_ENTRY_TYPE__map[v]

# Enumeration: EDotaUserMessages

DOTA_UM_AddUnitToSelection = 64

DOTA_UM_AIDebugLine = 65

DOTA_UM_ChatEvent = 66

DOTA_UM_CombatHeroPositions = 67

DOTA_UM_CombatLogData = 68

DOTA_UM_CombatLogShowDeath = 70

DOTA_UM_CreateLinearProjectile = 71

DOTA_UM_DestroyLinearProjectile = 72

DOTA_UM_DodgeTrackingProjectiles = 73

DOTA_UM_GlobalLightColor = 74

DOTA_UM_GlobalLightDirection = 75

DOTA_UM_InvalidCommand = 76

DOTA_UM_LocationPing = 77

DOTA_UM_MapLine = 78

DOTA_UM_MiniKillCamInfo = 79

DOTA_UM_MinimapDebugPoint = 80

DOTA_UM_MinimapEvent = 81

DOTA_UM_NevermoreRequiem = 82

DOTA_UM_OverheadEvent = 83

DOTA_UM_SetNextAutobuyItem = 84

DOTA_UM_SharedCooldown = 85

DOTA_UM_SpectatorPlayerClick = 86

DOTA_UM_TutorialTipInfo = 87

DOTA_UM_UnitEvent = 88

DOTA_UM_ParticleManager = 89

DOTA_UM_BotChat = 90

DOTA_UM_HudError = 91

DOTA_UM_ItemPurchased = 92

DOTA_UM_Ping = 93

DOTA_UM_ItemFound = 94

DOTA_UM_CharacterSpeakConcept = 95

DOTA_UM_SwapVerify = 96

DOTA_UM_WorldLine = 97

DOTA_UM_TournamentDrop = 98

DOTA_UM_ItemAlert = 99

DOTA_UM_HalloweenDrops = 100

DOTA_UM_ChatWheel = 101

DOTA_UM_ReceivedXmasGift = 102

DOTA_UM_UpdateSharedContent = 103

DOTA_UM_TutorialRequestExp = 104

DOTA_UM_TutorialPingMinimap = 105

DOTA_UM_GamerulesStateChanged = 106

DOTA_UM_ShowSurvey = 107

DOTA_UM_TutorialFade = 108

DOTA_UM_AddQuestLogEntry = 109

DOTA_UM_SendStatPopup = 110

DOTA_UM_TutorialFinish = 111

DOTA_UM_SendRoshanPopup = 112

DOTA_UM_SendGenericToolTip = 113

DOTA_UM_SendFinalGold = 114

DOTA_UM_CustomMsg = 115

DOTA_UM_CoachHUDPing = 116

DOTA_UM_ClientLoadGridNav = 117

DOTA_UM_AbilityPing = 118

DOTA_UM_ShowGenericPopup = 119

DOTA_UM_VoteStart = 120

DOTA_UM_VoteUpdate = 121

DOTA_UM_VoteEnd = 122

DOTA_UM_BoosterState = 123

DOTA_UM_WillPurchaseAlert = 124

DOTA_UM_TutorialMinimapPosition = 125

DOTA_UM_PlayerMMR = 126

DOTA_UM_AbilitySteal = 127

TYPE_EDotaUserMessages = ProtoBase.TYPE_int32

_EDotaUserMessages__map = {95: 'DOTA_UM_CharacterSpeakConcept', 66: 'DOTA_UM_ChatEvent', 83: 'DOTA_UM_OverheadEvent', 67: 'DOTA_UM_CombatHeroPositions', 118: 'DOTA_UM_AbilityPing', 126: 'DOTA_UM_PlayerMMR', 93: 'DOTA_UM_Ping', 119: 'DOTA_UM_ShowGenericPopup', 88: 'DOTA_UM_UnitEvent', 110: 'DOTA_UM_SendStatPopup', 98: 'DOTA_UM_TournamentDrop', 84: 'DOTA_UM_SetNextAutobuyItem', 100: 'DOTA_UM_HalloweenDrops', 96: 'DOTA_UM_SwapVerify', 120: 'DOTA_UM_VoteStart', 64: 'DOTA_UM_AddUnitToSelection', 121: 'DOTA_UM_VoteUpdate', 87: 'DOTA_UM_TutorialTipInfo', 103: 'DOTA_UM_UpdateSharedContent', 106: 'DOTA_UM_GamerulesStateChanged', 122: 'DOTA_UM_VoteEnd', 94: 'DOTA_UM_ItemFound', 117: 'DOTA_UM_ClientLoadGridNav', 91: 'DOTA_UM_HudError', 111: 'DOTA_UM_TutorialFinish', 85: 'DOTA_UM_SharedCooldown', 115: 'DOTA_UM_CustomMsg', 123: 'DOTA_UM_BoosterState', 102: 'DOTA_UM_ReceivedXmasGift', 113: 'DOTA_UM_SendGenericToolTip', 92: 'DOTA_UM_ItemPurchased', 104: 'DOTA_UM_TutorialRequestExp', 127: 'DOTA_UM_AbilitySteal', 107: 'DOTA_UM_ShowSurvey', 114: 'DOTA_UM_SendFinalGold', 73: 'DOTA_UM_DodgeTrackingProjectiles', 68: 'DOTA_UM_CombatLogData', 108: 'DOTA_UM_TutorialFade', 76: 'DOTA_UM_InvalidCommand', 124: 'DOTA_UM_WillPurchaseAlert', 80: 'DOTA_UM_MinimapDebugPoint', 90: 'DOTA_UM_BotChat', 82: 'DOTA_UM_NevermoreRequiem', 86: 'DOTA_UM_SpectatorPlayerClick', 65: 'DOTA_UM_AIDebugLine', 89: 'DOTA_UM_ParticleManager', 97: 'DOTA_UM_WorldLine', 72: 'DOTA_UM_DestroyLinearProjectile', 112: 'DOTA_UM_SendRoshanPopup', 79: 'DOTA_UM_MiniKillCamInfo', 70: 'DOTA_UM_CombatLogShowDeath', 105: 'DOTA_UM_TutorialPingMinimap', 109: 'DOTA_UM_AddQuestLogEntry', 71: 'DOTA_UM_CreateLinearProjectile', 78: 'DOTA_UM_MapLine', 116: 'DOTA_UM_CoachHUDPing', 125: 'DOTA_UM_TutorialMinimapPosition', 101: 'DOTA_UM_ChatWheel', 74: 'DOTA_UM_GlobalLightColor', 75: 'DOTA_UM_GlobalLightDirection', 99: 'DOTA_UM_ItemAlert', 77: 'DOTA_UM_LocationPing', 81: 'DOTA_UM_MinimapEvent'}

@classmethod
def get_EDotaUserMessages_name(cls, v):
    return cls._EDotaUserMessages__map[v]

# Enumeration: DOTA_CHAT_MESSAGE

CHAT_MESSAGE_INVALID = -1

CHAT_MESSAGE_HERO_KILL = 0

CHAT_MESSAGE_HERO_DENY = 1

CHAT_MESSAGE_BARRACKS_KILL = 2

CHAT_MESSAGE_TOWER_KILL = 3

CHAT_MESSAGE_TOWER_DENY = 4

CHAT_MESSAGE_FIRSTBLOOD = 5

CHAT_MESSAGE_STREAK_KILL = 6

CHAT_MESSAGE_BUYBACK = 7

CHAT_MESSAGE_AEGIS = 8

CHAT_MESSAGE_ROSHAN_KILL = 9

CHAT_MESSAGE_COURIER_LOST = 10

CHAT_MESSAGE_COURIER_RESPAWNED = 11

CHAT_MESSAGE_GLYPH_USED = 12

CHAT_MESSAGE_ITEM_PURCHASE = 13

CHAT_MESSAGE_CONNECT = 14

CHAT_MESSAGE_DISCONNECT = 15

CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT = 16

CHAT_MESSAGE_DISCONNECT_TIME_REMAINING = 17

CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL = 18

CHAT_MESSAGE_RECONNECT = 19

CHAT_MESSAGE_PLAYER_LEFT = 20

CHAT_MESSAGE_SAFE_TO_LEAVE = 21

CHAT_MESSAGE_RUNE_PICKUP = 22

CHAT_MESSAGE_RUNE_BOTTLE = 23

CHAT_MESSAGE_INTHEBAG = 24

CHAT_MESSAGE_SECRETSHOP = 25

CHAT_MESSAGE_ITEM_AUTOPURCHASED = 26

CHAT_MESSAGE_ITEMS_COMBINED = 27

CHAT_MESSAGE_SUPER_CREEPS = 28

CHAT_MESSAGE_CANT_USE_ACTION_ITEM = 29

CHAT_MESSAGE_CHARGES_EXHAUSTED = 30

CHAT_MESSAGE_CANTPAUSE = 31

CHAT_MESSAGE_NOPAUSESLEFT = 32

CHAT_MESSAGE_CANTPAUSEYET = 33

CHAT_MESSAGE_PAUSED = 34

CHAT_MESSAGE_UNPAUSE_COUNTDOWN = 35

CHAT_MESSAGE_UNPAUSED = 36

CHAT_MESSAGE_AUTO_UNPAUSED = 37

CHAT_MESSAGE_YOUPAUSED = 38

CHAT_MESSAGE_CANTUNPAUSETEAM = 39

CHAT_MESSAGE_VOICE_TEXT_BANNED = 41

CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME = 42

CHAT_MESSAGE_REPORT_REMINDER = 43

CHAT_MESSAGE_ECON_ITEM = 44

CHAT_MESSAGE_TAUNT = 45

CHAT_MESSAGE_RANDOM = 46

CHAT_MESSAGE_RD_TURN = 47

CHAT_MESSAGE_DROP_RATE_BONUS = 49

CHAT_MESSAGE_NO_BATTLE_POINTS = 50

CHAT_MESSAGE_DENIED_AEGIS = 51

CHAT_MESSAGE_INFORMATIONAL = 52

CHAT_MESSAGE_AEGIS_STOLEN = 53

CHAT_MESSAGE_ROSHAN_CANDY = 54

CHAT_MESSAGE_ITEM_GIFTED = 55

CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL = 56

CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED = 57

CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED = 58

CHAT_MESSAGE_HOLDOUT_WALL_FINISHED = 59

CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO = 62

CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION = 63

CHAT_MESSAGE_DISCONNECT_LIMITED_HERO = 64

CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION = 65

CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS = 66

CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE = 67

CHAT_MESSAGE_PLAYER_LEFT_AFK = 73

CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG = 74

CHAT_MESSAGE_PLAYER_ABANDONED = 75

CHAT_MESSAGE_PLAYER_ABANDONED_AFK = 76

CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG = 77

CHAT_MESSAGE_WILL_NOT_BE_SCORED = 78

CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED = 79

CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK = 80

CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED = 81

CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON = 82

CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS = 83

CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY = 84

CHAT_MESSAGE_COMPENDIUM_LEVEL = 85

TYPE_DOTA_CHAT_MESSAGE = ProtoBase.TYPE_int32

_DOTA_CHAT_MESSAGE__map = {24: 'CHAT_MESSAGE_INTHEBAG', 6: 'CHAT_MESSAGE_STREAK_KILL', 18: 'CHAT_MESSAGE_DISCONNECT_TIME_REMAINING_PLURAL', 80: 'CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK', 56: 'CHAT_MESSAGE_HERO_KILL_WITH_GREEVIL', 15: 'CHAT_MESSAGE_DISCONNECT', 1: 'CHAT_MESSAGE_HERO_DENY', 28: 'CHAT_MESSAGE_SUPER_CREEPS', 32: 'CHAT_MESSAGE_NOPAUSESLEFT', 21: 'CHAT_MESSAGE_SAFE_TO_LEAVE', 84: 'CHAT_MESSAGE_ABANDON_RANKED_BEFORE_FIRST_BLOOD_PARTY', 31: 'CHAT_MESSAGE_CANTPAUSE', 17: 'CHAT_MESSAGE_DISCONNECT_TIME_REMAINING', 85: 'CHAT_MESSAGE_COMPENDIUM_LEVEL', 58: 'CHAT_MESSAGE_HOLDOUT_WALL_DESTROYED', 75: 'CHAT_MESSAGE_PLAYER_ABANDONED', 5: 'CHAT_MESSAGE_FIRSTBLOOD', 39: 'CHAT_MESSAGE_CANTUNPAUSETEAM', 11: 'CHAT_MESSAGE_COURIER_RESPAWNED', 3: 'CHAT_MESSAGE_TOWER_KILL', 2: 'CHAT_MESSAGE_BARRACKS_KILL', 7: 'CHAT_MESSAGE_BUYBACK', 29: 'CHAT_MESSAGE_CANT_USE_ACTION_ITEM', 44: 'CHAT_MESSAGE_ECON_ITEM', 51: 'CHAT_MESSAGE_DENIED_AEGIS', 65: 'CHAT_MESSAGE_LOW_PRIORITY_COMPLETED_EXPLANATION', 38: 'CHAT_MESSAGE_YOUPAUSED', 50: 'CHAT_MESSAGE_NO_BATTLE_POINTS', 33: 'CHAT_MESSAGE_CANTPAUSEYET', 37: 'CHAT_MESSAGE_AUTO_UNPAUSED', 43: 'CHAT_MESSAGE_REPORT_REMINDER', 79: 'CHAT_MESSAGE_WILL_NOT_BE_SCORED_RANKED', 25: 'CHAT_MESSAGE_SECRETSHOP', 12: 'CHAT_MESSAGE_GLYPH_USED', 62: 'CHAT_MESSAGE_PLAYER_LEFT_LIMITED_HERO', 42: 'CHAT_MESSAGE_SPECTATORS_WATCHING_THIS_GAME', 41: 'CHAT_MESSAGE_VOICE_TEXT_BANNED', 77: 'CHAT_MESSAGE_PLAYER_ABANDONED_DISCONNECTED_TOO_LONG', 63: 'CHAT_MESSAGE_ABANDON_LIMITED_HERO_EXPLANATION', 83: 'CHAT_MESSAGE_RANKED_GAME_STILL_SCORED_LEAVERS_GET_LOSS', 66: 'CHAT_MESSAGE_RECRUITMENT_DROP_RATE_BONUS', 46: 'CHAT_MESSAGE_RANDOM', 35: 'CHAT_MESSAGE_UNPAUSE_COUNTDOWN', 53: 'CHAT_MESSAGE_AEGIS_STOLEN', 82: 'CHAT_MESSAGE_CAN_QUIT_WITHOUT_ABANDON', 23: 'CHAT_MESSAGE_RUNE_BOTTLE', 16: 'CHAT_MESSAGE_DISCONNECT_WAIT_FOR_RECONNECT', 55: 'CHAT_MESSAGE_ITEM_GIFTED', 9: 'CHAT_MESSAGE_ROSHAN_KILL', 22: 'CHAT_MESSAGE_RUNE_PICKUP', 19: 'CHAT_MESSAGE_RECONNECT', -1: 'CHAT_MESSAGE_INVALID', 76: 'CHAT_MESSAGE_PLAYER_ABANDONED_AFK', 64: 'CHAT_MESSAGE_DISCONNECT_LIMITED_HERO', 81: 'CHAT_MESSAGE_WILL_NOT_BE_SCORED_NETWORK_RANKED', 59: 'CHAT_MESSAGE_HOLDOUT_WALL_FINISHED', 30: 'CHAT_MESSAGE_CHARGES_EXHAUSTED', 74: 'CHAT_MESSAGE_PLAYER_LEFT_DISCONNECTED_TOO_LONG', 52: 'CHAT_MESSAGE_INFORMATIONAL', 57: 'CHAT_MESSAGE_HOLDOUT_TOWER_DESTROYED', 0: 'CHAT_MESSAGE_HERO_KILL', 4: 'CHAT_MESSAGE_TOWER_DENY', 49: 'CHAT_MESSAGE_DROP_RATE_BONUS', 13: 'CHAT_MESSAGE_ITEM_PURCHASE', 47: 'CHAT_MESSAGE_RD_TURN', 27: 'CHAT_MESSAGE_ITEMS_COMBINED', 73: 'CHAT_MESSAGE_PLAYER_LEFT_AFK', 8: 'CHAT_MESSAGE_AEGIS', 45: 'CHAT_MESSAGE_TAUNT', 26: 'CHAT_MESSAGE_ITEM_AUTOPURCHASED', 78: 'CHAT_MESSAGE_WILL_NOT_BE_SCORED', 34: 'CHAT_MESSAGE_PAUSED', 54: 'CHAT_MESSAGE_ROSHAN_CANDY', 20: 'CHAT_MESSAGE_PLAYER_LEFT', 36: 'CHAT_MESSAGE_UNPAUSED', 67: 'CHAT_MESSAGE_FROSTIVUS_SHINING_BOOSTER_ACTIVE', 14: 'CHAT_MESSAGE_CONNECT', 10: 'CHAT_MESSAGE_COURIER_LOST'}

@classmethod
def get_DOTA_CHAT_MESSAGE_name(cls, v):
    return cls._DOTA_CHAT_MESSAGE__map[v]

# Enumeration: DOTA_NO_BATTLE_POINTS_REASONS

NO_BATTLE_POINTS_WRONG_LOBBY_TYPE = 1

NO_BATTLE_POINTS_PRACTICE_BOTS = 2

NO_BATTLE_POINTS_CHEATS_ENABLED = 3

NO_BATTLE_POINTS_LOW_PRIORITY = 4

TYPE_DOTA_NO_BATTLE_POINTS_REASONS = ProtoBase.TYPE_int32

_DOTA_NO_BATTLE_POINTS_REASONS__map = {3: 'NO_BATTLE_POINTS_CHEATS_ENABLED', 1: 'NO_BATTLE_POINTS_WRONG_LOBBY_TYPE', 4: 'NO_BATTLE_POINTS_LOW_PRIORITY', 2: 'NO_BATTLE_POINTS_PRACTICE_BOTS'}

@classmethod
def get_DOTA_NO_BATTLE_POINTS_REASONS_name(cls, v):
    return cls._DOTA_NO_BATTLE_POINTS_REASONS__map[v]

# Enumeration: DOTA_CHAT_INFORMATIONAL

INFO_COOP_BATTLE_POINTS_RULES = 1

INFO_FROSTIVUS_ABANDON_REMINDER = 2

INFO_RANKED_REMINDER = 3

INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER = 4

TYPE_DOTA_CHAT_INFORMATIONAL = ProtoBase.TYPE_int32

_DOTA_CHAT_INFORMATIONAL__map = {4: 'INFO_COOP_LOW_PRIORITY_PASSIVE_REMINDER', 3: 'INFO_RANKED_REMINDER', 1: 'INFO_COOP_BATTLE_POINTS_RULES', 2: 'INFO_FROSTIVUS_ABANDON_REMINDER'}

@classmethod
def get_DOTA_CHAT_INFORMATIONAL_name(cls, v):
    return cls._DOTA_CHAT_INFORMATIONAL__map[v]

# Enumeration: DOTA_ABILITY_PING_TYPE

ABILITY_PING_READY = 1

ABILITY_PING_MANA = 2

ABILITY_PING_COOLDOWN = 3

TYPE_DOTA_ABILITY_PING_TYPE = ProtoBase.TYPE_int32

_DOTA_ABILITY_PING_TYPE__map = {2: 'ABILITY_PING_MANA', 3: 'ABILITY_PING_COOLDOWN', 1: 'ABILITY_PING_READY'}

@classmethod
def get_DOTA_ABILITY_PING_TYPE_name(cls, v):
    return cls._DOTA_ABILITY_PING_TYPE__map[v]

# Enumeration: DOTA_COMBATLOG_TYPES

DOTA_COMBATLOG_DAMAGE = 0

DOTA_COMBATLOG_HEAL = 1

DOTA_COMBATLOG_MODIFIER_ADD = 2

DOTA_COMBATLOG_MODIFIER_REMOVE = 3

DOTA_COMBATLOG_DEATH = 4

TYPE_DOTA_COMBATLOG_TYPES = ProtoBase.TYPE_int32

_DOTA_COMBATLOG_TYPES__map = {2: 'DOTA_COMBATLOG_MODIFIER_ADD', 4: 'DOTA_COMBATLOG_DEATH', 3: 'DOTA_COMBATLOG_MODIFIER_REMOVE', 1: 'DOTA_COMBATLOG_HEAL', 0: 'DOTA_COMBATLOG_DAMAGE'}

@classmethod
def get_DOTA_COMBATLOG_TYPES_name(cls, v):
    return cls._DOTA_COMBATLOG_TYPES__map[v]

# Enumeration: EDotaEntityMessages

DOTA_UNIT_SPEECH = 0

DOTA_UNIT_SPEECH_MUTE = 1

DOTA_UNIT_ADD_GESTURE = 2

DOTA_UNIT_REMOVE_GESTURE = 3

DOTA_UNIT_REMOVE_ALL_GESTURES = 4

DOTA_UNIT_FADE_GESTURE = 6

DOTA_UNIT_SPEECH_CLIENTSIDE_RULES = 7

TYPE_EDotaEntityMessages = ProtoBase.TYPE_int32

_EDotaEntityMessages__map = {4: 'DOTA_UNIT_REMOVE_ALL_GESTURES', 3: 'DOTA_UNIT_REMOVE_GESTURE', 2: 'DOTA_UNIT_ADD_GESTURE', 1: 'DOTA_UNIT_SPEECH_MUTE', 7: 'DOTA_UNIT_SPEECH_CLIENTSIDE_RULES', 6: 'DOTA_UNIT_FADE_GESTURE', 0: 'DOTA_UNIT_SPEECH'}

@classmethod
def get_EDotaEntityMessages_name(cls, v):
    return cls._EDotaEntityMessages__map[v]

# Enumeration: DOTA_PARTICLE_MESSAGE

DOTA_PARTICLE_MANAGER_EVENT_CREATE = 0

DOTA_PARTICLE_MANAGER_EVENT_UPDATE = 1

DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2

DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3

DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4

DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5

DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6

DOTA_PARTICLE_MANAGER_EVENT_DESTROY = 7

DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8

DOTA_PARTICLE_MANAGER_EVENT_RELEASE = 9

DOTA_PARTICLE_MANAGER_EVENT_LATENCY = 10

DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11

DOTA_PARTICLE_MANAGER_EVENT_FROZEN = 12

TYPE_DOTA_PARTICLE_MESSAGE = ProtoBase.TYPE_int32

_DOTA_PARTICLE_MESSAGE__map = {0: 'DOTA_PARTICLE_MANAGER_EVENT_CREATE', 1: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE', 12: 'DOTA_PARTICLE_MANAGER_EVENT_FROZEN', 9: 'DOTA_PARTICLE_MANAGER_EVENT_RELEASE', 5: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ENT', 6: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET', 8: 'DOTA_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING', 2: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD', 3: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION', 10: 'DOTA_PARTICLE_MANAGER_EVENT_LATENCY', 4: 'DOTA_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK', 7: 'DOTA_PARTICLE_MANAGER_EVENT_DESTROY', 11: 'DOTA_PARTICLE_MANAGER_EVENT_SHOULD_DRAW'}

@classmethod
def get_DOTA_PARTICLE_MESSAGE_name(cls, v):
    return cls._DOTA_PARTICLE_MESSAGE__map[v]

# Enumeration: DOTA_OVERHEAD_ALERT

OVERHEAD_ALERT_GOLD = 0

OVERHEAD_ALERT_DENY = 1

OVERHEAD_ALERT_CRITICAL = 2

OVERHEAD_ALERT_XP = 3

OVERHEAD_ALERT_BONUS_SPELL_DAMAGE = 4

OVERHEAD_ALERT_MISS = 5

OVERHEAD_ALERT_DAMAGE = 6

OVERHEAD_ALERT_EVADE = 7

OVERHEAD_ALERT_BLOCK = 8

OVERHEAD_ALERT_BONUS_POISON_DAMAGE = 9

OVERHEAD_ALERT_HEAL = 10

OVERHEAD_ALERT_MANA_ADD = 11

OVERHEAD_ALERT_MANA_LOSS = 12

OVERHEAD_ALERT_LAST_HIT_EARLY = 13

OVERHEAD_ALERT_LAST_HIT_CLOSE = 14

OVERHEAD_ALERT_LAST_HIT_MISS = 15

TYPE_DOTA_OVERHEAD_ALERT = ProtoBase.TYPE_int32

_DOTA_OVERHEAD_ALERT__map = {14: 'OVERHEAD_ALERT_LAST_HIT_CLOSE', 10: 'OVERHEAD_ALERT_HEAL', 11: 'OVERHEAD_ALERT_MANA_ADD', 4: 'OVERHEAD_ALERT_BONUS_SPELL_DAMAGE', 1: 'OVERHEAD_ALERT_DENY', 5: 'OVERHEAD_ALERT_MISS', 13: 'OVERHEAD_ALERT_LAST_HIT_EARLY', 12: 'OVERHEAD_ALERT_MANA_LOSS', 9: 'OVERHEAD_ALERT_BONUS_POISON_DAMAGE', 3: 'OVERHEAD_ALERT_XP', 0: 'OVERHEAD_ALERT_GOLD', 7: 'OVERHEAD_ALERT_EVADE', 6: 'OVERHEAD_ALERT_DAMAGE', 8: 'OVERHEAD_ALERT_BLOCK', 2: 'OVERHEAD_ALERT_CRITICAL', 15: 'OVERHEAD_ALERT_LAST_HIT_MISS'}

@classmethod
def get_DOTA_OVERHEAD_ALERT_name(cls, v):
    return cls._DOTA_OVERHEAD_ALERT__map[v]

# Enumeration: NET_Messages

net_NOP = 0

net_Disconnect = 1

net_File = 2

net_SplitScreenUser = 3

net_Tick = 4

net_StringCmd = 5

net_SetConVar = 6

net_SignonState = 7

TYPE_NET_Messages = ProtoBase.TYPE_int32

_NET_Messages__map = {7: 'net_SignonState', 3: 'net_SplitScreenUser', 2: 'net_File', 5: 'net_StringCmd', 1: 'net_Disconnect', 4: 'net_Tick', 6: 'net_SetConVar', 0: 'net_NOP'}

@classmethod
def get_NET_Messages_name(cls, v):
    return cls._NET_Messages__map[v]

# Enumeration: CLC_Messages

clc_ClientInfo = 8

clc_Move = 9

clc_VoiceData = 10

clc_BaselineAck = 11

clc_ListenEvents = 12

clc_RespondCvarValue = 13

clc_FileCRCCheck = 14

clc_LoadingProgress = 15

clc_SplitPlayerConnect = 16

clc_ClientMessage = 17

TYPE_CLC_Messages = ProtoBase.TYPE_int32

_CLC_Messages__map = {16: 'clc_SplitPlayerConnect', 15: 'clc_LoadingProgress', 10: 'clc_VoiceData', 13: 'clc_RespondCvarValue', 9: 'clc_Move', 8: 'clc_ClientInfo', 17: 'clc_ClientMessage', 12: 'clc_ListenEvents', 11: 'clc_BaselineAck', 14: 'clc_FileCRCCheck'}

@classmethod
def get_CLC_Messages_name(cls, v):
    return cls._CLC_Messages__map[v]

# Enumeration: VoiceDataFormat_t

VOICEDATA_FORMAT_STEAM = 0

VOICEDATA_FORMAT_ENGINE = 1

TYPE_VoiceDataFormat_t = ProtoBase.TYPE_int32

_VoiceDataFormat_t__map = {1: 'VOICEDATA_FORMAT_ENGINE', 0: 'VOICEDATA_FORMAT_STEAM'}

@classmethod
def get_VoiceDataFormat_t_name(cls, v):
    return cls._VoiceDataFormat_t__map[v]

# Enumeration: SVC_Messages

svc_ServerInfo = 8

svc_SendTable = 9

svc_ClassInfo = 10

svc_SetPause = 11

svc_CreateStringTable = 12

svc_UpdateStringTable = 13

svc_VoiceInit = 14

svc_VoiceData = 15

svc_Print = 16

svc_Sounds = 17

svc_SetView = 18

svc_FixAngle = 19

svc_CrosshairAngle = 20

svc_BSPDecal = 21

svc_SplitScreen = 22

svc_UserMessage = 23

svc_EntityMessage = 24

svc_GameEvent = 25

svc_PacketEntities = 26

svc_TempEntities = 27

svc_Prefetch = 28

svc_Menu = 29

svc_GameEventList = 30

svc_GetCvarValue = 31

svc_PacketReliable = 32

TYPE_SVC_Messages = ProtoBase.TYPE_int32

_SVC_Messages__map = {18: 'svc_SetView', 24: 'svc_EntityMessage', 23: 'svc_UserMessage', 32: 'svc_PacketReliable', 16: 'svc_Print', 30: 'svc_GameEventList', 31: 'svc_GetCvarValue', 26: 'svc_PacketEntities', 11: 'svc_SetPause', 25: 'svc_GameEvent', 22: 'svc_SplitScreen', 14: 'svc_VoiceInit', 9: 'svc_SendTable', 10: 'svc_ClassInfo', 17: 'svc_Sounds', 28: 'svc_Prefetch', 8: 'svc_ServerInfo', 29: 'svc_Menu', 21: 'svc_BSPDecal', 15: 'svc_VoiceData', 12: 'svc_CreateStringTable', 13: 'svc_UpdateStringTable', 19: 'svc_FixAngle', 27: 'svc_TempEntities', 20: 'svc_CrosshairAngle'}

@classmethod
def get_SVC_Messages_name(cls, v):
    return cls._SVC_Messages__map[v]

# Enumeration: ESplitScreenMessageType

MSG_SPLITSCREEN_ADDUSER = 0

MSG_SPLITSCREEN_REMOVEUSER = 1

TYPE_ESplitScreenMessageType = ProtoBase.TYPE_int32

_ESplitScreenMessageType__map = {0: 'MSG_SPLITSCREEN_ADDUSER', 1: 'MSG_SPLITSCREEN_REMOVEUSER'}

@classmethod
def get_ESplitScreenMessageType_name(cls, v):
    return cls._ESplitScreenMessageType__map[v]

# Enumeration: ENetworkDisconnectionReason

NETWORK_DISCONNECT_INVALID = 0

NETWORK_DISCONNECT_SHUTDOWN = 1

NETWORK_DISCONNECT_DISCONNECT_BY_USER = 2

NETWORK_DISCONNECT_DISCONNECT_BY_SERVER = 3

NETWORK_DISCONNECT_LOST = 4

NETWORK_DISCONNECT_OVERFLOW = 5

NETWORK_DISCONNECT_STEAM_BANNED = 6

NETWORK_DISCONNECT_STEAM_INUSE = 7

NETWORK_DISCONNECT_STEAM_TICKET = 8

NETWORK_DISCONNECT_STEAM_LOGON = 9

NETWORK_DISCONNECT_STEAM_AUTHCANCELLED = 10

NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED = 11

NETWORK_DISCONNECT_STEAM_AUTHINVALID = 12

NETWORK_DISCONNECT_STEAM_VACBANSTATE = 13

NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE = 14

NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT = 15

NETWORK_DISCONNECT_STEAM_DROPPED = 16

NETWORK_DISCONNECT_STEAM_OWNERSHIP = 17

NETWORK_DISCONNECT_SERVERINFO_OVERFLOW = 18

NETWORK_DISCONNECT_TICKMSG_OVERFLOW = 19

NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW = 20

NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW = 21

NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW = 22

NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW = 23

NETWORK_DISCONNECT_SNAPSHOTOVERFLOW = 24

NETWORK_DISCONNECT_SNAPSHOTERROR = 25

NETWORK_DISCONNECT_RELIABLEOVERFLOW = 26

NETWORK_DISCONNECT_BADDELTATICK = 27

NETWORK_DISCONNECT_NOMORESPLITS = 28

NETWORK_DISCONNECT_TIMEDOUT = 29

NETWORK_DISCONNECT_DISCONNECTED = 30

NETWORK_DISCONNECT_LEAVINGSPLIT = 31

NETWORK_DISCONNECT_DIFFERENTCLASSTABLES = 32

NETWORK_DISCONNECT_BADRELAYPASSWORD = 33

NETWORK_DISCONNECT_BADSPECTATORPASSWORD = 34

NETWORK_DISCONNECT_HLTVRESTRICTED = 35

NETWORK_DISCONNECT_NOSPECTATORS = 36

NETWORK_DISCONNECT_HLTVUNAVAILABLE = 37

NETWORK_DISCONNECT_HLTVSTOP = 38

NETWORK_DISCONNECT_KICKED = 39

NETWORK_DISCONNECT_BANADDED = 40

NETWORK_DISCONNECT_KICKBANADDED = 41

NETWORK_DISCONNECT_HLTVDIRECT = 42

NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA = 43

NETWORK_DISCONNECT_PURESERVER_MISMATCH = 44

NETWORK_DISCONNECT_USERCMD = 45

NETWORK_DISCONNECT_REJECTED_BY_GAME = 46

TYPE_ENetworkDisconnectionReason = ProtoBase.TYPE_int32

_ENetworkDisconnectionReason__map = {45: 'NETWORK_DISCONNECT_USERCMD', 29: 'NETWORK_DISCONNECT_TIMEDOUT', 32: 'NETWORK_DISCONNECT_DIFFERENTCLASSTABLES', 31: 'NETWORK_DISCONNECT_LEAVINGSPLIT', 14: 'NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE', 5: 'NETWORK_DISCONNECT_OVERFLOW', 27: 'NETWORK_DISCONNECT_BADDELTATICK', 23: 'NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW', 41: 'NETWORK_DISCONNECT_KICKBANADDED', 10: 'NETWORK_DISCONNECT_STEAM_AUTHCANCELLED', 17: 'NETWORK_DISCONNECT_STEAM_OWNERSHIP', 36: 'NETWORK_DISCONNECT_NOSPECTATORS', 33: 'NETWORK_DISCONNECT_BADRELAYPASSWORD', 1: 'NETWORK_DISCONNECT_SHUTDOWN', 30: 'NETWORK_DISCONNECT_DISCONNECTED', 26: 'NETWORK_DISCONNECT_RELIABLEOVERFLOW', 13: 'NETWORK_DISCONNECT_STEAM_VACBANSTATE', 44: 'NETWORK_DISCONNECT_PURESERVER_MISMATCH', 6: 'NETWORK_DISCONNECT_STEAM_BANNED', 43: 'NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA', 8: 'NETWORK_DISCONNECT_STEAM_TICKET', 7: 'NETWORK_DISCONNECT_STEAM_INUSE', 21: 'NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW', 37: 'NETWORK_DISCONNECT_HLTVUNAVAILABLE', 46: 'NETWORK_DISCONNECT_REJECTED_BY_GAME', 35: 'NETWORK_DISCONNECT_HLTVRESTRICTED', 11: 'NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED', 3: 'NETWORK_DISCONNECT_DISCONNECT_BY_SERVER', 34: 'NETWORK_DISCONNECT_BADSPECTATORPASSWORD', 2: 'NETWORK_DISCONNECT_DISCONNECT_BY_USER', 28: 'NETWORK_DISCONNECT_NOMORESPLITS', 18: 'NETWORK_DISCONNECT_SERVERINFO_OVERFLOW', 25: 'NETWORK_DISCONNECT_SNAPSHOTERROR', 0: 'NETWORK_DISCONNECT_INVALID', 15: 'NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT', 19: 'NETWORK_DISCONNECT_TICKMSG_OVERFLOW', 4: 'NETWORK_DISCONNECT_LOST', 40: 'NETWORK_DISCONNECT_BANADDED', 20: 'NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW', 9: 'NETWORK_DISCONNECT_STEAM_LOGON', 16: 'NETWORK_DISCONNECT_STEAM_DROPPED', 38: 'NETWORK_DISCONNECT_HLTVSTOP', 42: 'NETWORK_DISCONNECT_HLTVDIRECT', 12: 'NETWORK_DISCONNECT_STEAM_AUTHINVALID', 22: 'NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW', 39: 'NETWORK_DISCONNECT_KICKED', 24: 'NETWORK_DISCONNECT_SNAPSHOTOVERFLOW'}

@classmethod
def get_ENetworkDisconnectionReason_name(cls, v):
    return cls._ENetworkDisconnectionReason__map[v]

# Enumeration: SIGNONSTATE

SIGNONSTATE_NONE = 0

SIGNONSTATE_CHALLENGE = 1

SIGNONSTATE_CONNECTED = 2

SIGNONSTATE_NEW = 3

SIGNONSTATE_PRESPAWN = 4

SIGNONSTATE_SPAWN = 5

SIGNONSTATE_FULL = 6

SIGNONSTATE_CHANGELEVEL = 7

TYPE_SIGNONSTATE = ProtoBase.TYPE_int32

_SIGNONSTATE__map = {7: 'SIGNONSTATE_CHANGELEVEL', 2: 'SIGNONSTATE_CONNECTED', 4: 'SIGNONSTATE_PRESPAWN', 1: 'SIGNONSTATE_CHALLENGE', 0: 'SIGNONSTATE_NONE', 6: 'SIGNONSTATE_FULL', 3: 'SIGNONSTATE_NEW', 5: 'SIGNONSTATE_SPAWN'}

@classmethod
def get_SIGNONSTATE_name(cls, v):
    return cls._SIGNONSTATE__map[v]

# Enumeration: EBaseUserMessages

UM_AchievementEvent = 1

UM_CloseCaption = 2

UM_CloseCaptionDirect = 3

UM_CurrentTimescale = 4

UM_DesiredTimescale = 5

UM_Fade = 6

UM_GameTitle = 7

UM_Geiger = 8

UM_HintText = 9

UM_HudMsg = 10

UM_HudText = 11

UM_KeyHintText = 12

UM_MessageText = 13

UM_RequestState = 14

UM_ResetHUD = 15

UM_Rumble = 16

UM_SayText = 17

UM_SayText2 = 18

UM_SayTextChannel = 19

UM_Shake = 20

UM_ShakeDir = 21

UM_StatsCrawlMsg = 22

UM_StatsSkipState = 23

UM_TextMsg = 24

UM_Tilt = 25

UM_Train = 26

UM_VGUIMenu = 27

UM_VoiceMask = 28

UM_VoiceSubtitle = 29

UM_SendAudio = 30

UM_MAX_BASE = 63

TYPE_EBaseUserMessages = ProtoBase.TYPE_int32

_EBaseUserMessages__map = {8: 'UM_Geiger', 18: 'UM_SayText2', 24: 'UM_TextMsg', 17: 'UM_SayText', 16: 'UM_Rumble', 27: 'UM_VGUIMenu', 19: 'UM_SayTextChannel', 28: 'UM_VoiceMask', 63: 'UM_MAX_BASE', 1: 'UM_AchievementEvent', 11: 'UM_HudText', 23: 'UM_StatsSkipState', 13: 'UM_MessageText', 9: 'UM_HintText', 29: 'UM_VoiceSubtitle', 2: 'UM_CloseCaption', 3: 'UM_CloseCaptionDirect', 4: 'UM_CurrentTimescale', 22: 'UM_StatsCrawlMsg', 20: 'UM_Shake', 7: 'UM_GameTitle', 10: 'UM_HudMsg', 25: 'UM_Tilt', 15: 'UM_ResetHUD', 5: 'UM_DesiredTimescale', 30: 'UM_SendAudio', 6: 'UM_Fade', 26: 'UM_Train', 12: 'UM_KeyHintText', 21: 'UM_ShakeDir', 14: 'UM_RequestState'}

@classmethod
def get_EBaseUserMessages_name(cls, v):
    return cls._EBaseUserMessages__map[v]

class CDemoFileHeader(ProtoBase):
    _required = [1]
    _field_map = {'demo_file_stamp': 1, 'network_protocol': 2, 'server_name': 3, 'allow_clientside_particles': 9, 'client_name': 4, 'allow_clientside_entities': 8, 'game_directory': 6, 'map_name': 5, 'fullpackets_version': 7}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['demo_file_stamp', 'network_protocol', 'server_name', 'client_name', 'map_name', 'game_directory', 'fullpackets_version', 'allow_clientside_entities', 'allow_clientside_particles']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_demo_file_stamp(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'demo_file_stamp')
            self._cache[1] = r
        return r

    def _establish_parentage_demo_file_stamp(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_demo_file_stamp), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_demo_file_stamp
                v._pbf_establish_parent_callback = self._establish_parentage_demo_file_stamp

    def _set_demo_file_stamp(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_demo_file_stamp(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field demo_file_stamp"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_demo_file_stamp(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_demo_file_stamp(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "demo_file_stamp"

    demo_file_stamp = property(_get_demo_file_stamp, _set_demo_file_stamp, _del_demo_file_stamp)

    @property
    def demo_file_stamp__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def demo_file_stamp__type(self):
        return ProtoBase.TYPE_string

    def _finalize_demo_file_stamp(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_demo_file_stamp)


    def _get_network_protocol(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'network_protocol')
            self._cache[2] = r
        return r

    def _establish_parentage_network_protocol(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_network_protocol), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_network_protocol
                v._pbf_establish_parent_callback = self._establish_parentage_network_protocol

    def _set_network_protocol(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_network_protocol(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field network_protocol"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_network_protocol(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_network_protocol(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "network_protocol"

    network_protocol = property(_get_network_protocol, _set_network_protocol, _del_network_protocol)

    @property
    def network_protocol__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def network_protocol__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_network_protocol(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_network_protocol)


    def _get_server_name(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'server_name')
            self._cache[3] = r
        return r

    def _establish_parentage_server_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_server_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_server_name
                v._pbf_establish_parent_callback = self._establish_parentage_server_name

    def _set_server_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_server_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field server_name"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_server_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_server_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "server_name"

    server_name = property(_get_server_name, _set_server_name, _del_server_name)

    @property
    def server_name__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def server_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_server_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_server_name)


    def _get_client_name(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'client_name')
            self._cache[4] = r
        return r

    def _establish_parentage_client_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_client_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_client_name
                v._pbf_establish_parent_callback = self._establish_parentage_client_name

    def _set_client_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_client_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field client_name"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_client_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_client_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "client_name"

    client_name = property(_get_client_name, _set_client_name, _del_client_name)

    @property
    def client_name__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def client_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_client_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_client_name)


    def _get_map_name(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_string, 'map_name')
            self._cache[5] = r
        return r

    def _establish_parentage_map_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_map_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_map_name
                v._pbf_establish_parent_callback = self._establish_parentage_map_name

    def _set_map_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_map_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field map_name"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_string

    def _mod_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_string

    def _del_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "map_name"

    map_name = property(_get_map_name, _set_map_name, _del_map_name)

    @property
    def map_name__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def map_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_map_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_map_name)


    def _get_game_directory(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_string, 'game_directory')
            self._cache[6] = r
        return r

    def _establish_parentage_game_directory(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_game_directory), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_game_directory
                v._pbf_establish_parent_callback = self._establish_parentage_game_directory

    def _set_game_directory(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_game_directory(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field game_directory"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_string

    def _mod_game_directory(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_string

    def _del_game_directory(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "game_directory"

    game_directory = property(_get_game_directory, _set_game_directory, _del_game_directory)

    @property
    def game_directory__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def game_directory__type(self):
        return ProtoBase.TYPE_string

    def _finalize_game_directory(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_game_directory)


    def _get_fullpackets_version(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_int32, 'fullpackets_version')
            self._cache[7] = r
        return r

    def _establish_parentage_fullpackets_version(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fullpackets_version), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fullpackets_version
                v._pbf_establish_parent_callback = self._establish_parentage_fullpackets_version

    def _set_fullpackets_version(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fullpackets_version(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fullpackets_version"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_int32

    def _mod_fullpackets_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_int32

    def _del_fullpackets_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "fullpackets_version"

    fullpackets_version = property(_get_fullpackets_version, _set_fullpackets_version, _del_fullpackets_version)

    @property
    def fullpackets_version__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def fullpackets_version__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_fullpackets_version(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_fullpackets_version)


    def _get_allow_clientside_entities(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_bool, 'allow_clientside_entities')
            self._cache[8] = r
        return r

    def _establish_parentage_allow_clientside_entities(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_allow_clientside_entities), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_allow_clientside_entities
                v._pbf_establish_parent_callback = self._establish_parentage_allow_clientside_entities

    def _set_allow_clientside_entities(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_allow_clientside_entities(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field allow_clientside_entities"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_bool

    def _mod_allow_clientside_entities(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_bool

    def _del_allow_clientside_entities(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "allow_clientside_entities"

    allow_clientside_entities = property(_get_allow_clientside_entities, _set_allow_clientside_entities, _del_allow_clientside_entities)

    @property
    def allow_clientside_entities__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def allow_clientside_entities__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_allow_clientside_entities(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_allow_clientside_entities)


    def _get_allow_clientside_particles(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, ProtoBase.TYPE_bool, 'allow_clientside_particles')
            self._cache[9] = r
        return r

    def _establish_parentage_allow_clientside_particles(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_allow_clientside_particles), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_allow_clientside_particles
                v._pbf_establish_parent_callback = self._establish_parentage_allow_clientside_particles

    def _set_allow_clientside_particles(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_allow_clientside_particles(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field allow_clientside_particles"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = ProtoBase.TYPE_bool

    def _mod_allow_clientside_particles(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = ProtoBase.TYPE_bool

    def _del_allow_clientside_particles(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "allow_clientside_particles"

    allow_clientside_particles = property(_get_allow_clientside_particles, _set_allow_clientside_particles, _del_allow_clientside_particles)

    @property
    def allow_clientside_particles__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def allow_clientside_particles__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_allow_clientside_particles(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(9)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_allow_clientside_particles)


TYPE_CDemoFileHeader = CDemoFileHeader
_PB_finalizers.append('CDemoFileHeader')

class CGameInfo(ProtoBase):
    _required = []
    _field_map = {'dota': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['dota']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class CDotaGameInfo(ProtoBase):
        _required = []
        _field_map = {'picks_bans': 6, 'radiant_team_id': 7, 'match_id': 1, 'radiant_team_tag': 9, 'player_info': 4, 'dire_team_tag': 10, 'dire_team_id': 8, 'end_time': 11, 'leagueid': 5, 'game_mode': 2, 'game_winner': 3}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['match_id', 'game_mode', 'game_winner', 'player_info', 'leagueid', 'picks_bans', 'radiant_team_id', 'dire_team_id', 'radiant_team_tag', 'dire_team_tag', 'end_time']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
            
        class CPlayerInfo(ProtoBase):
            _required = []
            _field_map = {'is_fake_client': 3, 'steamid': 4, 'hero_name': 1, 'player_name': 2, 'game_team': 5}
            
            def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
                self._pbf_parent_callback = _pbf_parent_callback
                self._cache = {}
                self._pbf_establish_parent_callback = None
                ProtoBase.__init__(self, _pbf_buf, **kw)
        
            @classmethod
            def _pbf_finalize(cls):
                for c in cls._pbf_finalizers:
                    c(cls)
                del cls._pbf_finalizers
        
            @classmethod
            def fields(cls):
                return ['hero_name', 'player_name', 'is_fake_client', 'steamid', 'game_team']
        
            def modified(self):
                return self._evermod
        
            def __contains__(self, item):
                try:
                    return getattr(self, '%s__exists' % item)
                except AttributeError:
                    return False
        
            _pbf_strings = []
            _pbf_finalizers = []
        
            def __str__(self):
                return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                                  if getattr(self, '%s__exists' % f))
                
            def _get_hero_name(self):
                if 1 in self._cache:
                    r = self._cache[1]
                else:
                    r = self._buf_get(1, ProtoBase.TYPE_string, 'hero_name')
                    self._cache[1] = r
                return r
        
            def _establish_parentage_hero_name(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_hero_name), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_hero_name
                        v._pbf_establish_parent_callback = self._establish_parentage_hero_name
        
            def _set_hero_name(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_hero_name(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field hero_name"
                    raise ProtoValueError(list_assign_error)
                self._cache[1] = v
                self._mods[1] = ProtoBase.TYPE_string
        
            def _mod_hero_name(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[1] = ProtoBase.TYPE_string
        
            def _del_hero_name(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 1 in self._cache:
                    del self._cache[1]
                if 1 in self._mods:
                    del self._mods[1]
                self._buf_del(1)
        
            _pb_field_name_1 = "hero_name"
        
            hero_name = property(_get_hero_name, _set_hero_name, _del_hero_name)
        
            @property
            def hero_name__exists(self):
                return 1 in self._mods or self._buf_exists(1)
        
            @property
            def hero_name__type(self):
                return ProtoBase.TYPE_string
        
            def _finalize_hero_name(cls):
                if is_string(ProtoBase.TYPE_string):
                    cls._pbf_strings.append(1)
                elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_string.pb_subtype):
                        cls._pbf_strings.append(1)
        
            _pbf_finalizers.append(_finalize_hero_name)
        
                
            def _get_player_name(self):
                if 2 in self._cache:
                    r = self._cache[2]
                else:
                    r = self._buf_get(2, ProtoBase.TYPE_string, 'player_name')
                    self._cache[2] = r
                return r
        
            def _establish_parentage_player_name(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_player_name), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_player_name
                        v._pbf_establish_parent_callback = self._establish_parentage_player_name
        
            def _set_player_name(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_player_name(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field player_name"
                    raise ProtoValueError(list_assign_error)
                self._cache[2] = v
                self._mods[2] = ProtoBase.TYPE_string
        
            def _mod_player_name(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[2] = ProtoBase.TYPE_string
        
            def _del_player_name(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 2 in self._cache:
                    del self._cache[2]
                if 2 in self._mods:
                    del self._mods[2]
                self._buf_del(2)
        
            _pb_field_name_2 = "player_name"
        
            player_name = property(_get_player_name, _set_player_name, _del_player_name)
        
            @property
            def player_name__exists(self):
                return 2 in self._mods or self._buf_exists(2)
        
            @property
            def player_name__type(self):
                return ProtoBase.TYPE_string
        
            def _finalize_player_name(cls):
                if is_string(ProtoBase.TYPE_string):
                    cls._pbf_strings.append(2)
                elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_string.pb_subtype):
                        cls._pbf_strings.append(2)
        
            _pbf_finalizers.append(_finalize_player_name)
        
                
            def _get_is_fake_client(self):
                if 3 in self._cache:
                    r = self._cache[3]
                else:
                    r = self._buf_get(3, ProtoBase.TYPE_bool, 'is_fake_client')
                    self._cache[3] = r
                return r
        
            def _establish_parentage_is_fake_client(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_is_fake_client), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_is_fake_client
                        v._pbf_establish_parent_callback = self._establish_parentage_is_fake_client
        
            def _set_is_fake_client(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_is_fake_client(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field is_fake_client"
                    raise ProtoValueError(list_assign_error)
                self._cache[3] = v
                self._mods[3] = ProtoBase.TYPE_bool
        
            def _mod_is_fake_client(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[3] = ProtoBase.TYPE_bool
        
            def _del_is_fake_client(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 3 in self._cache:
                    del self._cache[3]
                if 3 in self._mods:
                    del self._mods[3]
                self._buf_del(3)
        
            _pb_field_name_3 = "is_fake_client"
        
            is_fake_client = property(_get_is_fake_client, _set_is_fake_client, _del_is_fake_client)
        
            @property
            def is_fake_client__exists(self):
                return 3 in self._mods or self._buf_exists(3)
        
            @property
            def is_fake_client__type(self):
                return ProtoBase.TYPE_bool
        
            def _finalize_is_fake_client(cls):
                if is_string(ProtoBase.TYPE_bool):
                    cls._pbf_strings.append(3)
                elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_bool.pb_subtype):
                        cls._pbf_strings.append(3)
        
            _pbf_finalizers.append(_finalize_is_fake_client)
        
                
            def _get_steamid(self):
                if 4 in self._cache:
                    r = self._cache[4]
                else:
                    r = self._buf_get(4, ProtoBase.TYPE_uint64, 'steamid')
                    self._cache[4] = r
                return r
        
            def _establish_parentage_steamid(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_steamid), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_steamid
                        v._pbf_establish_parent_callback = self._establish_parentage_steamid
        
            def _set_steamid(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_steamid(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field steamid"
                    raise ProtoValueError(list_assign_error)
                self._cache[4] = v
                self._mods[4] = ProtoBase.TYPE_uint64
        
            def _mod_steamid(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[4] = ProtoBase.TYPE_uint64
        
            def _del_steamid(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 4 in self._cache:
                    del self._cache[4]
                if 4 in self._mods:
                    del self._mods[4]
                self._buf_del(4)
        
            _pb_field_name_4 = "steamid"
        
            steamid = property(_get_steamid, _set_steamid, _del_steamid)
        
            @property
            def steamid__exists(self):
                return 4 in self._mods or self._buf_exists(4)
        
            @property
            def steamid__type(self):
                return ProtoBase.TYPE_uint64
        
            def _finalize_steamid(cls):
                if is_string(ProtoBase.TYPE_uint64):
                    cls._pbf_strings.append(4)
                elif _PB_type(ProtoBase.TYPE_uint64) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_uint64, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_uint64.pb_subtype):
                        cls._pbf_strings.append(4)
        
            _pbf_finalizers.append(_finalize_steamid)
        
                
            def _get_game_team(self):
                if 5 in self._cache:
                    r = self._cache[5]
                else:
                    r = self._buf_get(5, ProtoBase.TYPE_int32, 'game_team')
                    self._cache[5] = r
                return r
        
            def _establish_parentage_game_team(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_game_team), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_game_team
                        v._pbf_establish_parent_callback = self._establish_parentage_game_team
        
            def _set_game_team(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_game_team(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field game_team"
                    raise ProtoValueError(list_assign_error)
                self._cache[5] = v
                self._mods[5] = ProtoBase.TYPE_int32
        
            def _mod_game_team(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[5] = ProtoBase.TYPE_int32
        
            def _del_game_team(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 5 in self._cache:
                    del self._cache[5]
                if 5 in self._mods:
                    del self._mods[5]
                self._buf_del(5)
        
            _pb_field_name_5 = "game_team"
        
            game_team = property(_get_game_team, _set_game_team, _del_game_team)
        
            @property
            def game_team__exists(self):
                return 5 in self._mods or self._buf_exists(5)
        
            @property
            def game_team__type(self):
                return ProtoBase.TYPE_int32
        
            def _finalize_game_team(cls):
                if is_string(ProtoBase.TYPE_int32):
                    cls._pbf_strings.append(5)
                elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_int32.pb_subtype):
                        cls._pbf_strings.append(5)
        
            _pbf_finalizers.append(_finalize_game_team)
        
                
        TYPE_CPlayerInfo = CPlayerInfo
        _PB_finalizers.append('CGameInfo.CDotaGameInfo.CPlayerInfo')
            
        TYPE_CPlayerInfo = CPlayerInfo
            
        class CHeroSelectEvent(ProtoBase):
            _required = []
            _field_map = {'hero_id': 3, 'team': 2, 'is_pick': 1}
            
            def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
                self._pbf_parent_callback = _pbf_parent_callback
                self._cache = {}
                self._pbf_establish_parent_callback = None
                ProtoBase.__init__(self, _pbf_buf, **kw)
        
            @classmethod
            def _pbf_finalize(cls):
                for c in cls._pbf_finalizers:
                    c(cls)
                del cls._pbf_finalizers
        
            @classmethod
            def fields(cls):
                return ['is_pick', 'team', 'hero_id']
        
            def modified(self):
                return self._evermod
        
            def __contains__(self, item):
                try:
                    return getattr(self, '%s__exists' % item)
                except AttributeError:
                    return False
        
            _pbf_strings = []
            _pbf_finalizers = []
        
            def __str__(self):
                return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                                  if getattr(self, '%s__exists' % f))
                
            def _get_is_pick(self):
                if 1 in self._cache:
                    r = self._cache[1]
                else:
                    r = self._buf_get(1, ProtoBase.TYPE_bool, 'is_pick')
                    self._cache[1] = r
                return r
        
            def _establish_parentage_is_pick(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_is_pick), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_is_pick
                        v._pbf_establish_parent_callback = self._establish_parentage_is_pick
        
            def _set_is_pick(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_is_pick(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field is_pick"
                    raise ProtoValueError(list_assign_error)
                self._cache[1] = v
                self._mods[1] = ProtoBase.TYPE_bool
        
            def _mod_is_pick(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[1] = ProtoBase.TYPE_bool
        
            def _del_is_pick(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 1 in self._cache:
                    del self._cache[1]
                if 1 in self._mods:
                    del self._mods[1]
                self._buf_del(1)
        
            _pb_field_name_1 = "is_pick"
        
            is_pick = property(_get_is_pick, _set_is_pick, _del_is_pick)
        
            @property
            def is_pick__exists(self):
                return 1 in self._mods or self._buf_exists(1)
        
            @property
            def is_pick__type(self):
                return ProtoBase.TYPE_bool
        
            def _finalize_is_pick(cls):
                if is_string(ProtoBase.TYPE_bool):
                    cls._pbf_strings.append(1)
                elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_bool.pb_subtype):
                        cls._pbf_strings.append(1)
        
            _pbf_finalizers.append(_finalize_is_pick)
        
                
            def _get_team(self):
                if 2 in self._cache:
                    r = self._cache[2]
                else:
                    r = self._buf_get(2, ProtoBase.TYPE_uint32, 'team')
                    self._cache[2] = r
                return r
        
            def _establish_parentage_team(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_team), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_team
                        v._pbf_establish_parent_callback = self._establish_parentage_team
        
            def _set_team(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_team(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field team"
                    raise ProtoValueError(list_assign_error)
                self._cache[2] = v
                self._mods[2] = ProtoBase.TYPE_uint32
        
            def _mod_team(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[2] = ProtoBase.TYPE_uint32
        
            def _del_team(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 2 in self._cache:
                    del self._cache[2]
                if 2 in self._mods:
                    del self._mods[2]
                self._buf_del(2)
        
            _pb_field_name_2 = "team"
        
            team = property(_get_team, _set_team, _del_team)
        
            @property
            def team__exists(self):
                return 2 in self._mods or self._buf_exists(2)
        
            @property
            def team__type(self):
                return ProtoBase.TYPE_uint32
        
            def _finalize_team(cls):
                if is_string(ProtoBase.TYPE_uint32):
                    cls._pbf_strings.append(2)
                elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                        cls._pbf_strings.append(2)
        
            _pbf_finalizers.append(_finalize_team)
        
                
            def _get_hero_id(self):
                if 3 in self._cache:
                    r = self._cache[3]
                else:
                    r = self._buf_get(3, ProtoBase.TYPE_uint32, 'hero_id')
                    self._cache[3] = r
                return r
        
            def _establish_parentage_hero_id(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_hero_id), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_hero_id
                        v._pbf_establish_parent_callback = self._establish_parentage_hero_id
        
            def _set_hero_id(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_hero_id(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field hero_id"
                    raise ProtoValueError(list_assign_error)
                self._cache[3] = v
                self._mods[3] = ProtoBase.TYPE_uint32
        
            def _mod_hero_id(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[3] = ProtoBase.TYPE_uint32
        
            def _del_hero_id(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 3 in self._cache:
                    del self._cache[3]
                if 3 in self._mods:
                    del self._mods[3]
                self._buf_del(3)
        
            _pb_field_name_3 = "hero_id"
        
            hero_id = property(_get_hero_id, _set_hero_id, _del_hero_id)
        
            @property
            def hero_id__exists(self):
                return 3 in self._mods or self._buf_exists(3)
        
            @property
            def hero_id__type(self):
                return ProtoBase.TYPE_uint32
        
            def _finalize_hero_id(cls):
                if is_string(ProtoBase.TYPE_uint32):
                    cls._pbf_strings.append(3)
                elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                        cls._pbf_strings.append(3)
        
            _pbf_finalizers.append(_finalize_hero_id)
        
                
        TYPE_CHeroSelectEvent = CHeroSelectEvent
        _PB_finalizers.append('CGameInfo.CDotaGameInfo.CHeroSelectEvent')
            
        TYPE_CHeroSelectEvent = CHeroSelectEvent
        
        def _get_match_id(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_uint32, 'match_id')
                self._cache[1] = r
            return r
    
        def _establish_parentage_match_id(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_match_id), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_match_id
                    v._pbf_establish_parent_callback = self._establish_parentage_match_id
    
        def _set_match_id(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_match_id(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field match_id"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_uint32
    
        def _mod_match_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_uint32
    
        def _del_match_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "match_id"
    
        match_id = property(_get_match_id, _set_match_id, _del_match_id)
    
        @property
        def match_id__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def match_id__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_match_id(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_match_id)
    
        
        def _get_game_mode(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'game_mode')
                self._cache[2] = r
            return r
    
        def _establish_parentage_game_mode(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_game_mode), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_game_mode
                    v._pbf_establish_parent_callback = self._establish_parentage_game_mode
    
        def _set_game_mode(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_game_mode(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field game_mode"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_game_mode(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_game_mode(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "game_mode"
    
        game_mode = property(_get_game_mode, _set_game_mode, _del_game_mode)
    
        @property
        def game_mode__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def game_mode__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_game_mode(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_game_mode)
    
        
        def _get_game_winner(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'game_winner')
                self._cache[3] = r
            return r
    
        def _establish_parentage_game_winner(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_game_winner), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_game_winner
                    v._pbf_establish_parent_callback = self._establish_parentage_game_winner
    
        def _set_game_winner(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_game_winner(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field game_winner"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_game_winner(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_game_winner(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "game_winner"
    
        game_winner = property(_get_game_winner, _set_game_winner, _del_game_winner)
    
        @property
        def game_winner__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def game_winner__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_game_winner(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_game_winner)
    
        
        class Repeated_player_info(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CGameInfo.CDotaGameInfo.TYPE_CPlayerInfo
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_player_info = Repeated_player_info
    
        
        @property
        def player_info__stream(self):
            if 4 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[4]]
            return self._get_repeated(4, self.TYPE_Repeated_player_info, "player_info", lazy=True)
    
        def player_info__fast_append(self, value):
            self._append_to_repeated(4, self.TYPE_Repeated_player_info, value)
        
        def _get_player_info(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, self.TYPE_Repeated_player_info, 'player_info')
                self._cache[4] = r
            return r
    
        def _establish_parentage_player_info(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_player_info), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_player_info
                    v._pbf_establish_parent_callback = self._establish_parentage_player_info
    
        def _set_player_info(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_player_info(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field player_info"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = self.TYPE_Repeated_player_info
    
        def _mod_player_info(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = self.TYPE_Repeated_player_info
    
        def _del_player_info(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "player_info"
    
        player_info = property(_get_player_info, _set_player_info, _del_player_info)
    
        @property
        def player_info__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def player_info__type(self):
            return self.TYPE_Repeated_player_info
    
        def _finalize_player_info(cls):
            if is_string(cls.TYPE_Repeated_player_info):
                cls._pbf_strings.append(4)
            elif _PB_type(cls.TYPE_Repeated_player_info) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_player_info, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_player_info.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_player_info)
    
        
        def _get_leagueid(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                r = self._buf_get(5, ProtoBase.TYPE_uint32, 'leagueid')
                self._cache[5] = r
            return r
    
        def _establish_parentage_leagueid(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_leagueid), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_leagueid
                    v._pbf_establish_parent_callback = self._establish_parentage_leagueid
    
        def _set_leagueid(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_leagueid(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field leagueid"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = ProtoBase.TYPE_uint32
    
        def _mod_leagueid(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = ProtoBase.TYPE_uint32
    
        def _del_leagueid(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "leagueid"
    
        leagueid = property(_get_leagueid, _set_leagueid, _del_leagueid)
    
        @property
        def leagueid__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def leagueid__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_leagueid(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(5)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_leagueid)
    
        
        class Repeated_picks_bans(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CGameInfo.CDotaGameInfo.TYPE_CHeroSelectEvent
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_picks_bans = Repeated_picks_bans
    
        
        @property
        def picks_bans__stream(self):
            if 6 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[6]]
            return self._get_repeated(6, self.TYPE_Repeated_picks_bans, "picks_bans", lazy=True)
    
        def picks_bans__fast_append(self, value):
            self._append_to_repeated(6, self.TYPE_Repeated_picks_bans, value)
        
        def _get_picks_bans(self):
            if 6 in self._cache:
                r = self._cache[6]
            else:
                r = self._buf_get(6, self.TYPE_Repeated_picks_bans, 'picks_bans')
                self._cache[6] = r
            return r
    
        def _establish_parentage_picks_bans(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_picks_bans), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_picks_bans
                    v._pbf_establish_parent_callback = self._establish_parentage_picks_bans
    
        def _set_picks_bans(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_picks_bans(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field picks_bans"
                raise ProtoValueError(list_assign_error)
            self._cache[6] = v
            self._mods[6] = self.TYPE_Repeated_picks_bans
    
        def _mod_picks_bans(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[6] = self.TYPE_Repeated_picks_bans
    
        def _del_picks_bans(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 6 in self._cache:
                del self._cache[6]
            if 6 in self._mods:
                del self._mods[6]
            self._buf_del(6)
    
        _pb_field_name_6 = "picks_bans"
    
        picks_bans = property(_get_picks_bans, _set_picks_bans, _del_picks_bans)
    
        @property
        def picks_bans__exists(self):
            return 6 in self._mods or self._buf_exists(6)
    
        @property
        def picks_bans__type(self):
            return self.TYPE_Repeated_picks_bans
    
        def _finalize_picks_bans(cls):
            if is_string(cls.TYPE_Repeated_picks_bans):
                cls._pbf_strings.append(6)
            elif _PB_type(cls.TYPE_Repeated_picks_bans) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_picks_bans, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_picks_bans.pb_subtype):
                    cls._pbf_strings.append(6)
    
        _pbf_finalizers.append(_finalize_picks_bans)
    
        
        def _get_radiant_team_id(self):
            if 7 in self._cache:
                r = self._cache[7]
            else:
                r = self._buf_get(7, ProtoBase.TYPE_uint32, 'radiant_team_id')
                self._cache[7] = r
            return r
    
        def _establish_parentage_radiant_team_id(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_radiant_team_id), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_radiant_team_id
                    v._pbf_establish_parent_callback = self._establish_parentage_radiant_team_id
    
        def _set_radiant_team_id(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_radiant_team_id(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field radiant_team_id"
                raise ProtoValueError(list_assign_error)
            self._cache[7] = v
            self._mods[7] = ProtoBase.TYPE_uint32
    
        def _mod_radiant_team_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[7] = ProtoBase.TYPE_uint32
    
        def _del_radiant_team_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 7 in self._cache:
                del self._cache[7]
            if 7 in self._mods:
                del self._mods[7]
            self._buf_del(7)
    
        _pb_field_name_7 = "radiant_team_id"
    
        radiant_team_id = property(_get_radiant_team_id, _set_radiant_team_id, _del_radiant_team_id)
    
        @property
        def radiant_team_id__exists(self):
            return 7 in self._mods or self._buf_exists(7)
    
        @property
        def radiant_team_id__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_radiant_team_id(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(7)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(7)
    
        _pbf_finalizers.append(_finalize_radiant_team_id)
    
        
        def _get_dire_team_id(self):
            if 8 in self._cache:
                r = self._cache[8]
            else:
                r = self._buf_get(8, ProtoBase.TYPE_uint32, 'dire_team_id')
                self._cache[8] = r
            return r
    
        def _establish_parentage_dire_team_id(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_dire_team_id), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_dire_team_id
                    v._pbf_establish_parent_callback = self._establish_parentage_dire_team_id
    
        def _set_dire_team_id(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_dire_team_id(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field dire_team_id"
                raise ProtoValueError(list_assign_error)
            self._cache[8] = v
            self._mods[8] = ProtoBase.TYPE_uint32
    
        def _mod_dire_team_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[8] = ProtoBase.TYPE_uint32
    
        def _del_dire_team_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 8 in self._cache:
                del self._cache[8]
            if 8 in self._mods:
                del self._mods[8]
            self._buf_del(8)
    
        _pb_field_name_8 = "dire_team_id"
    
        dire_team_id = property(_get_dire_team_id, _set_dire_team_id, _del_dire_team_id)
    
        @property
        def dire_team_id__exists(self):
            return 8 in self._mods or self._buf_exists(8)
    
        @property
        def dire_team_id__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_dire_team_id(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(8)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(8)
    
        _pbf_finalizers.append(_finalize_dire_team_id)
    
        
        def _get_radiant_team_tag(self):
            if 9 in self._cache:
                r = self._cache[9]
            else:
                r = self._buf_get(9, ProtoBase.TYPE_string, 'radiant_team_tag')
                self._cache[9] = r
            return r
    
        def _establish_parentage_radiant_team_tag(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_radiant_team_tag), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_radiant_team_tag
                    v._pbf_establish_parent_callback = self._establish_parentage_radiant_team_tag
    
        def _set_radiant_team_tag(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_radiant_team_tag(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field radiant_team_tag"
                raise ProtoValueError(list_assign_error)
            self._cache[9] = v
            self._mods[9] = ProtoBase.TYPE_string
    
        def _mod_radiant_team_tag(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[9] = ProtoBase.TYPE_string
    
        def _del_radiant_team_tag(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 9 in self._cache:
                del self._cache[9]
            if 9 in self._mods:
                del self._mods[9]
            self._buf_del(9)
    
        _pb_field_name_9 = "radiant_team_tag"
    
        radiant_team_tag = property(_get_radiant_team_tag, _set_radiant_team_tag, _del_radiant_team_tag)
    
        @property
        def radiant_team_tag__exists(self):
            return 9 in self._mods or self._buf_exists(9)
    
        @property
        def radiant_team_tag__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_radiant_team_tag(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(9)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(9)
    
        _pbf_finalizers.append(_finalize_radiant_team_tag)
    
        
        def _get_dire_team_tag(self):
            if 10 in self._cache:
                r = self._cache[10]
            else:
                r = self._buf_get(10, ProtoBase.TYPE_string, 'dire_team_tag')
                self._cache[10] = r
            return r
    
        def _establish_parentage_dire_team_tag(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_dire_team_tag), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_dire_team_tag
                    v._pbf_establish_parent_callback = self._establish_parentage_dire_team_tag
    
        def _set_dire_team_tag(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_dire_team_tag(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field dire_team_tag"
                raise ProtoValueError(list_assign_error)
            self._cache[10] = v
            self._mods[10] = ProtoBase.TYPE_string
    
        def _mod_dire_team_tag(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[10] = ProtoBase.TYPE_string
    
        def _del_dire_team_tag(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 10 in self._cache:
                del self._cache[10]
            if 10 in self._mods:
                del self._mods[10]
            self._buf_del(10)
    
        _pb_field_name_10 = "dire_team_tag"
    
        dire_team_tag = property(_get_dire_team_tag, _set_dire_team_tag, _del_dire_team_tag)
    
        @property
        def dire_team_tag__exists(self):
            return 10 in self._mods or self._buf_exists(10)
    
        @property
        def dire_team_tag__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_dire_team_tag(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(10)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(10)
    
        _pbf_finalizers.append(_finalize_dire_team_tag)
    
        
        def _get_end_time(self):
            if 11 in self._cache:
                r = self._cache[11]
            else:
                r = self._buf_get(11, ProtoBase.TYPE_uint32, 'end_time')
                self._cache[11] = r
            return r
    
        def _establish_parentage_end_time(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_end_time), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_end_time
                    v._pbf_establish_parent_callback = self._establish_parentage_end_time
    
        def _set_end_time(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_end_time(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field end_time"
                raise ProtoValueError(list_assign_error)
            self._cache[11] = v
            self._mods[11] = ProtoBase.TYPE_uint32
    
        def _mod_end_time(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[11] = ProtoBase.TYPE_uint32
    
        def _del_end_time(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 11 in self._cache:
                del self._cache[11]
            if 11 in self._mods:
                del self._mods[11]
            self._buf_del(11)
    
        _pb_field_name_11 = "end_time"
    
        end_time = property(_get_end_time, _set_end_time, _del_end_time)
    
        @property
        def end_time__exists(self):
            return 11 in self._mods or self._buf_exists(11)
    
        @property
        def end_time__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_end_time(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(11)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(11)
    
        _pbf_finalizers.append(_finalize_end_time)
    
        
    TYPE_CDotaGameInfo = CDotaGameInfo
    _PB_finalizers.append('CGameInfo.CDotaGameInfo')
    
    TYPE_CDotaGameInfo = CDotaGameInfo

    def _get_dota(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, CGameInfo.TYPE_CDotaGameInfo, 'dota')
            self._cache[4] = r
        return r

    def _establish_parentage_dota(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_dota), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_dota
                v._pbf_establish_parent_callback = self._establish_parentage_dota

    def _set_dota(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_dota(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field dota"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = CGameInfo.TYPE_CDotaGameInfo

    def _mod_dota(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = CGameInfo.TYPE_CDotaGameInfo

    def _del_dota(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "dota"

    dota = property(_get_dota, _set_dota, _del_dota)

    @property
    def dota__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def dota__type(self):
        return CGameInfo.TYPE_CDotaGameInfo

    def _finalize_dota(cls):
        if is_string(CGameInfo.TYPE_CDotaGameInfo):
            cls._pbf_strings.append(4)
        elif _PB_type(CGameInfo.TYPE_CDotaGameInfo) is _PB_type:
            assert issubclass(CGameInfo.TYPE_CDotaGameInfo, RepeatedSequence)
            if is_string(CGameInfo.TYPE_CDotaGameInfo.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_dota)


TYPE_CGameInfo = CGameInfo
_PB_finalizers.append('CGameInfo')

class CDemoFileInfo(ProtoBase):
    _required = []
    _field_map = {'game_info': 4, 'playback_ticks': 2, 'playback_time': 1, 'playback_frames': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['playback_time', 'playback_ticks', 'playback_frames', 'game_info']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_playback_time(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'playback_time')
            self._cache[1] = r
        return r

    def _establish_parentage_playback_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playback_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playback_time
                v._pbf_establish_parent_callback = self._establish_parentage_playback_time

    def _set_playback_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playback_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playback_time"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_playback_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_playback_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "playback_time"

    playback_time = property(_get_playback_time, _set_playback_time, _del_playback_time)

    @property
    def playback_time__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def playback_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_playback_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_playback_time)


    def _get_playback_ticks(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'playback_ticks')
            self._cache[2] = r
        return r

    def _establish_parentage_playback_ticks(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playback_ticks), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playback_ticks
                v._pbf_establish_parent_callback = self._establish_parentage_playback_ticks

    def _set_playback_ticks(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playback_ticks(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playback_ticks"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_playback_ticks(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_playback_ticks(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "playback_ticks"

    playback_ticks = property(_get_playback_ticks, _set_playback_ticks, _del_playback_ticks)

    @property
    def playback_ticks__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def playback_ticks__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_playback_ticks(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_playback_ticks)


    def _get_playback_frames(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'playback_frames')
            self._cache[3] = r
        return r

    def _establish_parentage_playback_frames(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playback_frames), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playback_frames
                v._pbf_establish_parent_callback = self._establish_parentage_playback_frames

    def _set_playback_frames(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playback_frames(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playback_frames"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_playback_frames(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_playback_frames(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "playback_frames"

    playback_frames = property(_get_playback_frames, _set_playback_frames, _del_playback_frames)

    @property
    def playback_frames__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def playback_frames__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_playback_frames(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_playback_frames)


    def _get_game_info(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, TYPE_CGameInfo, 'game_info')
            self._cache[4] = r
        return r

    def _establish_parentage_game_info(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_game_info), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_game_info
                v._pbf_establish_parent_callback = self._establish_parentage_game_info

    def _set_game_info(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_game_info(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field game_info"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = TYPE_CGameInfo

    def _mod_game_info(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = TYPE_CGameInfo

    def _del_game_info(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "game_info"

    game_info = property(_get_game_info, _set_game_info, _del_game_info)

    @property
    def game_info__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def game_info__type(self):
        return TYPE_CGameInfo

    def _finalize_game_info(cls):
        if is_string(TYPE_CGameInfo):
            cls._pbf_strings.append(4)
        elif _PB_type(TYPE_CGameInfo) is _PB_type:
            assert issubclass(TYPE_CGameInfo, RepeatedSequence)
            if is_string(TYPE_CGameInfo.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_game_info)


TYPE_CDemoFileInfo = CDemoFileInfo
_PB_finalizers.append('CDemoFileInfo')

class CDemoPacket(ProtoBase):
    _required = []
    _field_map = {'sequence_in': 1, 'sequence_out_ack': 2, 'data': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['sequence_in', 'sequence_out_ack', 'data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_sequence_in(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'sequence_in')
            self._cache[1] = r
        return r

    def _establish_parentage_sequence_in(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_sequence_in), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_sequence_in
                v._pbf_establish_parent_callback = self._establish_parentage_sequence_in

    def _set_sequence_in(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_sequence_in(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field sequence_in"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_sequence_in(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_sequence_in(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "sequence_in"

    sequence_in = property(_get_sequence_in, _set_sequence_in, _del_sequence_in)

    @property
    def sequence_in__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def sequence_in__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_sequence_in(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_sequence_in)


    def _get_sequence_out_ack(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'sequence_out_ack')
            self._cache[2] = r
        return r

    def _establish_parentage_sequence_out_ack(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_sequence_out_ack), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_sequence_out_ack
                v._pbf_establish_parent_callback = self._establish_parentage_sequence_out_ack

    def _set_sequence_out_ack(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_sequence_out_ack(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field sequence_out_ack"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_sequence_out_ack(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_sequence_out_ack(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "sequence_out_ack"

    sequence_out_ack = property(_get_sequence_out_ack, _set_sequence_out_ack, _del_sequence_out_ack)

    @property
    def sequence_out_ack__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def sequence_out_ack__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_sequence_out_ack(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_sequence_out_ack)


    def _get_data(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bytes, 'data')
            self._cache[3] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_data)


TYPE_CDemoPacket = CDemoPacket
_PB_finalizers.append('CDemoPacket')

class CDemoFullPacket(ProtoBase):
    _required = []
    _field_map = {'packet': 2, 'string_table': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['string_table', 'packet']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_string_table(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CDemoStringTables, 'string_table')
            self._cache[1] = r
        return r

    def _establish_parentage_string_table(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_string_table), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_string_table
                v._pbf_establish_parent_callback = self._establish_parentage_string_table

    def _set_string_table(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_string_table(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field string_table"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CDemoStringTables

    def _mod_string_table(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CDemoStringTables

    def _del_string_table(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "string_table"

    string_table = property(_get_string_table, _set_string_table, _del_string_table)

    @property
    def string_table__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def string_table__type(self):
        return TYPE_CDemoStringTables

    def _finalize_string_table(cls):
        if is_string(TYPE_CDemoStringTables):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CDemoStringTables) is _PB_type:
            assert issubclass(TYPE_CDemoStringTables, RepeatedSequence)
            if is_string(TYPE_CDemoStringTables.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_string_table)


    def _get_packet(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDemoPacket, 'packet')
            self._cache[2] = r
        return r

    def _establish_parentage_packet(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_packet), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_packet
                v._pbf_establish_parent_callback = self._establish_parentage_packet

    def _set_packet(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_packet(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field packet"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDemoPacket

    def _mod_packet(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDemoPacket

    def _del_packet(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "packet"

    packet = property(_get_packet, _set_packet, _del_packet)

    @property
    def packet__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def packet__type(self):
        return TYPE_CDemoPacket

    def _finalize_packet(cls):
        if is_string(TYPE_CDemoPacket):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDemoPacket) is _PB_type:
            assert issubclass(TYPE_CDemoPacket, RepeatedSequence)
            if is_string(TYPE_CDemoPacket.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_packet)


TYPE_CDemoFullPacket = CDemoFullPacket
_PB_finalizers.append('CDemoFullPacket')

class CDemoSaveGame(ProtoBase):
    _required = []
    _field_map = {'steam_id': 2, 'version': 4, 'data': 1, 'signature': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['data', 'steam_id', 'signature', 'version']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_data(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bytes, 'data')
            self._cache[1] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_data)


    def _get_steam_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_fixed64, 'steam_id')
            self._cache[2] = r
        return r

    def _establish_parentage_steam_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_steam_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_steam_id
                v._pbf_establish_parent_callback = self._establish_parentage_steam_id

    def _set_steam_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_steam_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field steam_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_fixed64

    def _mod_steam_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_fixed64

    def _del_steam_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "steam_id"

    steam_id = property(_get_steam_id, _set_steam_id, _del_steam_id)

    @property
    def steam_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def steam_id__type(self):
        return ProtoBase.TYPE_fixed64

    def _finalize_steam_id(cls):
        if is_string(ProtoBase.TYPE_fixed64):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_fixed64) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed64, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed64.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_steam_id)


    def _get_signature(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_fixed64, 'signature')
            self._cache[3] = r
        return r

    def _establish_parentage_signature(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_signature), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_signature
                v._pbf_establish_parent_callback = self._establish_parentage_signature

    def _set_signature(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_signature(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field signature"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_fixed64

    def _mod_signature(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_fixed64

    def _del_signature(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "signature"

    signature = property(_get_signature, _set_signature, _del_signature)

    @property
    def signature__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def signature__type(self):
        return ProtoBase.TYPE_fixed64

    def _finalize_signature(cls):
        if is_string(ProtoBase.TYPE_fixed64):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_fixed64) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed64, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed64.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_signature)


    def _get_version(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'version')
            self._cache[4] = r
        return r

    def _establish_parentage_version(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_version), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_version
                v._pbf_establish_parent_callback = self._establish_parentage_version

    def _set_version(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_version(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field version"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "version"

    version = property(_get_version, _set_version, _del_version)

    @property
    def version__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def version__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_version(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_version)


TYPE_CDemoSaveGame = CDemoSaveGame
_PB_finalizers.append('CDemoSaveGame')

class CDemoSyncTick(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDemoSyncTick = CDemoSyncTick
_PB_finalizers.append('CDemoSyncTick')

class CDemoConsoleCmd(ProtoBase):
    _required = []
    _field_map = {'cmdstring': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['cmdstring']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_cmdstring(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'cmdstring')
            self._cache[1] = r
        return r

    def _establish_parentage_cmdstring(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cmdstring), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cmdstring
                v._pbf_establish_parent_callback = self._establish_parentage_cmdstring

    def _set_cmdstring(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cmdstring(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cmdstring"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_cmdstring(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_cmdstring(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "cmdstring"

    cmdstring = property(_get_cmdstring, _set_cmdstring, _del_cmdstring)

    @property
    def cmdstring__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def cmdstring__type(self):
        return ProtoBase.TYPE_string

    def _finalize_cmdstring(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_cmdstring)


TYPE_CDemoConsoleCmd = CDemoConsoleCmd
_PB_finalizers.append('CDemoConsoleCmd')

class CDemoSendTables(ProtoBase):
    _required = []
    _field_map = {'data': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_data(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bytes, 'data')
            self._cache[1] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_data)


TYPE_CDemoSendTables = CDemoSendTables
_PB_finalizers.append('CDemoSendTables')

class CDemoClassInfo(ProtoBase):
    _required = []
    _field_map = {'classes': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['classes']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class class_t(ProtoBase):
        _required = []
        _field_map = {'class_id': 1, 'table_name': 3, 'network_name': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['class_id', 'network_name', 'table_name']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_class_id(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'class_id')
                self._cache[1] = r
            return r
    
        def _establish_parentage_class_id(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_class_id), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_class_id
                    v._pbf_establish_parent_callback = self._establish_parentage_class_id
    
        def _set_class_id(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_class_id(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field class_id"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_class_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_class_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "class_id"
    
        class_id = property(_get_class_id, _set_class_id, _del_class_id)
    
        @property
        def class_id__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def class_id__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_class_id(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_class_id)
    
        
        def _get_network_name(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'network_name')
                self._cache[2] = r
            return r
    
        def _establish_parentage_network_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_network_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_network_name
                    v._pbf_establish_parent_callback = self._establish_parentage_network_name
    
        def _set_network_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_network_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field network_name"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_network_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_network_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "network_name"
    
        network_name = property(_get_network_name, _set_network_name, _del_network_name)
    
        @property
        def network_name__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def network_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_network_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_network_name)
    
        
        def _get_table_name(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_string, 'table_name')
                self._cache[3] = r
            return r
    
        def _establish_parentage_table_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_table_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_table_name
                    v._pbf_establish_parent_callback = self._establish_parentage_table_name
    
        def _set_table_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_table_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field table_name"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_string
    
        def _mod_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_string
    
        def _del_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "table_name"
    
        table_name = property(_get_table_name, _set_table_name, _del_table_name)
    
        @property
        def table_name__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def table_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_table_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_table_name)
    
        
    TYPE_class_t = class_t
    _PB_finalizers.append('CDemoClassInfo.class_t')
    
    TYPE_class_t = class_t

    class Repeated_classes(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CDemoClassInfo.TYPE_class_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_classes = Repeated_classes


    @property
    def classes__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_classes, "classes", lazy=True)

    def classes__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_classes, value)

    def _get_classes(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_classes, 'classes')
            self._cache[1] = r
        return r

    def _establish_parentage_classes(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_classes), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_classes
                v._pbf_establish_parent_callback = self._establish_parentage_classes

    def _set_classes(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_classes(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field classes"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_classes

    def _mod_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_classes

    def _del_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "classes"

    classes = property(_get_classes, _set_classes, _del_classes)

    @property
    def classes__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def classes__type(self):
        return self.TYPE_Repeated_classes

    def _finalize_classes(cls):
        if is_string(cls.TYPE_Repeated_classes):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_classes) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_classes, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_classes.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_classes)


TYPE_CDemoClassInfo = CDemoClassInfo
_PB_finalizers.append('CDemoClassInfo')

class CDemoCustomData(ProtoBase):
    _required = []
    _field_map = {'data': 2, 'callback_index': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['callback_index', 'data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_callback_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'callback_index')
            self._cache[1] = r
        return r

    def _establish_parentage_callback_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_callback_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_callback_index
                v._pbf_establish_parent_callback = self._establish_parentage_callback_index

    def _set_callback_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_callback_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field callback_index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_callback_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_callback_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "callback_index"

    callback_index = property(_get_callback_index, _set_callback_index, _del_callback_index)

    @property
    def callback_index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def callback_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_callback_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_callback_index)


    def _get_data(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bytes, 'data')
            self._cache[2] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_data)


TYPE_CDemoCustomData = CDemoCustomData
_PB_finalizers.append('CDemoCustomData')

class CDemoCustomDataCallbacks(ProtoBase):
    _required = []
    _field_map = {'save_id': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['save_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_save_id(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_save_id = Repeated_save_id


    def _get_save_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_save_id, 'save_id')
            self._cache[1] = r
        return r

    def _establish_parentage_save_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_save_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_save_id
                v._pbf_establish_parent_callback = self._establish_parentage_save_id

    def _set_save_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_save_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field save_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_save_id

    def _mod_save_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_save_id

    def _del_save_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "save_id"

    save_id = property(_get_save_id, _set_save_id, _del_save_id)

    @property
    def save_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def save_id__type(self):
        return self.TYPE_Repeated_save_id

    def _finalize_save_id(cls):
        if is_string(cls.TYPE_Repeated_save_id):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_save_id) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_save_id, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_save_id.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_save_id)


TYPE_CDemoCustomDataCallbacks = CDemoCustomDataCallbacks
_PB_finalizers.append('CDemoCustomDataCallbacks')

class CDemoStringTables(ProtoBase):
    _required = []
    _field_map = {'tables': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['tables']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class items_t(ProtoBase):
        _required = []
        _field_map = {'data': 2, 'str': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['str', 'data']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_str(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_string, 'str')
                self._cache[1] = r
            return r
    
        def _establish_parentage_str(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_str), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_str
                    v._pbf_establish_parent_callback = self._establish_parentage_str
    
        def _set_str(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_str(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field str"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_string
    
        def _mod_str(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_string
    
        def _del_str(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "str"
    
        str = property(_get_str, _set_str, _del_str)
    
        @property
        def str__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def str__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_str(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_str)
    
        
        def _get_data(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_bytes, 'data')
                self._cache[2] = r
            return r
    
        def _establish_parentage_data(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_data
                    v._pbf_establish_parent_callback = self._establish_parentage_data
    
        def _set_data(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_data(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field data"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_bytes
    
        def _mod_data(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_bytes
    
        def _del_data(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "data"
    
        data = property(_get_data, _set_data, _del_data)
    
        @property
        def data__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def data__type(self):
            return ProtoBase.TYPE_bytes
    
        def _finalize_data(cls):
            if is_string(ProtoBase.TYPE_bytes):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_data)
    
        
    TYPE_items_t = items_t
    _PB_finalizers.append('CDemoStringTables.items_t')
    
    TYPE_items_t = items_t
    
    class table_t(ProtoBase):
        _required = []
        _field_map = {'items': 2, 'items_clientside': 3, 'table_name': 1, 'table_flags': 4}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['table_name', 'items', 'items_clientside', 'table_flags']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_table_name(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_string, 'table_name')
                self._cache[1] = r
            return r
    
        def _establish_parentage_table_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_table_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_table_name
                    v._pbf_establish_parent_callback = self._establish_parentage_table_name
    
        def _set_table_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_table_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field table_name"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_string
    
        def _mod_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_string
    
        def _del_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "table_name"
    
        table_name = property(_get_table_name, _set_table_name, _del_table_name)
    
        @property
        def table_name__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def table_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_table_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_table_name)
    
        
        class Repeated_items(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CDemoStringTables.TYPE_items_t
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_items = Repeated_items
    
        
        @property
        def items__stream(self):
            if 2 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[2]]
            return self._get_repeated(2, self.TYPE_Repeated_items, "items", lazy=True)
    
        def items__fast_append(self, value):
            self._append_to_repeated(2, self.TYPE_Repeated_items, value)
        
        def _get_items(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, self.TYPE_Repeated_items, 'items')
                self._cache[2] = r
            return r
    
        def _establish_parentage_items(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_items), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_items
                    v._pbf_establish_parent_callback = self._establish_parentage_items
    
        def _set_items(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_items(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field items"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = self.TYPE_Repeated_items
    
        def _mod_items(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = self.TYPE_Repeated_items
    
        def _del_items(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "items"
    
        items = property(_get_items, _set_items, _del_items)
    
        @property
        def items__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def items__type(self):
            return self.TYPE_Repeated_items
    
        def _finalize_items(cls):
            if is_string(cls.TYPE_Repeated_items):
                cls._pbf_strings.append(2)
            elif _PB_type(cls.TYPE_Repeated_items) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_items, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_items.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_items)
    
        
        class Repeated_items_clientside(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CDemoStringTables.TYPE_items_t
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_items_clientside = Repeated_items_clientside
    
        
        @property
        def items_clientside__stream(self):
            if 3 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[3]]
            return self._get_repeated(3, self.TYPE_Repeated_items_clientside, "items_clientside", lazy=True)
    
        def items_clientside__fast_append(self, value):
            self._append_to_repeated(3, self.TYPE_Repeated_items_clientside, value)
        
        def _get_items_clientside(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, self.TYPE_Repeated_items_clientside, 'items_clientside')
                self._cache[3] = r
            return r
    
        def _establish_parentage_items_clientside(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_items_clientside), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_items_clientside
                    v._pbf_establish_parent_callback = self._establish_parentage_items_clientside
    
        def _set_items_clientside(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_items_clientside(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field items_clientside"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = self.TYPE_Repeated_items_clientside
    
        def _mod_items_clientside(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = self.TYPE_Repeated_items_clientside
    
        def _del_items_clientside(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "items_clientside"
    
        items_clientside = property(_get_items_clientside, _set_items_clientside, _del_items_clientside)
    
        @property
        def items_clientside__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def items_clientside__type(self):
            return self.TYPE_Repeated_items_clientside
    
        def _finalize_items_clientside(cls):
            if is_string(cls.TYPE_Repeated_items_clientside):
                cls._pbf_strings.append(3)
            elif _PB_type(cls.TYPE_Repeated_items_clientside) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_items_clientside, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_items_clientside.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_items_clientside)
    
        
        def _get_table_flags(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_int32, 'table_flags')
                self._cache[4] = r
            return r
    
        def _establish_parentage_table_flags(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_table_flags), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_table_flags
                    v._pbf_establish_parent_callback = self._establish_parentage_table_flags
    
        def _set_table_flags(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_table_flags(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field table_flags"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _mod_table_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _del_table_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "table_flags"
    
        table_flags = property(_get_table_flags, _set_table_flags, _del_table_flags)
    
        @property
        def table_flags__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def table_flags__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_table_flags(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_table_flags)
    
        
    TYPE_table_t = table_t
    _PB_finalizers.append('CDemoStringTables.table_t')
    
    TYPE_table_t = table_t

    class Repeated_tables(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CDemoStringTables.TYPE_table_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_tables = Repeated_tables


    @property
    def tables__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_tables, "tables", lazy=True)

    def tables__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_tables, value)

    def _get_tables(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_tables, 'tables')
            self._cache[1] = r
        return r

    def _establish_parentage_tables(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tables), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tables
                v._pbf_establish_parent_callback = self._establish_parentage_tables

    def _set_tables(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tables(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tables"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_tables

    def _mod_tables(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_tables

    def _del_tables(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "tables"

    tables = property(_get_tables, _set_tables, _del_tables)

    @property
    def tables__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def tables__type(self):
        return self.TYPE_Repeated_tables

    def _finalize_tables(cls):
        if is_string(cls.TYPE_Repeated_tables):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_tables) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_tables, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_tables.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_tables)


TYPE_CDemoStringTables = CDemoStringTables
_PB_finalizers.append('CDemoStringTables')

class CDemoStop(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDemoStop = CDemoStop
_PB_finalizers.append('CDemoStop')

class CDemoUserCmd(ProtoBase):
    _required = []
    _field_map = {'cmd_number': 1, 'data': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['cmd_number', 'data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_cmd_number(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'cmd_number')
            self._cache[1] = r
        return r

    def _establish_parentage_cmd_number(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cmd_number), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cmd_number
                v._pbf_establish_parent_callback = self._establish_parentage_cmd_number

    def _set_cmd_number(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cmd_number(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cmd_number"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_cmd_number(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_cmd_number(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "cmd_number"

    cmd_number = property(_get_cmd_number, _set_cmd_number, _del_cmd_number)

    @property
    def cmd_number__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def cmd_number__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_cmd_number(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_cmd_number)


    def _get_data(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bytes, 'data')
            self._cache[2] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_data)


TYPE_CDemoUserCmd = CDemoUserCmd
_PB_finalizers.append('CDemoUserCmd')

class CDOTAMsg_LocationPing(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'type': 5, 'target': 3, 'direct_ping': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'target', 'direct_ping', 'type']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_target(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'target')
            self._cache[3] = r
        return r

    def _establish_parentage_target(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target
                v._pbf_establish_parent_callback = self._establish_parentage_target

    def _set_target(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_target(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_target(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "target"

    target = property(_get_target, _set_target, _del_target)

    @property
    def target__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def target__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_target(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_target)


    def _get_direct_ping(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'direct_ping')
            self._cache[4] = r
        return r

    def _establish_parentage_direct_ping(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_direct_ping), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_direct_ping
                v._pbf_establish_parent_callback = self._establish_parentage_direct_ping

    def _set_direct_ping(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_direct_ping(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field direct_ping"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_direct_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_direct_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "direct_ping"

    direct_ping = property(_get_direct_ping, _set_direct_ping, _del_direct_ping)

    @property
    def direct_ping__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def direct_ping__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_direct_ping(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_direct_ping)


    def _get_type(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'type')
            self._cache[5] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_type)


TYPE_CDOTAMsg_LocationPing = CDOTAMsg_LocationPing
_PB_finalizers.append('CDOTAMsg_LocationPing')

class CDOTAMsg_ItemAlert(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'itemid': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'itemid']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_itemid(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'itemid')
            self._cache[3] = r
        return r

    def _establish_parentage_itemid(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_itemid), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_itemid
                v._pbf_establish_parent_callback = self._establish_parentage_itemid

    def _set_itemid(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_itemid(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field itemid"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_itemid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_itemid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "itemid"

    itemid = property(_get_itemid, _set_itemid, _del_itemid)

    @property
    def itemid__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def itemid__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_itemid(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_itemid)


TYPE_CDOTAMsg_ItemAlert = CDOTAMsg_ItemAlert
_PB_finalizers.append('CDOTAMsg_ItemAlert')

class CDOTAMsg_MapLine(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'initial': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'initial']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_initial(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'initial')
            self._cache[3] = r
        return r

    def _establish_parentage_initial(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_initial), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_initial
                v._pbf_establish_parent_callback = self._establish_parentage_initial

    def _set_initial(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_initial(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field initial"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_initial(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_initial(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "initial"

    initial = property(_get_initial, _set_initial, _del_initial)

    @property
    def initial__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def initial__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_initial(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_initial)


TYPE_CDOTAMsg_MapLine = CDOTAMsg_MapLine
_PB_finalizers.append('CDOTAMsg_MapLine')

class CDOTAMsg_WorldLine(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'z': 3, 'end': 5, 'initial': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'z', 'initial', 'end']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_z(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'z')
            self._cache[3] = r
        return r

    def _establish_parentage_z(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_z), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_z
                v._pbf_establish_parent_callback = self._establish_parentage_z

    def _set_z(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_z(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field z"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "z"

    z = property(_get_z, _set_z, _del_z)

    @property
    def z__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def z__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_z(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_z)


    def _get_initial(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'initial')
            self._cache[4] = r
        return r

    def _establish_parentage_initial(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_initial), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_initial
                v._pbf_establish_parent_callback = self._establish_parentage_initial

    def _set_initial(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_initial(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field initial"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_initial(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_initial(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "initial"

    initial = property(_get_initial, _set_initial, _del_initial)

    @property
    def initial__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def initial__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_initial(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_initial)


    def _get_end(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bool, 'end')
            self._cache[5] = r
        return r

    def _establish_parentage_end(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_end), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_end
                v._pbf_establish_parent_callback = self._establish_parentage_end

    def _set_end(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_end(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field end"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bool

    def _mod_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bool

    def _del_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "end"

    end = property(_get_end, _set_end, _del_end)

    @property
    def end__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def end__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_end(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_end)


TYPE_CDOTAMsg_WorldLine = CDOTAMsg_WorldLine
_PB_finalizers.append('CDOTAMsg_WorldLine')

class CDOTAMsg_SendStatPopup(ProtoBase):
    _required = []
    _field_map = {'style': 1, 'stat_images': 3, 'stat_strings': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['style', 'stat_strings', 'stat_images']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_style(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_EDOTAStatPopupTypes, 'style')
            except:
                r = k_EDOTA_SPT_Textline
            self._cache[1] = r
        return r

    def _establish_parentage_style(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_style), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_style
                v._pbf_establish_parent_callback = self._establish_parentage_style

    def _set_style(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_style(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field style"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_EDOTAStatPopupTypes

    def _mod_style(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_EDOTAStatPopupTypes

    def _del_style(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "style"

    style = property(_get_style, _set_style, _del_style)

    @property
    def style__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def style__type(self):
        return TYPE_EDOTAStatPopupTypes

    def _finalize_style(cls):
        if is_string(TYPE_EDOTAStatPopupTypes):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_EDOTAStatPopupTypes) is _PB_type:
            assert issubclass(TYPE_EDOTAStatPopupTypes, RepeatedSequence)
            if is_string(TYPE_EDOTAStatPopupTypes.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_style)


    class Repeated_stat_strings(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_stat_strings = Repeated_stat_strings


    def _get_stat_strings(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_stat_strings, 'stat_strings')
            self._cache[2] = r
        return r

    def _establish_parentage_stat_strings(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_stat_strings), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_stat_strings
                v._pbf_establish_parent_callback = self._establish_parentage_stat_strings

    def _set_stat_strings(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_stat_strings(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field stat_strings"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_stat_strings

    def _mod_stat_strings(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_stat_strings

    def _del_stat_strings(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "stat_strings"

    stat_strings = property(_get_stat_strings, _set_stat_strings, _del_stat_strings)

    @property
    def stat_strings__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def stat_strings__type(self):
        return self.TYPE_Repeated_stat_strings

    def _finalize_stat_strings(cls):
        if is_string(cls.TYPE_Repeated_stat_strings):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_stat_strings) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_stat_strings, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_stat_strings.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_stat_strings)


    class Repeated_stat_images(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_int32
        pb_subtype = pb_subtype()


    TYPE_Repeated_stat_images = Repeated_stat_images


    def _get_stat_images(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, self.TYPE_Repeated_stat_images, 'stat_images')
            self._cache[3] = r
        return r

    def _establish_parentage_stat_images(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_stat_images), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_stat_images
                v._pbf_establish_parent_callback = self._establish_parentage_stat_images

    def _set_stat_images(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_stat_images(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field stat_images"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = self.TYPE_Repeated_stat_images

    def _mod_stat_images(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = self.TYPE_Repeated_stat_images

    def _del_stat_images(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "stat_images"

    stat_images = property(_get_stat_images, _set_stat_images, _del_stat_images)

    @property
    def stat_images__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def stat_images__type(self):
        return self.TYPE_Repeated_stat_images

    def _finalize_stat_images(cls):
        if is_string(cls.TYPE_Repeated_stat_images):
            cls._pbf_strings.append(3)
        elif _PB_type(cls.TYPE_Repeated_stat_images) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_stat_images, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_stat_images.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_stat_images)


TYPE_CDOTAMsg_SendStatPopup = CDOTAMsg_SendStatPopup
_PB_finalizers.append('CDOTAMsg_SendStatPopup')

class CDOTAMsg_CoachHUDPing(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'tgtpath': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'tgtpath']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_tgtpath(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'tgtpath')
            self._cache[3] = r
        return r

    def _establish_parentage_tgtpath(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tgtpath), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tgtpath
                v._pbf_establish_parent_callback = self._establish_parentage_tgtpath

    def _set_tgtpath(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tgtpath(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tgtpath"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_tgtpath(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_tgtpath(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "tgtpath"

    tgtpath = property(_get_tgtpath, _set_tgtpath, _del_tgtpath)

    @property
    def tgtpath__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def tgtpath__type(self):
        return ProtoBase.TYPE_string

    def _finalize_tgtpath(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_tgtpath)


TYPE_CDOTAMsg_CoachHUDPing = CDOTAMsg_CoachHUDPing
_PB_finalizers.append('CDOTAMsg_CoachHUDPing')

class CDOTAModifierBuffTableEntry(ProtoBase):
    _required = [1, 2, 3, 4]
    _field_map = {'ability_level': 6, 'creation_time': 8, 'movement_speed': 22, 'duration': 9, 'subtle': 14, 'caster': 10, 'dd_modifier_index': 27, 'index': 3, 'stack_count': 7, 'armor': 12, 'dd_ability_index': 28, 'damage': 25, 'serial_num': 4, 'v_start': 16, 'portal_loop_appear': 18, 'portal_loop_disappear': 19, 'ability': 11, 'parent': 2, 'hero_loop_appear': 20, 'modifier_class': 5, 'activity': 24, 'hero_loop_disappear': 21, 'entry_type': 1, 'fade_time': 13, 'range': 26, 'channel_time': 15, 'aura': 23, 'v_end': 17}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entry_type', 'parent', 'index', 'serial_num', 'modifier_class', 'ability_level', 'stack_count', 'creation_time', 'duration', 'caster', 'ability', 'armor', 'fade_time', 'subtle', 'channel_time', 'v_start', 'v_end', 'portal_loop_appear', 'portal_loop_disappear', 'hero_loop_appear', 'hero_loop_disappear', 'movement_speed', 'aura', 'activity', 'damage', 'range', 'dd_modifier_index', 'dd_ability_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entry_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_DOTA_MODIFIER_ENTRY_TYPE, 'entry_type')
            except:
                r = DOTA_MODIFIER_ENTRY_TYPE_ACTIVE
            self._cache[1] = r
        return r

    def _establish_parentage_entry_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entry_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entry_type
                v._pbf_establish_parent_callback = self._establish_parentage_entry_type

    def _set_entry_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entry_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entry_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_DOTA_MODIFIER_ENTRY_TYPE

    def _mod_entry_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_DOTA_MODIFIER_ENTRY_TYPE

    def _del_entry_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entry_type"

    entry_type = property(_get_entry_type, _set_entry_type, _del_entry_type)

    @property
    def entry_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entry_type__type(self):
        return TYPE_DOTA_MODIFIER_ENTRY_TYPE

    def _finalize_entry_type(cls):
        if is_string(TYPE_DOTA_MODIFIER_ENTRY_TYPE):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_DOTA_MODIFIER_ENTRY_TYPE) is _PB_type:
            assert issubclass(TYPE_DOTA_MODIFIER_ENTRY_TYPE, RepeatedSequence)
            if is_string(TYPE_DOTA_MODIFIER_ENTRY_TYPE.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entry_type)


    def _get_parent(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'parent')
            self._cache[2] = r
        return r

    def _establish_parentage_parent(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_parent), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_parent
                v._pbf_establish_parent_callback = self._establish_parentage_parent

    def _set_parent(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_parent(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field parent"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_parent(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_parent(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "parent"

    parent = property(_get_parent, _set_parent, _del_parent)

    @property
    def parent__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def parent__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_parent(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_parent)


    def _get_index(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'index')
            self._cache[3] = r
        return r

    def _establish_parentage_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_index
                v._pbf_establish_parent_callback = self._establish_parentage_index

    def _set_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field index"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "index"

    index = property(_get_index, _set_index, _del_index)

    @property
    def index__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_index)


    def _get_serial_num(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'serial_num')
            self._cache[4] = r
        return r

    def _establish_parentage_serial_num(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_serial_num), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_serial_num
                v._pbf_establish_parent_callback = self._establish_parentage_serial_num

    def _set_serial_num(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_serial_num(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field serial_num"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_serial_num(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_serial_num(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "serial_num"

    serial_num = property(_get_serial_num, _set_serial_num, _del_serial_num)

    @property
    def serial_num__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def serial_num__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_serial_num(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_serial_num)


    def _get_modifier_class(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'modifier_class')
            self._cache[5] = r
        return r

    def _establish_parentage_modifier_class(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_modifier_class), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_modifier_class
                v._pbf_establish_parent_callback = self._establish_parentage_modifier_class

    def _set_modifier_class(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_modifier_class(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field modifier_class"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_modifier_class(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_modifier_class(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "modifier_class"

    modifier_class = property(_get_modifier_class, _set_modifier_class, _del_modifier_class)

    @property
    def modifier_class__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def modifier_class__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_modifier_class(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_modifier_class)


    def _get_ability_level(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_int32, 'ability_level')
            self._cache[6] = r
        return r

    def _establish_parentage_ability_level(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ability_level), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ability_level
                v._pbf_establish_parent_callback = self._establish_parentage_ability_level

    def _set_ability_level(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ability_level(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ability_level"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_int32

    def _mod_ability_level(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_int32

    def _del_ability_level(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "ability_level"

    ability_level = property(_get_ability_level, _set_ability_level, _del_ability_level)

    @property
    def ability_level__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def ability_level__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_ability_level(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_ability_level)


    def _get_stack_count(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_int32, 'stack_count')
            self._cache[7] = r
        return r

    def _establish_parentage_stack_count(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_stack_count), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_stack_count
                v._pbf_establish_parent_callback = self._establish_parentage_stack_count

    def _set_stack_count(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_stack_count(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field stack_count"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_int32

    def _mod_stack_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_int32

    def _del_stack_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "stack_count"

    stack_count = property(_get_stack_count, _set_stack_count, _del_stack_count)

    @property
    def stack_count__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def stack_count__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_stack_count(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_stack_count)


    def _get_creation_time(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_float, 'creation_time')
            self._cache[8] = r
        return r

    def _establish_parentage_creation_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_creation_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_creation_time
                v._pbf_establish_parent_callback = self._establish_parentage_creation_time

    def _set_creation_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_creation_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field creation_time"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_float

    def _mod_creation_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_float

    def _del_creation_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "creation_time"

    creation_time = property(_get_creation_time, _set_creation_time, _del_creation_time)

    @property
    def creation_time__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def creation_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_creation_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_creation_time)


    def _get_duration(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            try:
                r = self._buf_get(9, ProtoBase.TYPE_float, 'duration')
            except:
                r = -1
            self._cache[9] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(9)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_duration)


    def _get_caster(self):
        if 10 in self._cache:
            r = self._cache[10]
        else:
            r = self._buf_get(10, ProtoBase.TYPE_int32, 'caster')
            self._cache[10] = r
        return r

    def _establish_parentage_caster(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_caster), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_caster
                v._pbf_establish_parent_callback = self._establish_parentage_caster

    def _set_caster(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_caster(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field caster"
            raise ProtoValueError(list_assign_error)
        self._cache[10] = v
        self._mods[10] = ProtoBase.TYPE_int32

    def _mod_caster(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[10] = ProtoBase.TYPE_int32

    def _del_caster(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 10 in self._cache:
            del self._cache[10]
        if 10 in self._mods:
            del self._mods[10]
        self._buf_del(10)

    _pb_field_name_10 = "caster"

    caster = property(_get_caster, _set_caster, _del_caster)

    @property
    def caster__exists(self):
        return 10 in self._mods or self._buf_exists(10)

    @property
    def caster__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_caster(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(10)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(10)

    _pbf_finalizers.append(_finalize_caster)


    def _get_ability(self):
        if 11 in self._cache:
            r = self._cache[11]
        else:
            r = self._buf_get(11, ProtoBase.TYPE_int32, 'ability')
            self._cache[11] = r
        return r

    def _establish_parentage_ability(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ability), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ability
                v._pbf_establish_parent_callback = self._establish_parentage_ability

    def _set_ability(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ability(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ability"
            raise ProtoValueError(list_assign_error)
        self._cache[11] = v
        self._mods[11] = ProtoBase.TYPE_int32

    def _mod_ability(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[11] = ProtoBase.TYPE_int32

    def _del_ability(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 11 in self._cache:
            del self._cache[11]
        if 11 in self._mods:
            del self._mods[11]
        self._buf_del(11)

    _pb_field_name_11 = "ability"

    ability = property(_get_ability, _set_ability, _del_ability)

    @property
    def ability__exists(self):
        return 11 in self._mods or self._buf_exists(11)

    @property
    def ability__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_ability(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(11)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(11)

    _pbf_finalizers.append(_finalize_ability)


    def _get_armor(self):
        if 12 in self._cache:
            r = self._cache[12]
        else:
            r = self._buf_get(12, ProtoBase.TYPE_int32, 'armor')
            self._cache[12] = r
        return r

    def _establish_parentage_armor(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_armor), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_armor
                v._pbf_establish_parent_callback = self._establish_parentage_armor

    def _set_armor(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_armor(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field armor"
            raise ProtoValueError(list_assign_error)
        self._cache[12] = v
        self._mods[12] = ProtoBase.TYPE_int32

    def _mod_armor(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[12] = ProtoBase.TYPE_int32

    def _del_armor(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 12 in self._cache:
            del self._cache[12]
        if 12 in self._mods:
            del self._mods[12]
        self._buf_del(12)

    _pb_field_name_12 = "armor"

    armor = property(_get_armor, _set_armor, _del_armor)

    @property
    def armor__exists(self):
        return 12 in self._mods or self._buf_exists(12)

    @property
    def armor__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_armor(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(12)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(12)

    _pbf_finalizers.append(_finalize_armor)


    def _get_fade_time(self):
        if 13 in self._cache:
            r = self._cache[13]
        else:
            r = self._buf_get(13, ProtoBase.TYPE_float, 'fade_time')
            self._cache[13] = r
        return r

    def _establish_parentage_fade_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fade_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fade_time
                v._pbf_establish_parent_callback = self._establish_parentage_fade_time

    def _set_fade_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fade_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fade_time"
            raise ProtoValueError(list_assign_error)
        self._cache[13] = v
        self._mods[13] = ProtoBase.TYPE_float

    def _mod_fade_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[13] = ProtoBase.TYPE_float

    def _del_fade_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 13 in self._cache:
            del self._cache[13]
        if 13 in self._mods:
            del self._mods[13]
        self._buf_del(13)

    _pb_field_name_13 = "fade_time"

    fade_time = property(_get_fade_time, _set_fade_time, _del_fade_time)

    @property
    def fade_time__exists(self):
        return 13 in self._mods or self._buf_exists(13)

    @property
    def fade_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_fade_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(13)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(13)

    _pbf_finalizers.append(_finalize_fade_time)


    def _get_subtle(self):
        if 14 in self._cache:
            r = self._cache[14]
        else:
            r = self._buf_get(14, ProtoBase.TYPE_bool, 'subtle')
            self._cache[14] = r
        return r

    def _establish_parentage_subtle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_subtle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_subtle
                v._pbf_establish_parent_callback = self._establish_parentage_subtle

    def _set_subtle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_subtle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field subtle"
            raise ProtoValueError(list_assign_error)
        self._cache[14] = v
        self._mods[14] = ProtoBase.TYPE_bool

    def _mod_subtle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[14] = ProtoBase.TYPE_bool

    def _del_subtle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 14 in self._cache:
            del self._cache[14]
        if 14 in self._mods:
            del self._mods[14]
        self._buf_del(14)

    _pb_field_name_14 = "subtle"

    subtle = property(_get_subtle, _set_subtle, _del_subtle)

    @property
    def subtle__exists(self):
        return 14 in self._mods or self._buf_exists(14)

    @property
    def subtle__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_subtle(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(14)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(14)

    _pbf_finalizers.append(_finalize_subtle)


    def _get_channel_time(self):
        if 15 in self._cache:
            r = self._cache[15]
        else:
            r = self._buf_get(15, ProtoBase.TYPE_float, 'channel_time')
            self._cache[15] = r
        return r

    def _establish_parentage_channel_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_channel_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_channel_time
                v._pbf_establish_parent_callback = self._establish_parentage_channel_time

    def _set_channel_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_channel_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field channel_time"
            raise ProtoValueError(list_assign_error)
        self._cache[15] = v
        self._mods[15] = ProtoBase.TYPE_float

    def _mod_channel_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[15] = ProtoBase.TYPE_float

    def _del_channel_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 15 in self._cache:
            del self._cache[15]
        if 15 in self._mods:
            del self._mods[15]
        self._buf_del(15)

    _pb_field_name_15 = "channel_time"

    channel_time = property(_get_channel_time, _set_channel_time, _del_channel_time)

    @property
    def channel_time__exists(self):
        return 15 in self._mods or self._buf_exists(15)

    @property
    def channel_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_channel_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(15)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(15)

    _pbf_finalizers.append(_finalize_channel_time)


    def _get_v_start(self):
        if 16 in self._cache:
            r = self._cache[16]
        else:
            r = self._buf_get(16, TYPE_CMsgVector, 'v_start')
            self._cache[16] = r
        return r

    def _establish_parentage_v_start(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_v_start), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_v_start
                v._pbf_establish_parent_callback = self._establish_parentage_v_start

    def _set_v_start(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_v_start(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field v_start"
            raise ProtoValueError(list_assign_error)
        self._cache[16] = v
        self._mods[16] = TYPE_CMsgVector

    def _mod_v_start(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[16] = TYPE_CMsgVector

    def _del_v_start(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 16 in self._cache:
            del self._cache[16]
        if 16 in self._mods:
            del self._mods[16]
        self._buf_del(16)

    _pb_field_name_16 = "v_start"

    v_start = property(_get_v_start, _set_v_start, _del_v_start)

    @property
    def v_start__exists(self):
        return 16 in self._mods or self._buf_exists(16)

    @property
    def v_start__type(self):
        return TYPE_CMsgVector

    def _finalize_v_start(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(16)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(16)

    _pbf_finalizers.append(_finalize_v_start)


    def _get_v_end(self):
        if 17 in self._cache:
            r = self._cache[17]
        else:
            r = self._buf_get(17, TYPE_CMsgVector, 'v_end')
            self._cache[17] = r
        return r

    def _establish_parentage_v_end(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_v_end), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_v_end
                v._pbf_establish_parent_callback = self._establish_parentage_v_end

    def _set_v_end(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_v_end(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field v_end"
            raise ProtoValueError(list_assign_error)
        self._cache[17] = v
        self._mods[17] = TYPE_CMsgVector

    def _mod_v_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[17] = TYPE_CMsgVector

    def _del_v_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 17 in self._cache:
            del self._cache[17]
        if 17 in self._mods:
            del self._mods[17]
        self._buf_del(17)

    _pb_field_name_17 = "v_end"

    v_end = property(_get_v_end, _set_v_end, _del_v_end)

    @property
    def v_end__exists(self):
        return 17 in self._mods or self._buf_exists(17)

    @property
    def v_end__type(self):
        return TYPE_CMsgVector

    def _finalize_v_end(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(17)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(17)

    _pbf_finalizers.append(_finalize_v_end)


    def _get_portal_loop_appear(self):
        if 18 in self._cache:
            r = self._cache[18]
        else:
            r = self._buf_get(18, ProtoBase.TYPE_string, 'portal_loop_appear')
            self._cache[18] = r
        return r

    def _establish_parentage_portal_loop_appear(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_portal_loop_appear), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_portal_loop_appear
                v._pbf_establish_parent_callback = self._establish_parentage_portal_loop_appear

    def _set_portal_loop_appear(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_portal_loop_appear(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field portal_loop_appear"
            raise ProtoValueError(list_assign_error)
        self._cache[18] = v
        self._mods[18] = ProtoBase.TYPE_string

    def _mod_portal_loop_appear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[18] = ProtoBase.TYPE_string

    def _del_portal_loop_appear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 18 in self._cache:
            del self._cache[18]
        if 18 in self._mods:
            del self._mods[18]
        self._buf_del(18)

    _pb_field_name_18 = "portal_loop_appear"

    portal_loop_appear = property(_get_portal_loop_appear, _set_portal_loop_appear, _del_portal_loop_appear)

    @property
    def portal_loop_appear__exists(self):
        return 18 in self._mods or self._buf_exists(18)

    @property
    def portal_loop_appear__type(self):
        return ProtoBase.TYPE_string

    def _finalize_portal_loop_appear(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(18)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(18)

    _pbf_finalizers.append(_finalize_portal_loop_appear)


    def _get_portal_loop_disappear(self):
        if 19 in self._cache:
            r = self._cache[19]
        else:
            r = self._buf_get(19, ProtoBase.TYPE_string, 'portal_loop_disappear')
            self._cache[19] = r
        return r

    def _establish_parentage_portal_loop_disappear(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_portal_loop_disappear), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_portal_loop_disappear
                v._pbf_establish_parent_callback = self._establish_parentage_portal_loop_disappear

    def _set_portal_loop_disappear(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_portal_loop_disappear(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field portal_loop_disappear"
            raise ProtoValueError(list_assign_error)
        self._cache[19] = v
        self._mods[19] = ProtoBase.TYPE_string

    def _mod_portal_loop_disappear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[19] = ProtoBase.TYPE_string

    def _del_portal_loop_disappear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 19 in self._cache:
            del self._cache[19]
        if 19 in self._mods:
            del self._mods[19]
        self._buf_del(19)

    _pb_field_name_19 = "portal_loop_disappear"

    portal_loop_disappear = property(_get_portal_loop_disappear, _set_portal_loop_disappear, _del_portal_loop_disappear)

    @property
    def portal_loop_disappear__exists(self):
        return 19 in self._mods or self._buf_exists(19)

    @property
    def portal_loop_disappear__type(self):
        return ProtoBase.TYPE_string

    def _finalize_portal_loop_disappear(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(19)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(19)

    _pbf_finalizers.append(_finalize_portal_loop_disappear)


    def _get_hero_loop_appear(self):
        if 20 in self._cache:
            r = self._cache[20]
        else:
            r = self._buf_get(20, ProtoBase.TYPE_string, 'hero_loop_appear')
            self._cache[20] = r
        return r

    def _establish_parentage_hero_loop_appear(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hero_loop_appear), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hero_loop_appear
                v._pbf_establish_parent_callback = self._establish_parentage_hero_loop_appear

    def _set_hero_loop_appear(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hero_loop_appear(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hero_loop_appear"
            raise ProtoValueError(list_assign_error)
        self._cache[20] = v
        self._mods[20] = ProtoBase.TYPE_string

    def _mod_hero_loop_appear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[20] = ProtoBase.TYPE_string

    def _del_hero_loop_appear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 20 in self._cache:
            del self._cache[20]
        if 20 in self._mods:
            del self._mods[20]
        self._buf_del(20)

    _pb_field_name_20 = "hero_loop_appear"

    hero_loop_appear = property(_get_hero_loop_appear, _set_hero_loop_appear, _del_hero_loop_appear)

    @property
    def hero_loop_appear__exists(self):
        return 20 in self._mods or self._buf_exists(20)

    @property
    def hero_loop_appear__type(self):
        return ProtoBase.TYPE_string

    def _finalize_hero_loop_appear(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(20)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(20)

    _pbf_finalizers.append(_finalize_hero_loop_appear)


    def _get_hero_loop_disappear(self):
        if 21 in self._cache:
            r = self._cache[21]
        else:
            r = self._buf_get(21, ProtoBase.TYPE_string, 'hero_loop_disappear')
            self._cache[21] = r
        return r

    def _establish_parentage_hero_loop_disappear(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hero_loop_disappear), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hero_loop_disappear
                v._pbf_establish_parent_callback = self._establish_parentage_hero_loop_disappear

    def _set_hero_loop_disappear(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hero_loop_disappear(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hero_loop_disappear"
            raise ProtoValueError(list_assign_error)
        self._cache[21] = v
        self._mods[21] = ProtoBase.TYPE_string

    def _mod_hero_loop_disappear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[21] = ProtoBase.TYPE_string

    def _del_hero_loop_disappear(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 21 in self._cache:
            del self._cache[21]
        if 21 in self._mods:
            del self._mods[21]
        self._buf_del(21)

    _pb_field_name_21 = "hero_loop_disappear"

    hero_loop_disappear = property(_get_hero_loop_disappear, _set_hero_loop_disappear, _del_hero_loop_disappear)

    @property
    def hero_loop_disappear__exists(self):
        return 21 in self._mods or self._buf_exists(21)

    @property
    def hero_loop_disappear__type(self):
        return ProtoBase.TYPE_string

    def _finalize_hero_loop_disappear(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(21)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(21)

    _pbf_finalizers.append(_finalize_hero_loop_disappear)


    def _get_movement_speed(self):
        if 22 in self._cache:
            r = self._cache[22]
        else:
            r = self._buf_get(22, ProtoBase.TYPE_int32, 'movement_speed')
            self._cache[22] = r
        return r

    def _establish_parentage_movement_speed(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_movement_speed), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_movement_speed
                v._pbf_establish_parent_callback = self._establish_parentage_movement_speed

    def _set_movement_speed(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_movement_speed(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field movement_speed"
            raise ProtoValueError(list_assign_error)
        self._cache[22] = v
        self._mods[22] = ProtoBase.TYPE_int32

    def _mod_movement_speed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[22] = ProtoBase.TYPE_int32

    def _del_movement_speed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 22 in self._cache:
            del self._cache[22]
        if 22 in self._mods:
            del self._mods[22]
        self._buf_del(22)

    _pb_field_name_22 = "movement_speed"

    movement_speed = property(_get_movement_speed, _set_movement_speed, _del_movement_speed)

    @property
    def movement_speed__exists(self):
        return 22 in self._mods or self._buf_exists(22)

    @property
    def movement_speed__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_movement_speed(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(22)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(22)

    _pbf_finalizers.append(_finalize_movement_speed)


    def _get_aura(self):
        if 23 in self._cache:
            r = self._cache[23]
        else:
            r = self._buf_get(23, ProtoBase.TYPE_bool, 'aura')
            self._cache[23] = r
        return r

    def _establish_parentage_aura(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_aura), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_aura
                v._pbf_establish_parent_callback = self._establish_parentage_aura

    def _set_aura(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_aura(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field aura"
            raise ProtoValueError(list_assign_error)
        self._cache[23] = v
        self._mods[23] = ProtoBase.TYPE_bool

    def _mod_aura(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[23] = ProtoBase.TYPE_bool

    def _del_aura(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 23 in self._cache:
            del self._cache[23]
        if 23 in self._mods:
            del self._mods[23]
        self._buf_del(23)

    _pb_field_name_23 = "aura"

    aura = property(_get_aura, _set_aura, _del_aura)

    @property
    def aura__exists(self):
        return 23 in self._mods or self._buf_exists(23)

    @property
    def aura__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_aura(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(23)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(23)

    _pbf_finalizers.append(_finalize_aura)


    def _get_activity(self):
        if 24 in self._cache:
            r = self._cache[24]
        else:
            r = self._buf_get(24, ProtoBase.TYPE_int32, 'activity')
            self._cache[24] = r
        return r

    def _establish_parentage_activity(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_activity), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_activity
                v._pbf_establish_parent_callback = self._establish_parentage_activity

    def _set_activity(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_activity(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field activity"
            raise ProtoValueError(list_assign_error)
        self._cache[24] = v
        self._mods[24] = ProtoBase.TYPE_int32

    def _mod_activity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[24] = ProtoBase.TYPE_int32

    def _del_activity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 24 in self._cache:
            del self._cache[24]
        if 24 in self._mods:
            del self._mods[24]
        self._buf_del(24)

    _pb_field_name_24 = "activity"

    activity = property(_get_activity, _set_activity, _del_activity)

    @property
    def activity__exists(self):
        return 24 in self._mods or self._buf_exists(24)

    @property
    def activity__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_activity(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(24)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(24)

    _pbf_finalizers.append(_finalize_activity)


    def _get_damage(self):
        if 25 in self._cache:
            r = self._cache[25]
        else:
            r = self._buf_get(25, ProtoBase.TYPE_int32, 'damage')
            self._cache[25] = r
        return r

    def _establish_parentage_damage(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_damage), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_damage
                v._pbf_establish_parent_callback = self._establish_parentage_damage

    def _set_damage(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_damage(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field damage"
            raise ProtoValueError(list_assign_error)
        self._cache[25] = v
        self._mods[25] = ProtoBase.TYPE_int32

    def _mod_damage(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[25] = ProtoBase.TYPE_int32

    def _del_damage(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 25 in self._cache:
            del self._cache[25]
        if 25 in self._mods:
            del self._mods[25]
        self._buf_del(25)

    _pb_field_name_25 = "damage"

    damage = property(_get_damage, _set_damage, _del_damage)

    @property
    def damage__exists(self):
        return 25 in self._mods or self._buf_exists(25)

    @property
    def damage__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_damage(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(25)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(25)

    _pbf_finalizers.append(_finalize_damage)


    def _get_range(self):
        if 26 in self._cache:
            r = self._cache[26]
        else:
            r = self._buf_get(26, ProtoBase.TYPE_int32, 'range')
            self._cache[26] = r
        return r

    def _establish_parentage_range(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_range), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_range
                v._pbf_establish_parent_callback = self._establish_parentage_range

    def _set_range(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_range(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field range"
            raise ProtoValueError(list_assign_error)
        self._cache[26] = v
        self._mods[26] = ProtoBase.TYPE_int32

    def _mod_range(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[26] = ProtoBase.TYPE_int32

    def _del_range(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 26 in self._cache:
            del self._cache[26]
        if 26 in self._mods:
            del self._mods[26]
        self._buf_del(26)

    _pb_field_name_26 = "range"

    range = property(_get_range, _set_range, _del_range)

    @property
    def range__exists(self):
        return 26 in self._mods or self._buf_exists(26)

    @property
    def range__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_range(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(26)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(26)

    _pbf_finalizers.append(_finalize_range)


    def _get_dd_modifier_index(self):
        if 27 in self._cache:
            r = self._cache[27]
        else:
            r = self._buf_get(27, ProtoBase.TYPE_int32, 'dd_modifier_index')
            self._cache[27] = r
        return r

    def _establish_parentage_dd_modifier_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_dd_modifier_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_dd_modifier_index
                v._pbf_establish_parent_callback = self._establish_parentage_dd_modifier_index

    def _set_dd_modifier_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_dd_modifier_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field dd_modifier_index"
            raise ProtoValueError(list_assign_error)
        self._cache[27] = v
        self._mods[27] = ProtoBase.TYPE_int32

    def _mod_dd_modifier_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[27] = ProtoBase.TYPE_int32

    def _del_dd_modifier_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 27 in self._cache:
            del self._cache[27]
        if 27 in self._mods:
            del self._mods[27]
        self._buf_del(27)

    _pb_field_name_27 = "dd_modifier_index"

    dd_modifier_index = property(_get_dd_modifier_index, _set_dd_modifier_index, _del_dd_modifier_index)

    @property
    def dd_modifier_index__exists(self):
        return 27 in self._mods or self._buf_exists(27)

    @property
    def dd_modifier_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_dd_modifier_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(27)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(27)

    _pbf_finalizers.append(_finalize_dd_modifier_index)


    def _get_dd_ability_index(self):
        if 28 in self._cache:
            r = self._cache[28]
        else:
            r = self._buf_get(28, ProtoBase.TYPE_int32, 'dd_ability_index')
            self._cache[28] = r
        return r

    def _establish_parentage_dd_ability_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_dd_ability_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_dd_ability_index
                v._pbf_establish_parent_callback = self._establish_parentage_dd_ability_index

    def _set_dd_ability_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_dd_ability_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field dd_ability_index"
            raise ProtoValueError(list_assign_error)
        self._cache[28] = v
        self._mods[28] = ProtoBase.TYPE_int32

    def _mod_dd_ability_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[28] = ProtoBase.TYPE_int32

    def _del_dd_ability_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 28 in self._cache:
            del self._cache[28]
        if 28 in self._mods:
            del self._mods[28]
        self._buf_del(28)

    _pb_field_name_28 = "dd_ability_index"

    dd_ability_index = property(_get_dd_ability_index, _set_dd_ability_index, _del_dd_ability_index)

    @property
    def dd_ability_index__exists(self):
        return 28 in self._mods or self._buf_exists(28)

    @property
    def dd_ability_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_dd_ability_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(28)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(28)

    _pbf_finalizers.append(_finalize_dd_ability_index)


TYPE_CDOTAModifierBuffTableEntry = CDOTAModifierBuffTableEntry
_PB_finalizers.append('CDOTAModifierBuffTableEntry')

class CDOTAUserMsg_AIDebugLine(ProtoBase):
    _required = []
    _field_map = {'message': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


TYPE_CDOTAUserMsg_AIDebugLine = CDOTAUserMsg_AIDebugLine
_PB_finalizers.append('CDOTAUserMsg_AIDebugLine')

class CDOTAUserMsg_Ping(ProtoBase):
    _required = []
    _field_map = {'message': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


TYPE_CDOTAUserMsg_Ping = CDOTAUserMsg_Ping
_PB_finalizers.append('CDOTAUserMsg_Ping')

class CDOTAUserMsg_SwapVerify(ProtoBase):
    _required = []
    _field_map = {'player_id': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


TYPE_CDOTAUserMsg_SwapVerify = CDOTAUserMsg_SwapVerify
_PB_finalizers.append('CDOTAUserMsg_SwapVerify')

class CDOTAUserMsg_ChatEvent(ProtoBase):
    _required = [1]
    _field_map = {'playerid_6': 8, 'playerid_5': 7, 'playerid_4': 6, 'playerid_3': 5, 'playerid_2': 4, 'playerid_1': 3, 'value': 2, 'type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['type', 'value', 'playerid_1', 'playerid_2', 'playerid_3', 'playerid_4', 'playerid_5', 'playerid_6']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_DOTA_CHAT_MESSAGE, 'type')
            except:
                r = CHAT_MESSAGE_INVALID
            self._cache[1] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_DOTA_CHAT_MESSAGE

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_DOTA_CHAT_MESSAGE

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def type__type(self):
        return TYPE_DOTA_CHAT_MESSAGE

    def _finalize_type(cls):
        if is_string(TYPE_DOTA_CHAT_MESSAGE):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_DOTA_CHAT_MESSAGE) is _PB_type:
            assert issubclass(TYPE_DOTA_CHAT_MESSAGE, RepeatedSequence)
            if is_string(TYPE_DOTA_CHAT_MESSAGE.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_type)


    def _get_value(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'value')
            self._cache[2] = r
        return r

    def _establish_parentage_value(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_value
                v._pbf_establish_parent_callback = self._establish_parentage_value

    def _set_value(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_value(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field value"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "value"

    value = property(_get_value, _set_value, _del_value)

    @property
    def value__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def value__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_value(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_value)


    def _get_playerid_1(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            try:
                r = self._buf_get(3, ProtoBase.TYPE_sint32, 'playerid_1')
            except:
                r = -1
            self._cache[3] = r
        return r

    def _establish_parentage_playerid_1(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_1), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_1
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_1

    def _set_playerid_1(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_1(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_1"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_sint32

    def _mod_playerid_1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_sint32

    def _del_playerid_1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "playerid_1"

    playerid_1 = property(_get_playerid_1, _set_playerid_1, _del_playerid_1)

    @property
    def playerid_1__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def playerid_1__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_1(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_playerid_1)


    def _get_playerid_2(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            try:
                r = self._buf_get(4, ProtoBase.TYPE_sint32, 'playerid_2')
            except:
                r = -1
            self._cache[4] = r
        return r

    def _establish_parentage_playerid_2(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_2), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_2
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_2

    def _set_playerid_2(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_2(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_2"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_sint32

    def _mod_playerid_2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_sint32

    def _del_playerid_2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "playerid_2"

    playerid_2 = property(_get_playerid_2, _set_playerid_2, _del_playerid_2)

    @property
    def playerid_2__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def playerid_2__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_2(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_playerid_2)


    def _get_playerid_3(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            try:
                r = self._buf_get(5, ProtoBase.TYPE_sint32, 'playerid_3')
            except:
                r = -1
            self._cache[5] = r
        return r

    def _establish_parentage_playerid_3(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_3), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_3
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_3

    def _set_playerid_3(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_3(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_3"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_sint32

    def _mod_playerid_3(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_sint32

    def _del_playerid_3(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "playerid_3"

    playerid_3 = property(_get_playerid_3, _set_playerid_3, _del_playerid_3)

    @property
    def playerid_3__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def playerid_3__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_3(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_playerid_3)


    def _get_playerid_4(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            try:
                r = self._buf_get(6, ProtoBase.TYPE_sint32, 'playerid_4')
            except:
                r = -1
            self._cache[6] = r
        return r

    def _establish_parentage_playerid_4(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_4), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_4
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_4

    def _set_playerid_4(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_4(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_4"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_sint32

    def _mod_playerid_4(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_sint32

    def _del_playerid_4(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "playerid_4"

    playerid_4 = property(_get_playerid_4, _set_playerid_4, _del_playerid_4)

    @property
    def playerid_4__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def playerid_4__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_4(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_playerid_4)


    def _get_playerid_5(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            try:
                r = self._buf_get(7, ProtoBase.TYPE_sint32, 'playerid_5')
            except:
                r = -1
            self._cache[7] = r
        return r

    def _establish_parentage_playerid_5(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_5), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_5
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_5

    def _set_playerid_5(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_5(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_5"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_sint32

    def _mod_playerid_5(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_sint32

    def _del_playerid_5(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "playerid_5"

    playerid_5 = property(_get_playerid_5, _set_playerid_5, _del_playerid_5)

    @property
    def playerid_5__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def playerid_5__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_5(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_playerid_5)


    def _get_playerid_6(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            try:
                r = self._buf_get(8, ProtoBase.TYPE_sint32, 'playerid_6')
            except:
                r = -1
            self._cache[8] = r
        return r

    def _establish_parentage_playerid_6(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_playerid_6), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_playerid_6
                v._pbf_establish_parent_callback = self._establish_parentage_playerid_6

    def _set_playerid_6(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_playerid_6(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field playerid_6"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_sint32

    def _mod_playerid_6(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_sint32

    def _del_playerid_6(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "playerid_6"

    playerid_6 = property(_get_playerid_6, _set_playerid_6, _del_playerid_6)

    @property
    def playerid_6__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def playerid_6__type(self):
        return ProtoBase.TYPE_sint32

    def _finalize_playerid_6(cls):
        if is_string(ProtoBase.TYPE_sint32):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_playerid_6)


TYPE_CDOTAUserMsg_ChatEvent = CDOTAUserMsg_ChatEvent
_PB_finalizers.append('CDOTAUserMsg_ChatEvent')

class CDOTAUserMsg_CombatLogData(ProtoBase):
    _required = []
    _field_map = {'attacker_illusion': 4, 'inflictor_name': 6, 'target_name': 2, 'value': 7, 'attacker_name': 3, 'target_illusion': 5, 'health': 8, 'time': 9, 'type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['type', 'target_name', 'attacker_name', 'attacker_illusion', 'target_illusion', 'inflictor_name', 'value', 'health', 'time']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_DOTA_COMBATLOG_TYPES, 'type')
            except:
                r = DOTA_COMBATLOG_DAMAGE
            self._cache[1] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_DOTA_COMBATLOG_TYPES

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_DOTA_COMBATLOG_TYPES

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def type__type(self):
        return TYPE_DOTA_COMBATLOG_TYPES

    def _finalize_type(cls):
        if is_string(TYPE_DOTA_COMBATLOG_TYPES):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_DOTA_COMBATLOG_TYPES) is _PB_type:
            assert issubclass(TYPE_DOTA_COMBATLOG_TYPES, RepeatedSequence)
            if is_string(TYPE_DOTA_COMBATLOG_TYPES.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_type)


    def _get_target_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'target_name')
            self._cache[2] = r
        return r

    def _establish_parentage_target_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target_name
                v._pbf_establish_parent_callback = self._establish_parentage_target_name

    def _set_target_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target_name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_target_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_target_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "target_name"

    target_name = property(_get_target_name, _set_target_name, _del_target_name)

    @property
    def target_name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def target_name__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_target_name(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_target_name)


    def _get_attacker_name(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'attacker_name')
            self._cache[3] = r
        return r

    def _establish_parentage_attacker_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_attacker_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_attacker_name
                v._pbf_establish_parent_callback = self._establish_parentage_attacker_name

    def _set_attacker_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_attacker_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field attacker_name"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_attacker_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_attacker_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "attacker_name"

    attacker_name = property(_get_attacker_name, _set_attacker_name, _del_attacker_name)

    @property
    def attacker_name__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def attacker_name__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_attacker_name(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_attacker_name)


    def _get_attacker_illusion(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'attacker_illusion')
            self._cache[4] = r
        return r

    def _establish_parentage_attacker_illusion(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_attacker_illusion), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_attacker_illusion
                v._pbf_establish_parent_callback = self._establish_parentage_attacker_illusion

    def _set_attacker_illusion(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_attacker_illusion(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field attacker_illusion"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_attacker_illusion(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_attacker_illusion(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "attacker_illusion"

    attacker_illusion = property(_get_attacker_illusion, _set_attacker_illusion, _del_attacker_illusion)

    @property
    def attacker_illusion__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def attacker_illusion__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_attacker_illusion(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_attacker_illusion)


    def _get_target_illusion(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bool, 'target_illusion')
            self._cache[5] = r
        return r

    def _establish_parentage_target_illusion(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target_illusion), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target_illusion
                v._pbf_establish_parent_callback = self._establish_parentage_target_illusion

    def _set_target_illusion(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target_illusion(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target_illusion"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bool

    def _mod_target_illusion(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bool

    def _del_target_illusion(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "target_illusion"

    target_illusion = property(_get_target_illusion, _set_target_illusion, _del_target_illusion)

    @property
    def target_illusion__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def target_illusion__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_target_illusion(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_target_illusion)


    def _get_inflictor_name(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_uint32, 'inflictor_name')
            self._cache[6] = r
        return r

    def _establish_parentage_inflictor_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_inflictor_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_inflictor_name
                v._pbf_establish_parent_callback = self._establish_parentage_inflictor_name

    def _set_inflictor_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_inflictor_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field inflictor_name"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_uint32

    def _mod_inflictor_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_uint32

    def _del_inflictor_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "inflictor_name"

    inflictor_name = property(_get_inflictor_name, _set_inflictor_name, _del_inflictor_name)

    @property
    def inflictor_name__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def inflictor_name__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_inflictor_name(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_inflictor_name)


    def _get_value(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_int32, 'value')
            self._cache[7] = r
        return r

    def _establish_parentage_value(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_value
                v._pbf_establish_parent_callback = self._establish_parentage_value

    def _set_value(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_value(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field value"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_int32

    def _mod_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_int32

    def _del_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "value"

    value = property(_get_value, _set_value, _del_value)

    @property
    def value__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def value__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_value(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_value)


    def _get_health(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_int32, 'health')
            self._cache[8] = r
        return r

    def _establish_parentage_health(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_health), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_health
                v._pbf_establish_parent_callback = self._establish_parentage_health

    def _set_health(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_health(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field health"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_int32

    def _mod_health(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_int32

    def _del_health(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "health"

    health = property(_get_health, _set_health, _del_health)

    @property
    def health__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def health__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_health(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_health)


    def _get_time(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, ProtoBase.TYPE_float, 'time')
            self._cache[9] = r
        return r

    def _establish_parentage_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_time
                v._pbf_establish_parent_callback = self._establish_parentage_time

    def _set_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field time"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = ProtoBase.TYPE_float

    def _mod_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = ProtoBase.TYPE_float

    def _del_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "time"

    time = property(_get_time, _set_time, _del_time)

    @property
    def time__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(9)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_time)


TYPE_CDOTAUserMsg_CombatLogData = CDOTAUserMsg_CombatLogData
_PB_finalizers.append('CDOTAUserMsg_CombatLogData')

class CDOTAUserMsg_CombatLogShowDeath(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDOTAUserMsg_CombatLogShowDeath = CDOTAUserMsg_CombatLogShowDeath
_PB_finalizers.append('CDOTAUserMsg_CombatLogShowDeath')

class CDOTAUserMsg_BotChat(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'message': 3, 'target': 4, 'format': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'format', 'message', 'target']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_format(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'format')
            self._cache[2] = r
        return r

    def _establish_parentage_format(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_format), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_format
                v._pbf_establish_parent_callback = self._establish_parentage_format

    def _set_format(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_format(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field format"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "format"

    format = property(_get_format, _set_format, _del_format)

    @property
    def format__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def format__type(self):
        return ProtoBase.TYPE_string

    def _finalize_format(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_format)


    def _get_message(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'message')
            self._cache[3] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_message)


    def _get_target(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'target')
            self._cache[4] = r
        return r

    def _establish_parentage_target(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target
                v._pbf_establish_parent_callback = self._establish_parentage_target

    def _set_target(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_target(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_target(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "target"

    target = property(_get_target, _set_target, _del_target)

    @property
    def target__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def target__type(self):
        return ProtoBase.TYPE_string

    def _finalize_target(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_target)


TYPE_CDOTAUserMsg_BotChat = CDOTAUserMsg_BotChat
_PB_finalizers.append('CDOTAUserMsg_BotChat')

class CDOTAUserMsg_CombatHeroPositions(ProtoBase):
    _required = []
    _field_map = {'index': 1, 'health': 4, 'world_pos': 3, 'time': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['index', 'time', 'world_pos', 'health']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'index')
            self._cache[1] = r
        return r

    def _establish_parentage_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_index
                v._pbf_establish_parent_callback = self._establish_parentage_index

    def _set_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "index"

    index = property(_get_index, _set_index, _del_index)

    @property
    def index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def index__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_index(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_index)


    def _get_time(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'time')
            self._cache[2] = r
        return r

    def _establish_parentage_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_time
                v._pbf_establish_parent_callback = self._establish_parentage_time

    def _set_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field time"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "time"

    time = property(_get_time, _set_time, _del_time)

    @property
    def time__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def time__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_time(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_time)


    def _get_world_pos(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, TYPE_CMsgVector2D, 'world_pos')
            self._cache[3] = r
        return r

    def _establish_parentage_world_pos(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_world_pos), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_world_pos
                v._pbf_establish_parent_callback = self._establish_parentage_world_pos

    def _set_world_pos(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_world_pos(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field world_pos"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_CMsgVector2D

    def _mod_world_pos(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_CMsgVector2D

    def _del_world_pos(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "world_pos"

    world_pos = property(_get_world_pos, _set_world_pos, _del_world_pos)

    @property
    def world_pos__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def world_pos__type(self):
        return TYPE_CMsgVector2D

    def _finalize_world_pos(cls):
        if is_string(TYPE_CMsgVector2D):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_CMsgVector2D) is _PB_type:
            assert issubclass(TYPE_CMsgVector2D, RepeatedSequence)
            if is_string(TYPE_CMsgVector2D.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_world_pos)


    def _get_health(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'health')
            self._cache[4] = r
        return r

    def _establish_parentage_health(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_health), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_health
                v._pbf_establish_parent_callback = self._establish_parentage_health

    def _set_health(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_health(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field health"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_health(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_health(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "health"

    health = property(_get_health, _set_health, _del_health)

    @property
    def health__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def health__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_health(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_health)


TYPE_CDOTAUserMsg_CombatHeroPositions = CDOTAUserMsg_CombatHeroPositions
_PB_finalizers.append('CDOTAUserMsg_CombatHeroPositions')

class CDOTAUserMsg_MiniKillCamInfo(ProtoBase):
    _required = []
    _field_map = {'attackers': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['attackers']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class Attacker(ProtoBase):
        _required = []
        _field_map = {'attacker': 1, 'abilities': 3, 'total_damage': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['attacker', 'total_damage', 'abilities']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
            
        class Ability(ProtoBase):
            _required = []
            _field_map = {'ability': 1, 'damage': 2}
            
            def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
                self._pbf_parent_callback = _pbf_parent_callback
                self._cache = {}
                self._pbf_establish_parent_callback = None
                ProtoBase.__init__(self, _pbf_buf, **kw)
        
            @classmethod
            def _pbf_finalize(cls):
                for c in cls._pbf_finalizers:
                    c(cls)
                del cls._pbf_finalizers
        
            @classmethod
            def fields(cls):
                return ['ability', 'damage']
        
            def modified(self):
                return self._evermod
        
            def __contains__(self, item):
                try:
                    return getattr(self, '%s__exists' % item)
                except AttributeError:
                    return False
        
            _pbf_strings = []
            _pbf_finalizers = []
        
            def __str__(self):
                return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                                  if getattr(self, '%s__exists' % f))
                
            def _get_ability(self):
                if 1 in self._cache:
                    r = self._cache[1]
                else:
                    r = self._buf_get(1, ProtoBase.TYPE_uint32, 'ability')
                    self._cache[1] = r
                return r
        
            def _establish_parentage_ability(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_ability), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_ability
                        v._pbf_establish_parent_callback = self._establish_parentage_ability
        
            def _set_ability(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_ability(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field ability"
                    raise ProtoValueError(list_assign_error)
                self._cache[1] = v
                self._mods[1] = ProtoBase.TYPE_uint32
        
            def _mod_ability(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[1] = ProtoBase.TYPE_uint32
        
            def _del_ability(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 1 in self._cache:
                    del self._cache[1]
                if 1 in self._mods:
                    del self._mods[1]
                self._buf_del(1)
        
            _pb_field_name_1 = "ability"
        
            ability = property(_get_ability, _set_ability, _del_ability)
        
            @property
            def ability__exists(self):
                return 1 in self._mods or self._buf_exists(1)
        
            @property
            def ability__type(self):
                return ProtoBase.TYPE_uint32
        
            def _finalize_ability(cls):
                if is_string(ProtoBase.TYPE_uint32):
                    cls._pbf_strings.append(1)
                elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                        cls._pbf_strings.append(1)
        
            _pbf_finalizers.append(_finalize_ability)
        
                
            def _get_damage(self):
                if 2 in self._cache:
                    r = self._cache[2]
                else:
                    r = self._buf_get(2, ProtoBase.TYPE_int32, 'damage')
                    self._cache[2] = r
                return r
        
            def _establish_parentage_damage(self, v):
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    if v._pbf_parent_callback:
                        assert (v._pbf_parent_callback == self._mod_damage), "subobjects can only have one parent--use copy()?"
                    else:
                        v._pbf_parent_callback = self._mod_damage
                        v._pbf_establish_parent_callback = self._establish_parentage_damage
        
            def _set_damage(self, v, modifying=True):
                self._evermod = modifying or self._evermod
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if isinstance(v, (ProtoBase, RepeatedSequence)):
                    self._establish_parentage_damage(v)
                elif isinstance(v, list):
                    list_assign_error = "Can't assign list to repeated field damage"
                    raise ProtoValueError(list_assign_error)
                self._cache[2] = v
                self._mods[2] = ProtoBase.TYPE_int32
        
            def _mod_damage(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                self._mods[2] = ProtoBase.TYPE_int32
        
            def _del_damage(self):
                self._evermod = True
                if self._pbf_parent_callback:
                    self._pbf_parent_callback()
                if 2 in self._cache:
                    del self._cache[2]
                if 2 in self._mods:
                    del self._mods[2]
                self._buf_del(2)
        
            _pb_field_name_2 = "damage"
        
            damage = property(_get_damage, _set_damage, _del_damage)
        
            @property
            def damage__exists(self):
                return 2 in self._mods or self._buf_exists(2)
        
            @property
            def damage__type(self):
                return ProtoBase.TYPE_int32
        
            def _finalize_damage(cls):
                if is_string(ProtoBase.TYPE_int32):
                    cls._pbf_strings.append(2)
                elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                    assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                    if is_string(ProtoBase.TYPE_int32.pb_subtype):
                        cls._pbf_strings.append(2)
        
            _pbf_finalizers.append(_finalize_damage)
        
                
        TYPE_Ability = Ability
        _PB_finalizers.append('CDOTAUserMsg_MiniKillCamInfo.Attacker.Ability')
            
        TYPE_Ability = Ability
        
        def _get_attacker(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_uint32, 'attacker')
                self._cache[1] = r
            return r
    
        def _establish_parentage_attacker(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_attacker), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_attacker
                    v._pbf_establish_parent_callback = self._establish_parentage_attacker
    
        def _set_attacker(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_attacker(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field attacker"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_uint32
    
        def _mod_attacker(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_uint32
    
        def _del_attacker(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "attacker"
    
        attacker = property(_get_attacker, _set_attacker, _del_attacker)
    
        @property
        def attacker__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def attacker__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_attacker(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_attacker)
    
        
        def _get_total_damage(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'total_damage')
                self._cache[2] = r
            return r
    
        def _establish_parentage_total_damage(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_total_damage), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_total_damage
                    v._pbf_establish_parent_callback = self._establish_parentage_total_damage
    
        def _set_total_damage(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_total_damage(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field total_damage"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_total_damage(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_total_damage(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "total_damage"
    
        total_damage = property(_get_total_damage, _set_total_damage, _del_total_damage)
    
        @property
        def total_damage__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def total_damage__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_total_damage(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_total_damage)
    
        
        class Repeated_abilities(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CDOTAUserMsg_MiniKillCamInfo.Attacker.TYPE_Ability
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_abilities = Repeated_abilities
    
        
        @property
        def abilities__stream(self):
            if 3 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[3]]
            return self._get_repeated(3, self.TYPE_Repeated_abilities, "abilities", lazy=True)
    
        def abilities__fast_append(self, value):
            self._append_to_repeated(3, self.TYPE_Repeated_abilities, value)
        
        def _get_abilities(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, self.TYPE_Repeated_abilities, 'abilities')
                self._cache[3] = r
            return r
    
        def _establish_parentage_abilities(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_abilities), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_abilities
                    v._pbf_establish_parent_callback = self._establish_parentage_abilities
    
        def _set_abilities(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_abilities(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field abilities"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = self.TYPE_Repeated_abilities
    
        def _mod_abilities(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = self.TYPE_Repeated_abilities
    
        def _del_abilities(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "abilities"
    
        abilities = property(_get_abilities, _set_abilities, _del_abilities)
    
        @property
        def abilities__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def abilities__type(self):
            return self.TYPE_Repeated_abilities
    
        def _finalize_abilities(cls):
            if is_string(cls.TYPE_Repeated_abilities):
                cls._pbf_strings.append(3)
            elif _PB_type(cls.TYPE_Repeated_abilities) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_abilities, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_abilities.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_abilities)
    
        
    TYPE_Attacker = Attacker
    _PB_finalizers.append('CDOTAUserMsg_MiniKillCamInfo.Attacker')
    
    TYPE_Attacker = Attacker

    class Repeated_attackers(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CDOTAUserMsg_MiniKillCamInfo.TYPE_Attacker
        pb_subtype = pb_subtype()


    TYPE_Repeated_attackers = Repeated_attackers


    @property
    def attackers__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_attackers, "attackers", lazy=True)

    def attackers__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_attackers, value)

    def _get_attackers(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_attackers, 'attackers')
            self._cache[1] = r
        return r

    def _establish_parentage_attackers(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_attackers), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_attackers
                v._pbf_establish_parent_callback = self._establish_parentage_attackers

    def _set_attackers(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_attackers(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field attackers"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_attackers

    def _mod_attackers(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_attackers

    def _del_attackers(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "attackers"

    attackers = property(_get_attackers, _set_attackers, _del_attackers)

    @property
    def attackers__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def attackers__type(self):
        return self.TYPE_Repeated_attackers

    def _finalize_attackers(cls):
        if is_string(cls.TYPE_Repeated_attackers):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_attackers) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_attackers, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_attackers.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_attackers)


TYPE_CDOTAUserMsg_MiniKillCamInfo = CDOTAUserMsg_MiniKillCamInfo
_PB_finalizers.append('CDOTAUserMsg_MiniKillCamInfo')

class CDOTAUserMsg_GlobalLightColor(ProtoBase):
    _required = []
    _field_map = {'color': 1, 'duration': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['color', 'duration']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_color(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'color')
            self._cache[1] = r
        return r

    def _establish_parentage_color(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color
                v._pbf_establish_parent_callback = self._establish_parentage_color

    def _set_color(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "color"

    color = property(_get_color, _set_color, _del_color)

    @property
    def color__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def color__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_color(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_color)


    def _get_duration(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'duration')
            self._cache[2] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_duration)


TYPE_CDOTAUserMsg_GlobalLightColor = CDOTAUserMsg_GlobalLightColor
_PB_finalizers.append('CDOTAUserMsg_GlobalLightColor')

class CDOTAUserMsg_GlobalLightDirection(ProtoBase):
    _required = []
    _field_map = {'duration': 2, 'direction': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['direction', 'duration']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_direction(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsgVector, 'direction')
            self._cache[1] = r
        return r

    def _establish_parentage_direction(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_direction), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_direction
                v._pbf_establish_parent_callback = self._establish_parentage_direction

    def _set_direction(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_direction(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field direction"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsgVector

    def _mod_direction(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsgVector

    def _del_direction(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "direction"

    direction = property(_get_direction, _set_direction, _del_direction)

    @property
    def direction__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def direction__type(self):
        return TYPE_CMsgVector

    def _finalize_direction(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_direction)


    def _get_duration(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'duration')
            self._cache[2] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_duration)


TYPE_CDOTAUserMsg_GlobalLightDirection = CDOTAUserMsg_GlobalLightDirection
_PB_finalizers.append('CDOTAUserMsg_GlobalLightDirection')

class CDOTAUserMsg_LocationPing(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'location_ping': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'location_ping']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_location_ping(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_LocationPing, 'location_ping')
            self._cache[2] = r
        return r

    def _establish_parentage_location_ping(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_location_ping), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_location_ping
                v._pbf_establish_parent_callback = self._establish_parentage_location_ping

    def _set_location_ping(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_location_ping(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field location_ping"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_LocationPing

    def _mod_location_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_LocationPing

    def _del_location_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "location_ping"

    location_ping = property(_get_location_ping, _set_location_ping, _del_location_ping)

    @property
    def location_ping__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def location_ping__type(self):
        return TYPE_CDOTAMsg_LocationPing

    def _finalize_location_ping(cls):
        if is_string(TYPE_CDOTAMsg_LocationPing):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_LocationPing) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_LocationPing, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_LocationPing.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_location_ping)


TYPE_CDOTAUserMsg_LocationPing = CDOTAUserMsg_LocationPing
_PB_finalizers.append('CDOTAUserMsg_LocationPing')

class CDOTAUserMsg_ItemAlert(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'item_alert': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'item_alert']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_item_alert(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_ItemAlert, 'item_alert')
            self._cache[2] = r
        return r

    def _establish_parentage_item_alert(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_item_alert), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_item_alert
                v._pbf_establish_parent_callback = self._establish_parentage_item_alert

    def _set_item_alert(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_item_alert(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field item_alert"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_ItemAlert

    def _mod_item_alert(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_ItemAlert

    def _del_item_alert(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "item_alert"

    item_alert = property(_get_item_alert, _set_item_alert, _del_item_alert)

    @property
    def item_alert__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def item_alert__type(self):
        return TYPE_CDOTAMsg_ItemAlert

    def _finalize_item_alert(cls):
        if is_string(TYPE_CDOTAMsg_ItemAlert):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_ItemAlert) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_ItemAlert, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_ItemAlert.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_item_alert)


TYPE_CDOTAUserMsg_ItemAlert = CDOTAUserMsg_ItemAlert
_PB_finalizers.append('CDOTAUserMsg_ItemAlert')

class CDOTAUserMsg_WillPurchaseAlert(ProtoBase):
    _required = []
    _field_map = {'itemid': 1, 'player_id': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['itemid', 'player_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_itemid(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'itemid')
            self._cache[1] = r
        return r

    def _establish_parentage_itemid(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_itemid), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_itemid
                v._pbf_establish_parent_callback = self._establish_parentage_itemid

    def _set_itemid(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_itemid(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field itemid"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_itemid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_itemid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "itemid"

    itemid = property(_get_itemid, _set_itemid, _del_itemid)

    @property
    def itemid__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def itemid__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_itemid(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_itemid)


    def _get_player_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'player_id')
            self._cache[2] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_player_id)


TYPE_CDOTAUserMsg_WillPurchaseAlert = CDOTAUserMsg_WillPurchaseAlert
_PB_finalizers.append('CDOTAUserMsg_WillPurchaseAlert')

class CDOTAUserMsg_MinimapEvent(ProtoBase):
    _required = []
    _field_map = {'y': 4, 'x': 3, 'duration': 5, 'entity_handle': 2, 'event_type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['event_type', 'entity_handle', 'x', 'y', 'duration']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_event_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'event_type')
            self._cache[1] = r
        return r

    def _establish_parentage_event_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_type
                v._pbf_establish_parent_callback = self._establish_parentage_event_type

    def _set_event_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_event_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_event_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "event_type"

    event_type = property(_get_event_type, _set_event_type, _del_event_type)

    @property
    def event_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def event_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_event_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_event_type)


    def _get_entity_handle(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'entity_handle')
            self._cache[2] = r
        return r

    def _establish_parentage_entity_handle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_handle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_handle
                v._pbf_establish_parent_callback = self._establish_parentage_entity_handle

    def _set_entity_handle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_handle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_handle"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_entity_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_entity_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "entity_handle"

    entity_handle = property(_get_entity_handle, _set_entity_handle, _del_entity_handle)

    @property
    def entity_handle__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def entity_handle__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_handle(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_entity_handle)


    def _get_x(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'x')
            self._cache[3] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def x__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'y')
            self._cache[4] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def y__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_y)


    def _get_duration(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'duration')
            self._cache[5] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_duration)


TYPE_CDOTAUserMsg_MinimapEvent = CDOTAUserMsg_MinimapEvent
_PB_finalizers.append('CDOTAUserMsg_MinimapEvent')

class CDOTAUserMsg_MapLine(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'mapline': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'mapline']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_mapline(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_MapLine, 'mapline')
            self._cache[2] = r
        return r

    def _establish_parentage_mapline(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_mapline), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_mapline
                v._pbf_establish_parent_callback = self._establish_parentage_mapline

    def _set_mapline(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_mapline(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field mapline"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_MapLine

    def _mod_mapline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_MapLine

    def _del_mapline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "mapline"

    mapline = property(_get_mapline, _set_mapline, _del_mapline)

    @property
    def mapline__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def mapline__type(self):
        return TYPE_CDOTAMsg_MapLine

    def _finalize_mapline(cls):
        if is_string(TYPE_CDOTAMsg_MapLine):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_MapLine) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_MapLine, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_MapLine.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_mapline)


TYPE_CDOTAUserMsg_MapLine = CDOTAUserMsg_MapLine
_PB_finalizers.append('CDOTAUserMsg_MapLine')

class CDOTAUserMsg_MinimapDebugPoint(ProtoBase):
    _required = []
    _field_map = {'color': 2, 'duration': 4, 'location': 1, 'size': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['location', 'color', 'size', 'duration']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_location(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsgVector, 'location')
            self._cache[1] = r
        return r

    def _establish_parentage_location(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_location), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_location
                v._pbf_establish_parent_callback = self._establish_parentage_location

    def _set_location(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_location(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field location"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsgVector

    def _mod_location(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsgVector

    def _del_location(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "location"

    location = property(_get_location, _set_location, _del_location)

    @property
    def location__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def location__type(self):
        return TYPE_CMsgVector

    def _finalize_location(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_location)


    def _get_color(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'color')
            self._cache[2] = r
        return r

    def _establish_parentage_color(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color
                v._pbf_establish_parent_callback = self._establish_parentage_color

    def _set_color(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "color"

    color = property(_get_color, _set_color, _del_color)

    @property
    def color__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def color__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_color(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_color)


    def _get_size(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'size')
            self._cache[3] = r
        return r

    def _establish_parentage_size(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_size), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_size
                v._pbf_establish_parent_callback = self._establish_parentage_size

    def _set_size(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_size(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field size"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "size"

    size = property(_get_size, _set_size, _del_size)

    @property
    def size__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def size__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_size(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_size)


    def _get_duration(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_float, 'duration')
            self._cache[4] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_duration)


TYPE_CDOTAUserMsg_MinimapDebugPoint = CDOTAUserMsg_MinimapDebugPoint
_PB_finalizers.append('CDOTAUserMsg_MinimapDebugPoint')

class CDOTAUserMsg_CreateLinearProjectile(ProtoBase):
    _required = []
    _field_map = {'origin': 1, 'latency': 3, 'acceleration': 7, 'handle': 6, 'entindex': 4, 'max_speed': 8, 'particle_index': 5, 'velocity': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['origin', 'velocity', 'latency', 'entindex', 'particle_index', 'handle', 'acceleration', 'max_speed']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_origin(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsgVector, 'origin')
            self._cache[1] = r
        return r

    def _establish_parentage_origin(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_origin), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_origin
                v._pbf_establish_parent_callback = self._establish_parentage_origin

    def _set_origin(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_origin(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field origin"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsgVector

    def _mod_origin(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsgVector

    def _del_origin(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "origin"

    origin = property(_get_origin, _set_origin, _del_origin)

    @property
    def origin__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def origin__type(self):
        return TYPE_CMsgVector

    def _finalize_origin(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_origin)


    def _get_velocity(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CMsgVector2D, 'velocity')
            self._cache[2] = r
        return r

    def _establish_parentage_velocity(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_velocity), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_velocity
                v._pbf_establish_parent_callback = self._establish_parentage_velocity

    def _set_velocity(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_velocity(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field velocity"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CMsgVector2D

    def _mod_velocity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CMsgVector2D

    def _del_velocity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "velocity"

    velocity = property(_get_velocity, _set_velocity, _del_velocity)

    @property
    def velocity__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def velocity__type(self):
        return TYPE_CMsgVector2D

    def _finalize_velocity(cls):
        if is_string(TYPE_CMsgVector2D):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CMsgVector2D) is _PB_type:
            assert issubclass(TYPE_CMsgVector2D, RepeatedSequence)
            if is_string(TYPE_CMsgVector2D.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_velocity)


    def _get_latency(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'latency')
            self._cache[3] = r
        return r

    def _establish_parentage_latency(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_latency), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_latency
                v._pbf_establish_parent_callback = self._establish_parentage_latency

    def _set_latency(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_latency(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field latency"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_latency(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_latency(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "latency"

    latency = property(_get_latency, _set_latency, _del_latency)

    @property
    def latency__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def latency__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_latency(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_latency)


    def _get_entindex(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'entindex')
            self._cache[4] = r
        return r

    def _establish_parentage_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_entindex

    def _set_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "entindex"

    entindex = property(_get_entindex, _set_entindex, _del_entindex)

    @property
    def entindex__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_entindex)


    def _get_particle_index(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'particle_index')
            self._cache[5] = r
        return r

    def _establish_parentage_particle_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_particle_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_particle_index
                v._pbf_establish_parent_callback = self._establish_parentage_particle_index

    def _set_particle_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_particle_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field particle_index"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_particle_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_particle_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "particle_index"

    particle_index = property(_get_particle_index, _set_particle_index, _del_particle_index)

    @property
    def particle_index__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def particle_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_particle_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_particle_index)


    def _get_handle(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_int32, 'handle')
            self._cache[6] = r
        return r

    def _establish_parentage_handle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_handle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_handle
                v._pbf_establish_parent_callback = self._establish_parentage_handle

    def _set_handle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_handle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field handle"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_int32

    def _mod_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_int32

    def _del_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "handle"

    handle = property(_get_handle, _set_handle, _del_handle)

    @property
    def handle__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def handle__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_handle(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_handle)


    def _get_acceleration(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, TYPE_CMsgVector2D, 'acceleration')
            self._cache[7] = r
        return r

    def _establish_parentage_acceleration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_acceleration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_acceleration
                v._pbf_establish_parent_callback = self._establish_parentage_acceleration

    def _set_acceleration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_acceleration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field acceleration"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = TYPE_CMsgVector2D

    def _mod_acceleration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = TYPE_CMsgVector2D

    def _del_acceleration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "acceleration"

    acceleration = property(_get_acceleration, _set_acceleration, _del_acceleration)

    @property
    def acceleration__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def acceleration__type(self):
        return TYPE_CMsgVector2D

    def _finalize_acceleration(cls):
        if is_string(TYPE_CMsgVector2D):
            cls._pbf_strings.append(7)
        elif _PB_type(TYPE_CMsgVector2D) is _PB_type:
            assert issubclass(TYPE_CMsgVector2D, RepeatedSequence)
            if is_string(TYPE_CMsgVector2D.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_acceleration)


    def _get_max_speed(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_float, 'max_speed')
            self._cache[8] = r
        return r

    def _establish_parentage_max_speed(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_max_speed), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_max_speed
                v._pbf_establish_parent_callback = self._establish_parentage_max_speed

    def _set_max_speed(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_max_speed(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field max_speed"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_float

    def _mod_max_speed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_float

    def _del_max_speed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "max_speed"

    max_speed = property(_get_max_speed, _set_max_speed, _del_max_speed)

    @property
    def max_speed__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def max_speed__type(self):
        return ProtoBase.TYPE_float

    def _finalize_max_speed(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_max_speed)


TYPE_CDOTAUserMsg_CreateLinearProjectile = CDOTAUserMsg_CreateLinearProjectile
_PB_finalizers.append('CDOTAUserMsg_CreateLinearProjectile')

class CDOTAUserMsg_DestroyLinearProjectile(ProtoBase):
    _required = []
    _field_map = {'handle': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['handle']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_handle(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'handle')
            self._cache[1] = r
        return r

    def _establish_parentage_handle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_handle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_handle
                v._pbf_establish_parent_callback = self._establish_parentage_handle

    def _set_handle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_handle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field handle"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "handle"

    handle = property(_get_handle, _set_handle, _del_handle)

    @property
    def handle__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def handle__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_handle(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_handle)


TYPE_CDOTAUserMsg_DestroyLinearProjectile = CDOTAUserMsg_DestroyLinearProjectile
_PB_finalizers.append('CDOTAUserMsg_DestroyLinearProjectile')

class CDOTAUserMsg_DodgeTrackingProjectiles(ProtoBase):
    _required = [1]
    _field_map = {'entindex': 1, 'attacks_only': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entindex', 'attacks_only']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entindex(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'entindex')
            self._cache[1] = r
        return r

    def _establish_parentage_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_entindex

    def _set_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entindex"

    entindex = property(_get_entindex, _set_entindex, _del_entindex)

    @property
    def entindex__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entindex)


    def _get_attacks_only(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'attacks_only')
            self._cache[2] = r
        return r

    def _establish_parentage_attacks_only(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_attacks_only), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_attacks_only
                v._pbf_establish_parent_callback = self._establish_parentage_attacks_only

    def _set_attacks_only(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_attacks_only(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field attacks_only"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_attacks_only(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_attacks_only(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "attacks_only"

    attacks_only = property(_get_attacks_only, _set_attacks_only, _del_attacks_only)

    @property
    def attacks_only__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def attacks_only__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_attacks_only(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_attacks_only)


TYPE_CDOTAUserMsg_DodgeTrackingProjectiles = CDOTAUserMsg_DodgeTrackingProjectiles
_PB_finalizers.append('CDOTAUserMsg_DodgeTrackingProjectiles')

class CDOTAUserMsg_SpectatorPlayerClick(ProtoBase):
    _required = [1]
    _field_map = {'entindex': 1, 'order_type': 2, 'target_index': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entindex', 'order_type', 'target_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entindex(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'entindex')
            self._cache[1] = r
        return r

    def _establish_parentage_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_entindex

    def _set_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entindex"

    entindex = property(_get_entindex, _set_entindex, _del_entindex)

    @property
    def entindex__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entindex)


    def _get_order_type(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'order_type')
            self._cache[2] = r
        return r

    def _establish_parentage_order_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_order_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_order_type
                v._pbf_establish_parent_callback = self._establish_parentage_order_type

    def _set_order_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_order_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field order_type"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_order_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_order_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "order_type"

    order_type = property(_get_order_type, _set_order_type, _del_order_type)

    @property
    def order_type__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def order_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_order_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_order_type)


    def _get_target_index(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'target_index')
            self._cache[3] = r
        return r

    def _establish_parentage_target_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target_index
                v._pbf_establish_parent_callback = self._establish_parentage_target_index

    def _set_target_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target_index"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_target_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_target_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "target_index"

    target_index = property(_get_target_index, _set_target_index, _del_target_index)

    @property
    def target_index__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def target_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_target_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_target_index)


TYPE_CDOTAUserMsg_SpectatorPlayerClick = CDOTAUserMsg_SpectatorPlayerClick
_PB_finalizers.append('CDOTAUserMsg_SpectatorPlayerClick')

class CDOTAUserMsg_NevermoreRequiem(ProtoBase):
    _required = []
    _field_map = {'origin': 3, 'entity_handle': 1, 'lines': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entity_handle', 'lines', 'origin']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entity_handle(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'entity_handle')
            self._cache[1] = r
        return r

    def _establish_parentage_entity_handle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_handle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_handle
                v._pbf_establish_parent_callback = self._establish_parentage_entity_handle

    def _set_entity_handle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_handle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_handle"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_entity_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_entity_handle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entity_handle"

    entity_handle = property(_get_entity_handle, _set_entity_handle, _del_entity_handle)

    @property
    def entity_handle__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entity_handle__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_handle(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entity_handle)


    def _get_lines(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'lines')
            self._cache[2] = r
        return r

    def _establish_parentage_lines(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_lines), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_lines
                v._pbf_establish_parent_callback = self._establish_parentage_lines

    def _set_lines(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_lines(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field lines"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_lines(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_lines(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "lines"

    lines = property(_get_lines, _set_lines, _del_lines)

    @property
    def lines__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def lines__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_lines(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_lines)


    def _get_origin(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, TYPE_CMsgVector, 'origin')
            self._cache[3] = r
        return r

    def _establish_parentage_origin(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_origin), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_origin
                v._pbf_establish_parent_callback = self._establish_parentage_origin

    def _set_origin(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_origin(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field origin"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_CMsgVector

    def _mod_origin(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_CMsgVector

    def _del_origin(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "origin"

    origin = property(_get_origin, _set_origin, _del_origin)

    @property
    def origin__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def origin__type(self):
        return TYPE_CMsgVector

    def _finalize_origin(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_origin)


TYPE_CDOTAUserMsg_NevermoreRequiem = CDOTAUserMsg_NevermoreRequiem
_PB_finalizers.append('CDOTAUserMsg_NevermoreRequiem')

class CDOTAUserMsg_InvalidCommand(ProtoBase):
    _required = []
    _field_map = {'message': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


TYPE_CDOTAUserMsg_InvalidCommand = CDOTAUserMsg_InvalidCommand
_PB_finalizers.append('CDOTAUserMsg_InvalidCommand')

class CDOTAUserMsg_HudError(ProtoBase):
    _required = []
    _field_map = {'order_id': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['order_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_order_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'order_id')
            self._cache[1] = r
        return r

    def _establish_parentage_order_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_order_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_order_id
                v._pbf_establish_parent_callback = self._establish_parentage_order_id

    def _set_order_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_order_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field order_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_order_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_order_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "order_id"

    order_id = property(_get_order_id, _set_order_id, _del_order_id)

    @property
    def order_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def order_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_order_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_order_id)


TYPE_CDOTAUserMsg_HudError = CDOTAUserMsg_HudError
_PB_finalizers.append('CDOTAUserMsg_HudError')

class CDOTAUserMsg_SharedCooldown(ProtoBase):
    _required = []
    _field_map = {'entindex': 1, 'name_index': 4, 'cooldown': 3, 'name': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entindex', 'name', 'cooldown', 'name_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entindex(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'entindex')
            self._cache[1] = r
        return r

    def _establish_parentage_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_entindex

    def _set_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entindex"

    entindex = property(_get_entindex, _set_entindex, _del_entindex)

    @property
    def entindex__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entindex)


    def _get_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'name')
            self._cache[2] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_name)


    def _get_cooldown(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'cooldown')
            self._cache[3] = r
        return r

    def _establish_parentage_cooldown(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cooldown), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cooldown
                v._pbf_establish_parent_callback = self._establish_parentage_cooldown

    def _set_cooldown(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cooldown(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cooldown"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_cooldown(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_cooldown(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "cooldown"

    cooldown = property(_get_cooldown, _set_cooldown, _del_cooldown)

    @property
    def cooldown__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def cooldown__type(self):
        return ProtoBase.TYPE_float

    def _finalize_cooldown(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_cooldown)


    def _get_name_index(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'name_index')
            self._cache[4] = r
        return r

    def _establish_parentage_name_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name_index
                v._pbf_establish_parent_callback = self._establish_parentage_name_index

    def _set_name_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name_index"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_name_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_name_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "name_index"

    name_index = property(_get_name_index, _set_name_index, _del_name_index)

    @property
    def name_index__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def name_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_name_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_name_index)


TYPE_CDOTAUserMsg_SharedCooldown = CDOTAUserMsg_SharedCooldown
_PB_finalizers.append('CDOTAUserMsg_SharedCooldown')

class CDOTAUserMsg_SetNextAutobuyItem(ProtoBase):
    _required = []
    _field_map = {'name': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['name']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
            self._cache[1] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_name)


TYPE_CDOTAUserMsg_SetNextAutobuyItem = CDOTAUserMsg_SetNextAutobuyItem
_PB_finalizers.append('CDOTAUserMsg_SetNextAutobuyItem')

class CDOTAUserMsg_HalloweenDrops(ProtoBase):
    _required = []
    _field_map = {'prize_list': 3, 'player_ids': 2, 'item_defs': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['item_defs', 'player_ids', 'prize_list']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_item_defs(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_uint32
        pb_subtype = pb_subtype()


    TYPE_Repeated_item_defs = Repeated_item_defs


    def _get_item_defs(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_item_defs, 'item_defs')
            self._cache[1] = r
        return r

    def _establish_parentage_item_defs(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_item_defs), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_item_defs
                v._pbf_establish_parent_callback = self._establish_parentage_item_defs

    def _set_item_defs(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_item_defs(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field item_defs"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_item_defs

    def _mod_item_defs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_item_defs

    def _del_item_defs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "item_defs"

    item_defs = property(_get_item_defs, _set_item_defs, _del_item_defs)

    @property
    def item_defs__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def item_defs__type(self):
        return self.TYPE_Repeated_item_defs

    def _finalize_item_defs(cls):
        if is_string(cls.TYPE_Repeated_item_defs):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_item_defs) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_item_defs, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_item_defs.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_item_defs)


    class Repeated_player_ids(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_uint32
        pb_subtype = pb_subtype()


    TYPE_Repeated_player_ids = Repeated_player_ids


    def _get_player_ids(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_player_ids, 'player_ids')
            self._cache[2] = r
        return r

    def _establish_parentage_player_ids(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_ids), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_ids
                v._pbf_establish_parent_callback = self._establish_parentage_player_ids

    def _set_player_ids(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_ids(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_ids"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_player_ids

    def _mod_player_ids(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_player_ids

    def _del_player_ids(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "player_ids"

    player_ids = property(_get_player_ids, _set_player_ids, _del_player_ids)

    @property
    def player_ids__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def player_ids__type(self):
        return self.TYPE_Repeated_player_ids

    def _finalize_player_ids(cls):
        if is_string(cls.TYPE_Repeated_player_ids):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_player_ids) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_player_ids, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_player_ids.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_player_ids)


    def _get_prize_list(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'prize_list')
            self._cache[3] = r
        return r

    def _establish_parentage_prize_list(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_prize_list), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_prize_list
                v._pbf_establish_parent_callback = self._establish_parentage_prize_list

    def _set_prize_list(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_prize_list(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field prize_list"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_prize_list(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_prize_list(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "prize_list"

    prize_list = property(_get_prize_list, _set_prize_list, _del_prize_list)

    @property
    def prize_list__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def prize_list__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_prize_list(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_prize_list)


TYPE_CDOTAUserMsg_HalloweenDrops = CDOTAUserMsg_HalloweenDrops
_PB_finalizers.append('CDOTAUserMsg_HalloweenDrops')

class CDOTAResponseQuerySerialized(ProtoBase):
    _required = []
    _field_map = {'facts': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['facts']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class Fact(ProtoBase):
        _required = [1, 2]
        _field_map = {'val_string': 4, 'valtype': 2, 'val_numeric': 3, 'key': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['key', 'valtype', 'val_numeric', 'val_string']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
            
        # Enumeration: ValueType
                
        NUMERIC = 1
                
        STRING = 2
                
        TYPE_ValueType = ProtoBase.TYPE_int32
                
        _ValueType__map = {2: 'STRING', 1: 'NUMERIC'}
                
        @classmethod
        def get_ValueType_name(cls, v):
            return cls._ValueType__map[v]
            
        def _get_key(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'key')
                self._cache[1] = r
            return r
    
        def _establish_parentage_key(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_key), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_key
                    v._pbf_establish_parent_callback = self._establish_parentage_key
    
        def _set_key(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_key(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field key"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_key(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_key(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "key"
    
        key = property(_get_key, _set_key, _del_key)
    
        @property
        def key__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def key__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_key(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_key)
    
        
        def _get_valtype(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                try:
                    r = self._buf_get(2, CDOTAResponseQuerySerialized.Fact.TYPE_ValueType, 'valtype')
                except:
                    r = CDOTAResponseQuerySerialized.Fact.NUMERIC
                self._cache[2] = r
            return r
    
        def _establish_parentage_valtype(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_valtype), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_valtype
                    v._pbf_establish_parent_callback = self._establish_parentage_valtype
    
        def _set_valtype(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_valtype(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field valtype"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = CDOTAResponseQuerySerialized.Fact.TYPE_ValueType
    
        def _mod_valtype(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = CDOTAResponseQuerySerialized.Fact.TYPE_ValueType
    
        def _del_valtype(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "valtype"
    
        valtype = property(_get_valtype, _set_valtype, _del_valtype)
    
        @property
        def valtype__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def valtype__type(self):
            return CDOTAResponseQuerySerialized.Fact.TYPE_ValueType
    
        def _finalize_valtype(cls):
            if is_string(CDOTAResponseQuerySerialized.Fact.TYPE_ValueType):
                cls._pbf_strings.append(2)
            elif _PB_type(CDOTAResponseQuerySerialized.Fact.TYPE_ValueType) is _PB_type:
                assert issubclass(CDOTAResponseQuerySerialized.Fact.TYPE_ValueType, RepeatedSequence)
                if is_string(CDOTAResponseQuerySerialized.Fact.TYPE_ValueType.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_valtype)
    
        
        def _get_val_numeric(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_float, 'val_numeric')
                self._cache[3] = r
            return r
    
        def _establish_parentage_val_numeric(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_numeric), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_numeric
                    v._pbf_establish_parent_callback = self._establish_parentage_val_numeric
    
        def _set_val_numeric(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_numeric(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_numeric"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_float
    
        def _mod_val_numeric(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_float
    
        def _del_val_numeric(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "val_numeric"
    
        val_numeric = property(_get_val_numeric, _set_val_numeric, _del_val_numeric)
    
        @property
        def val_numeric__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def val_numeric__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_val_numeric(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_val_numeric)
    
        
        def _get_val_string(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_string, 'val_string')
                self._cache[4] = r
            return r
    
        def _establish_parentage_val_string(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_string), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_string
                    v._pbf_establish_parent_callback = self._establish_parentage_val_string
    
        def _set_val_string(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_string(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_string"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_string
    
        def _mod_val_string(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_string
    
        def _del_val_string(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "val_string"
    
        val_string = property(_get_val_string, _set_val_string, _del_val_string)
    
        @property
        def val_string__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def val_string__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_val_string(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_val_string)
    
        
    TYPE_Fact = Fact
    _PB_finalizers.append('CDOTAResponseQuerySerialized.Fact')
    
    TYPE_Fact = Fact

    class Repeated_facts(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CDOTAResponseQuerySerialized.TYPE_Fact
        pb_subtype = pb_subtype()


    TYPE_Repeated_facts = Repeated_facts


    @property
    def facts__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_facts, "facts", lazy=True)

    def facts__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_facts, value)

    def _get_facts(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_facts, 'facts')
            self._cache[1] = r
        return r

    def _establish_parentage_facts(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_facts), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_facts
                v._pbf_establish_parent_callback = self._establish_parentage_facts

    def _set_facts(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_facts(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field facts"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_facts

    def _mod_facts(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_facts

    def _del_facts(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "facts"

    facts = property(_get_facts, _set_facts, _del_facts)

    @property
    def facts__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def facts__type(self):
        return self.TYPE_Repeated_facts

    def _finalize_facts(cls):
        if is_string(cls.TYPE_Repeated_facts):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_facts) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_facts, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_facts.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_facts)


TYPE_CDOTAResponseQuerySerialized = CDOTAResponseQuerySerialized
_PB_finalizers.append('CDOTAResponseQuerySerialized')

class CDOTASpeechMatchOnClient(ProtoBase):
    _required = []
    _field_map = {'responsequery': 3, 'concept': 1, 'randomseed': 4, 'recipient_type': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['concept', 'recipient_type', 'responsequery', 'randomseed']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_concept(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'concept')
            self._cache[1] = r
        return r

    def _establish_parentage_concept(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_concept), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_concept
                v._pbf_establish_parent_callback = self._establish_parentage_concept

    def _set_concept(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_concept(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field concept"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_concept(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_concept(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "concept"

    concept = property(_get_concept, _set_concept, _del_concept)

    @property
    def concept__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def concept__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_concept(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_concept)


    def _get_recipient_type(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'recipient_type')
            self._cache[2] = r
        return r

    def _establish_parentage_recipient_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_recipient_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_recipient_type
                v._pbf_establish_parent_callback = self._establish_parentage_recipient_type

    def _set_recipient_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_recipient_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field recipient_type"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_recipient_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_recipient_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "recipient_type"

    recipient_type = property(_get_recipient_type, _set_recipient_type, _del_recipient_type)

    @property
    def recipient_type__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def recipient_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_recipient_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_recipient_type)


    def _get_responsequery(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, TYPE_CDOTAResponseQuerySerialized, 'responsequery')
            self._cache[3] = r
        return r

    def _establish_parentage_responsequery(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_responsequery), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_responsequery
                v._pbf_establish_parent_callback = self._establish_parentage_responsequery

    def _set_responsequery(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_responsequery(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field responsequery"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_CDOTAResponseQuerySerialized

    def _mod_responsequery(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_CDOTAResponseQuerySerialized

    def _del_responsequery(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "responsequery"

    responsequery = property(_get_responsequery, _set_responsequery, _del_responsequery)

    @property
    def responsequery__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def responsequery__type(self):
        return TYPE_CDOTAResponseQuerySerialized

    def _finalize_responsequery(cls):
        if is_string(TYPE_CDOTAResponseQuerySerialized):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_CDOTAResponseQuerySerialized) is _PB_type:
            assert issubclass(TYPE_CDOTAResponseQuerySerialized, RepeatedSequence)
            if is_string(TYPE_CDOTAResponseQuerySerialized.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_responsequery)


    def _get_randomseed(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            try:
                r = self._buf_get(4, ProtoBase.TYPE_sfixed32, 'randomseed')
            except:
                r = 0
            self._cache[4] = r
        return r

    def _establish_parentage_randomseed(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_randomseed), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_randomseed
                v._pbf_establish_parent_callback = self._establish_parentage_randomseed

    def _set_randomseed(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_randomseed(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field randomseed"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_sfixed32

    def _mod_randomseed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_sfixed32

    def _del_randomseed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "randomseed"

    randomseed = property(_get_randomseed, _set_randomseed, _del_randomseed)

    @property
    def randomseed__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def randomseed__type(self):
        return ProtoBase.TYPE_sfixed32

    def _finalize_randomseed(cls):
        if is_string(ProtoBase.TYPE_sfixed32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_sfixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_sfixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_sfixed32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_randomseed)


TYPE_CDOTASpeechMatchOnClient = CDOTASpeechMatchOnClient
_PB_finalizers.append('CDOTASpeechMatchOnClient')

class CDOTAUserMsg_UnitEvent(ProtoBase):
    _required = [1, 2]
    _field_map = {'entity_index': 2, 'msg_type': 1, 'speech_match_on_client': 9, 'fade_gesture': 8, 'add_gesture': 5, 'remove_gesture': 6, 'speech': 3, 'blood_impact': 7, 'speech_mute': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['msg_type', 'entity_index', 'speech', 'speech_mute', 'add_gesture', 'remove_gesture', 'blood_impact', 'fade_gesture', 'speech_match_on_client']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class Speech(ProtoBase):
        _required = []
        _field_map = {'concept': 1, 'muteable': 5, 'response': 2, 'recipient_type': 3, 'level': 4}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['concept', 'response', 'recipient_type', 'level', 'muteable']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_concept(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'concept')
                self._cache[1] = r
            return r
    
        def _establish_parentage_concept(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_concept), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_concept
                    v._pbf_establish_parent_callback = self._establish_parentage_concept
    
        def _set_concept(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_concept(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field concept"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_concept(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_concept(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "concept"
    
        concept = property(_get_concept, _set_concept, _del_concept)
    
        @property
        def concept__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def concept__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_concept(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_concept)
    
        
        def _get_response(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'response')
                self._cache[2] = r
            return r
    
        def _establish_parentage_response(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_response), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_response
                    v._pbf_establish_parent_callback = self._establish_parentage_response
    
        def _set_response(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_response(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field response"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_response(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_response(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "response"
    
        response = property(_get_response, _set_response, _del_response)
    
        @property
        def response__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def response__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_response(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_response)
    
        
        def _get_recipient_type(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'recipient_type')
                self._cache[3] = r
            return r
    
        def _establish_parentage_recipient_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_recipient_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_recipient_type
                    v._pbf_establish_parent_callback = self._establish_parentage_recipient_type
    
        def _set_recipient_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_recipient_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field recipient_type"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_recipient_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_recipient_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "recipient_type"
    
        recipient_type = property(_get_recipient_type, _set_recipient_type, _del_recipient_type)
    
        @property
        def recipient_type__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def recipient_type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_recipient_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_recipient_type)
    
        
        def _get_level(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_int32, 'level')
                self._cache[4] = r
            return r
    
        def _establish_parentage_level(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_level), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_level
                    v._pbf_establish_parent_callback = self._establish_parentage_level
    
        def _set_level(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_level(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field level"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _mod_level(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _del_level(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "level"
    
        level = property(_get_level, _set_level, _del_level)
    
        @property
        def level__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def level__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_level(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_level)
    
        
        def _get_muteable(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                try:
                    r = self._buf_get(5, ProtoBase.TYPE_bool, 'muteable')
                except:
                    r = False
                self._cache[5] = r
            return r
    
        def _establish_parentage_muteable(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_muteable), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_muteable
                    v._pbf_establish_parent_callback = self._establish_parentage_muteable
    
        def _set_muteable(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_muteable(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field muteable"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = ProtoBase.TYPE_bool
    
        def _mod_muteable(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = ProtoBase.TYPE_bool
    
        def _del_muteable(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "muteable"
    
        muteable = property(_get_muteable, _set_muteable, _del_muteable)
    
        @property
        def muteable__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def muteable__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_muteable(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(5)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_muteable)
    
        
    TYPE_Speech = Speech
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.Speech')
    
    TYPE_Speech = Speech
    
    class SpeechMute(ProtoBase):
        _required = []
        _field_map = {'delay': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['delay']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_delay(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                try:
                    r = self._buf_get(1, ProtoBase.TYPE_float, 'delay')
                except:
                    r = 0.5
                self._cache[1] = r
            return r
    
        def _establish_parentage_delay(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_delay), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_delay
                    v._pbf_establish_parent_callback = self._establish_parentage_delay
    
        def _set_delay(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_delay(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field delay"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_float
    
        def _mod_delay(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_float
    
        def _del_delay(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "delay"
    
        delay = property(_get_delay, _set_delay, _del_delay)
    
        @property
        def delay__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def delay__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_delay(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_delay)
    
        
    TYPE_SpeechMute = SpeechMute
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.SpeechMute')
    
    TYPE_SpeechMute = SpeechMute
    
    class AddGesture(ProtoBase):
        _required = []
        _field_map = {'slot': 2, 'fade_in': 3, 'fade_out': 4, 'activity': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['activity', 'slot', 'fade_in', 'fade_out']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_activity(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                try:
                    r = self._buf_get(1, TYPE_Activity, 'activity')
                except:
                    r = ACT_INVALID
                self._cache[1] = r
            return r
    
        def _establish_parentage_activity(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_activity), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_activity
                    v._pbf_establish_parent_callback = self._establish_parentage_activity
    
        def _set_activity(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_activity(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field activity"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = TYPE_Activity
    
        def _mod_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = TYPE_Activity
    
        def _del_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "activity"
    
        activity = property(_get_activity, _set_activity, _del_activity)
    
        @property
        def activity__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def activity__type(self):
            return TYPE_Activity
    
        def _finalize_activity(cls):
            if is_string(TYPE_Activity):
                cls._pbf_strings.append(1)
            elif _PB_type(TYPE_Activity) is _PB_type:
                assert issubclass(TYPE_Activity, RepeatedSequence)
                if is_string(TYPE_Activity.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_activity)
    
        
        def _get_slot(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'slot')
                self._cache[2] = r
            return r
    
        def _establish_parentage_slot(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_slot), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_slot
                    v._pbf_establish_parent_callback = self._establish_parentage_slot
    
        def _set_slot(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_slot(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field slot"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_slot(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_slot(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "slot"
    
        slot = property(_get_slot, _set_slot, _del_slot)
    
        @property
        def slot__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def slot__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_slot(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_slot)
    
        
        def _get_fade_in(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                try:
                    r = self._buf_get(3, ProtoBase.TYPE_float, 'fade_in')
                except:
                    r = 0
                self._cache[3] = r
            return r
    
        def _establish_parentage_fade_in(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_fade_in), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_fade_in
                    v._pbf_establish_parent_callback = self._establish_parentage_fade_in
    
        def _set_fade_in(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_fade_in(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field fade_in"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_float
    
        def _mod_fade_in(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_float
    
        def _del_fade_in(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "fade_in"
    
        fade_in = property(_get_fade_in, _set_fade_in, _del_fade_in)
    
        @property
        def fade_in__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def fade_in__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_fade_in(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_fade_in)
    
        
        def _get_fade_out(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                try:
                    r = self._buf_get(4, ProtoBase.TYPE_float, 'fade_out')
                except:
                    r = 0.1
                self._cache[4] = r
            return r
    
        def _establish_parentage_fade_out(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_fade_out), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_fade_out
                    v._pbf_establish_parent_callback = self._establish_parentage_fade_out
    
        def _set_fade_out(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_fade_out(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field fade_out"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_float
    
        def _mod_fade_out(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_float
    
        def _del_fade_out(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "fade_out"
    
        fade_out = property(_get_fade_out, _set_fade_out, _del_fade_out)
    
        @property
        def fade_out__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def fade_out__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_fade_out(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_fade_out)
    
        
    TYPE_AddGesture = AddGesture
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.AddGesture')
    
    TYPE_AddGesture = AddGesture
    
    class RemoveGesture(ProtoBase):
        _required = []
        _field_map = {'activity': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['activity']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_activity(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                try:
                    r = self._buf_get(1, TYPE_Activity, 'activity')
                except:
                    r = ACT_INVALID
                self._cache[1] = r
            return r
    
        def _establish_parentage_activity(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_activity), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_activity
                    v._pbf_establish_parent_callback = self._establish_parentage_activity
    
        def _set_activity(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_activity(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field activity"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = TYPE_Activity
    
        def _mod_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = TYPE_Activity
    
        def _del_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "activity"
    
        activity = property(_get_activity, _set_activity, _del_activity)
    
        @property
        def activity__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def activity__type(self):
            return TYPE_Activity
    
        def _finalize_activity(cls):
            if is_string(TYPE_Activity):
                cls._pbf_strings.append(1)
            elif _PB_type(TYPE_Activity) is _PB_type:
                assert issubclass(TYPE_Activity, RepeatedSequence)
                if is_string(TYPE_Activity.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_activity)
    
        
    TYPE_RemoveGesture = RemoveGesture
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.RemoveGesture')
    
    TYPE_RemoveGesture = RemoveGesture
    
    class BloodImpact(ProtoBase):
        _required = []
        _field_map = {'scale': 1, 'y_normal': 3, 'x_normal': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['scale', 'x_normal', 'y_normal']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_scale(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'scale')
                self._cache[1] = r
            return r
    
        def _establish_parentage_scale(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_scale), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_scale
                    v._pbf_establish_parent_callback = self._establish_parentage_scale
    
        def _set_scale(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_scale(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field scale"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_scale(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_scale(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "scale"
    
        scale = property(_get_scale, _set_scale, _del_scale)
    
        @property
        def scale__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def scale__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_scale(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_scale)
    
        
        def _get_x_normal(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'x_normal')
                self._cache[2] = r
            return r
    
        def _establish_parentage_x_normal(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_x_normal), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_x_normal
                    v._pbf_establish_parent_callback = self._establish_parentage_x_normal
    
        def _set_x_normal(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_x_normal(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field x_normal"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_x_normal(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_x_normal(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "x_normal"
    
        x_normal = property(_get_x_normal, _set_x_normal, _del_x_normal)
    
        @property
        def x_normal__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def x_normal__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_x_normal(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_x_normal)
    
        
        def _get_y_normal(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'y_normal')
                self._cache[3] = r
            return r
    
        def _establish_parentage_y_normal(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_y_normal), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_y_normal
                    v._pbf_establish_parent_callback = self._establish_parentage_y_normal
    
        def _set_y_normal(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_y_normal(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field y_normal"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_y_normal(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_y_normal(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "y_normal"
    
        y_normal = property(_get_y_normal, _set_y_normal, _del_y_normal)
    
        @property
        def y_normal__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def y_normal__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_y_normal(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_y_normal)
    
        
    TYPE_BloodImpact = BloodImpact
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.BloodImpact')
    
    TYPE_BloodImpact = BloodImpact
    
    class FadeGesture(ProtoBase):
        _required = []
        _field_map = {'activity': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['activity']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_activity(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                try:
                    r = self._buf_get(1, TYPE_Activity, 'activity')
                except:
                    r = ACT_INVALID
                self._cache[1] = r
            return r
    
        def _establish_parentage_activity(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_activity), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_activity
                    v._pbf_establish_parent_callback = self._establish_parentage_activity
    
        def _set_activity(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_activity(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field activity"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = TYPE_Activity
    
        def _mod_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = TYPE_Activity
    
        def _del_activity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "activity"
    
        activity = property(_get_activity, _set_activity, _del_activity)
    
        @property
        def activity__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def activity__type(self):
            return TYPE_Activity
    
        def _finalize_activity(cls):
            if is_string(TYPE_Activity):
                cls._pbf_strings.append(1)
            elif _PB_type(TYPE_Activity) is _PB_type:
                assert issubclass(TYPE_Activity, RepeatedSequence)
                if is_string(TYPE_Activity.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_activity)
    
        
    TYPE_FadeGesture = FadeGesture
    _PB_finalizers.append('CDOTAUserMsg_UnitEvent.FadeGesture')
    
    TYPE_FadeGesture = FadeGesture

    def _get_msg_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_EDotaEntityMessages, 'msg_type')
            except:
                r = DOTA_UNIT_SPEECH
            self._cache[1] = r
        return r

    def _establish_parentage_msg_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_msg_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_msg_type
                v._pbf_establish_parent_callback = self._establish_parentage_msg_type

    def _set_msg_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_msg_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field msg_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_EDotaEntityMessages

    def _mod_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_EDotaEntityMessages

    def _del_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "msg_type"

    msg_type = property(_get_msg_type, _set_msg_type, _del_msg_type)

    @property
    def msg_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def msg_type__type(self):
        return TYPE_EDotaEntityMessages

    def _finalize_msg_type(cls):
        if is_string(TYPE_EDotaEntityMessages):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_EDotaEntityMessages) is _PB_type:
            assert issubclass(TYPE_EDotaEntityMessages, RepeatedSequence)
            if is_string(TYPE_EDotaEntityMessages.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_msg_type)


    def _get_entity_index(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'entity_index')
            self._cache[2] = r
        return r

    def _establish_parentage_entity_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_index
                v._pbf_establish_parent_callback = self._establish_parentage_entity_index

    def _set_entity_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_index"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "entity_index"

    entity_index = property(_get_entity_index, _set_entity_index, _del_entity_index)

    @property
    def entity_index__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def entity_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_entity_index)


    def _get_speech(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, CDOTAUserMsg_UnitEvent.TYPE_Speech, 'speech')
            self._cache[3] = r
        return r

    def _establish_parentage_speech(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_speech), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_speech
                v._pbf_establish_parent_callback = self._establish_parentage_speech

    def _set_speech(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_speech(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field speech"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = CDOTAUserMsg_UnitEvent.TYPE_Speech

    def _mod_speech(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = CDOTAUserMsg_UnitEvent.TYPE_Speech

    def _del_speech(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "speech"

    speech = property(_get_speech, _set_speech, _del_speech)

    @property
    def speech__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def speech__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_Speech

    def _finalize_speech(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_Speech):
            cls._pbf_strings.append(3)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_Speech) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_Speech, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_Speech.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_speech)


    def _get_speech_mute(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, CDOTAUserMsg_UnitEvent.TYPE_SpeechMute, 'speech_mute')
            self._cache[4] = r
        return r

    def _establish_parentage_speech_mute(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_speech_mute), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_speech_mute
                v._pbf_establish_parent_callback = self._establish_parentage_speech_mute

    def _set_speech_mute(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_speech_mute(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field speech_mute"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = CDOTAUserMsg_UnitEvent.TYPE_SpeechMute

    def _mod_speech_mute(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = CDOTAUserMsg_UnitEvent.TYPE_SpeechMute

    def _del_speech_mute(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "speech_mute"

    speech_mute = property(_get_speech_mute, _set_speech_mute, _del_speech_mute)

    @property
    def speech_mute__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def speech_mute__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_SpeechMute

    def _finalize_speech_mute(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_SpeechMute):
            cls._pbf_strings.append(4)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_SpeechMute) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_SpeechMute, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_SpeechMute.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_speech_mute)


    def _get_add_gesture(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, CDOTAUserMsg_UnitEvent.TYPE_AddGesture, 'add_gesture')
            self._cache[5] = r
        return r

    def _establish_parentage_add_gesture(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_add_gesture), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_add_gesture
                v._pbf_establish_parent_callback = self._establish_parentage_add_gesture

    def _set_add_gesture(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_add_gesture(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field add_gesture"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = CDOTAUserMsg_UnitEvent.TYPE_AddGesture

    def _mod_add_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = CDOTAUserMsg_UnitEvent.TYPE_AddGesture

    def _del_add_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "add_gesture"

    add_gesture = property(_get_add_gesture, _set_add_gesture, _del_add_gesture)

    @property
    def add_gesture__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def add_gesture__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_AddGesture

    def _finalize_add_gesture(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_AddGesture):
            cls._pbf_strings.append(5)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_AddGesture) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_AddGesture, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_AddGesture.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_add_gesture)


    def _get_remove_gesture(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture, 'remove_gesture')
            self._cache[6] = r
        return r

    def _establish_parentage_remove_gesture(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_remove_gesture), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_remove_gesture
                v._pbf_establish_parent_callback = self._establish_parentage_remove_gesture

    def _set_remove_gesture(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_remove_gesture(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field remove_gesture"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture

    def _mod_remove_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture

    def _del_remove_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "remove_gesture"

    remove_gesture = property(_get_remove_gesture, _set_remove_gesture, _del_remove_gesture)

    @property
    def remove_gesture__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def remove_gesture__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture

    def _finalize_remove_gesture(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture):
            cls._pbf_strings.append(6)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_RemoveGesture.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_remove_gesture)


    def _get_blood_impact(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, CDOTAUserMsg_UnitEvent.TYPE_BloodImpact, 'blood_impact')
            self._cache[7] = r
        return r

    def _establish_parentage_blood_impact(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_blood_impact), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_blood_impact
                v._pbf_establish_parent_callback = self._establish_parentage_blood_impact

    def _set_blood_impact(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_blood_impact(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field blood_impact"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = CDOTAUserMsg_UnitEvent.TYPE_BloodImpact

    def _mod_blood_impact(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = CDOTAUserMsg_UnitEvent.TYPE_BloodImpact

    def _del_blood_impact(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "blood_impact"

    blood_impact = property(_get_blood_impact, _set_blood_impact, _del_blood_impact)

    @property
    def blood_impact__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def blood_impact__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_BloodImpact

    def _finalize_blood_impact(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_BloodImpact):
            cls._pbf_strings.append(7)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_BloodImpact) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_BloodImpact, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_BloodImpact.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_blood_impact)


    def _get_fade_gesture(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, CDOTAUserMsg_UnitEvent.TYPE_FadeGesture, 'fade_gesture')
            self._cache[8] = r
        return r

    def _establish_parentage_fade_gesture(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fade_gesture), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fade_gesture
                v._pbf_establish_parent_callback = self._establish_parentage_fade_gesture

    def _set_fade_gesture(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fade_gesture(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fade_gesture"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = CDOTAUserMsg_UnitEvent.TYPE_FadeGesture

    def _mod_fade_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = CDOTAUserMsg_UnitEvent.TYPE_FadeGesture

    def _del_fade_gesture(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "fade_gesture"

    fade_gesture = property(_get_fade_gesture, _set_fade_gesture, _del_fade_gesture)

    @property
    def fade_gesture__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def fade_gesture__type(self):
        return CDOTAUserMsg_UnitEvent.TYPE_FadeGesture

    def _finalize_fade_gesture(cls):
        if is_string(CDOTAUserMsg_UnitEvent.TYPE_FadeGesture):
            cls._pbf_strings.append(8)
        elif _PB_type(CDOTAUserMsg_UnitEvent.TYPE_FadeGesture) is _PB_type:
            assert issubclass(CDOTAUserMsg_UnitEvent.TYPE_FadeGesture, RepeatedSequence)
            if is_string(CDOTAUserMsg_UnitEvent.TYPE_FadeGesture.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_fade_gesture)


    def _get_speech_match_on_client(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, TYPE_CDOTASpeechMatchOnClient, 'speech_match_on_client')
            self._cache[9] = r
        return r

    def _establish_parentage_speech_match_on_client(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_speech_match_on_client), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_speech_match_on_client
                v._pbf_establish_parent_callback = self._establish_parentage_speech_match_on_client

    def _set_speech_match_on_client(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_speech_match_on_client(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field speech_match_on_client"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = TYPE_CDOTASpeechMatchOnClient

    def _mod_speech_match_on_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = TYPE_CDOTASpeechMatchOnClient

    def _del_speech_match_on_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "speech_match_on_client"

    speech_match_on_client = property(_get_speech_match_on_client, _set_speech_match_on_client, _del_speech_match_on_client)

    @property
    def speech_match_on_client__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def speech_match_on_client__type(self):
        return TYPE_CDOTASpeechMatchOnClient

    def _finalize_speech_match_on_client(cls):
        if is_string(TYPE_CDOTASpeechMatchOnClient):
            cls._pbf_strings.append(9)
        elif _PB_type(TYPE_CDOTASpeechMatchOnClient) is _PB_type:
            assert issubclass(TYPE_CDOTASpeechMatchOnClient, RepeatedSequence)
            if is_string(TYPE_CDOTASpeechMatchOnClient.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_speech_match_on_client)


TYPE_CDOTAUserMsg_UnitEvent = CDOTAUserMsg_UnitEvent
_PB_finalizers.append('CDOTAUserMsg_UnitEvent')

class CDOTAUserMsg_ItemPurchased(ProtoBase):
    _required = []
    _field_map = {'item_index': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['item_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_item_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'item_index')
            self._cache[1] = r
        return r

    def _establish_parentage_item_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_item_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_item_index
                v._pbf_establish_parent_callback = self._establish_parentage_item_index

    def _set_item_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_item_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field item_index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_item_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_item_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "item_index"

    item_index = property(_get_item_index, _set_item_index, _del_item_index)

    @property
    def item_index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def item_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_item_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_item_index)


TYPE_CDOTAUserMsg_ItemPurchased = CDOTAUserMsg_ItemPurchased
_PB_finalizers.append('CDOTAUserMsg_ItemPurchased')

class CDOTAUserMsg_ItemFound(ProtoBase):
    _required = []
    _field_map = {'player': 1, 'quality': 2, 'method': 4, 'itemdef': 5, 'rarity': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player', 'quality', 'rarity', 'method', 'itemdef']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player')
            self._cache[1] = r
        return r

    def _establish_parentage_player(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player
                v._pbf_establish_parent_callback = self._establish_parentage_player

    def _set_player(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player"

    player = property(_get_player, _set_player, _del_player)

    @property
    def player__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player)


    def _get_quality(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'quality')
            self._cache[2] = r
        return r

    def _establish_parentage_quality(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_quality), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_quality
                v._pbf_establish_parent_callback = self._establish_parentage_quality

    def _set_quality(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_quality(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field quality"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_quality(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_quality(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "quality"

    quality = property(_get_quality, _set_quality, _del_quality)

    @property
    def quality__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def quality__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_quality(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_quality)


    def _get_rarity(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'rarity')
            self._cache[3] = r
        return r

    def _establish_parentage_rarity(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_rarity), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_rarity
                v._pbf_establish_parent_callback = self._establish_parentage_rarity

    def _set_rarity(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_rarity(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field rarity"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_rarity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_rarity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "rarity"

    rarity = property(_get_rarity, _set_rarity, _del_rarity)

    @property
    def rarity__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def rarity__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_rarity(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_rarity)


    def _get_method(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'method')
            self._cache[4] = r
        return r

    def _establish_parentage_method(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_method), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_method
                v._pbf_establish_parent_callback = self._establish_parentage_method

    def _set_method(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_method(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field method"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_method(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_method(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "method"

    method = property(_get_method, _set_method, _del_method)

    @property
    def method__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def method__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_method(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_method)


    def _get_itemdef(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'itemdef')
            self._cache[5] = r
        return r

    def _establish_parentage_itemdef(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_itemdef), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_itemdef
                v._pbf_establish_parent_callback = self._establish_parentage_itemdef

    def _set_itemdef(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_itemdef(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field itemdef"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_itemdef(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_itemdef(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "itemdef"

    itemdef = property(_get_itemdef, _set_itemdef, _del_itemdef)

    @property
    def itemdef__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def itemdef__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_itemdef(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_itemdef)


TYPE_CDOTAUserMsg_ItemFound = CDOTAUserMsg_ItemFound
_PB_finalizers.append('CDOTAUserMsg_ItemFound')

class CDOTAUserMsg_ParticleManager(ProtoBase):
    _required = [1, 2]
    _field_map = {'index': 2, 'update_particle': 7, 'update_particle_orient': 9, 'update_particle_fwd': 8, 'update_particle_offset': 11, 'update_particle_set_frozen': 15, 'release_particle_index': 3, 'update_particle_ent': 12, 'destroy_particle_involving': 6, 'update_particle_should_draw': 14, 'destroy_particle': 5, 'type': 1, 'update_particle_fallback': 10, 'create_particle': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['type', 'index', 'release_particle_index', 'create_particle', 'destroy_particle', 'destroy_particle_involving', 'update_particle', 'update_particle_fwd', 'update_particle_orient', 'update_particle_fallback', 'update_particle_offset', 'update_particle_ent', 'update_particle_should_draw', 'update_particle_set_frozen']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class ReleaseParticleIndex(ProtoBase):
        _required = []
        _field_map = {}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
    TYPE_ReleaseParticleIndex = ReleaseParticleIndex
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.ReleaseParticleIndex')
    
    TYPE_ReleaseParticleIndex = ReleaseParticleIndex
    
    class CreateParticle(ProtoBase):
        _required = []
        _field_map = {'attach_type': 2, 'entity_handle': 3, 'particle_name_index': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['particle_name_index', 'attach_type', 'entity_handle']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_particle_name_index(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'particle_name_index')
                self._cache[1] = r
            return r
    
        def _establish_parentage_particle_name_index(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_particle_name_index), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_particle_name_index
                    v._pbf_establish_parent_callback = self._establish_parentage_particle_name_index
    
        def _set_particle_name_index(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_particle_name_index(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field particle_name_index"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_particle_name_index(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_particle_name_index(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "particle_name_index"
    
        particle_name_index = property(_get_particle_name_index, _set_particle_name_index, _del_particle_name_index)
    
        @property
        def particle_name_index__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def particle_name_index__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_particle_name_index(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_particle_name_index)
    
        
        def _get_attach_type(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'attach_type')
                self._cache[2] = r
            return r
    
        def _establish_parentage_attach_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_attach_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_attach_type
                    v._pbf_establish_parent_callback = self._establish_parentage_attach_type
    
        def _set_attach_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_attach_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field attach_type"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_attach_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_attach_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "attach_type"
    
        attach_type = property(_get_attach_type, _set_attach_type, _del_attach_type)
    
        @property
        def attach_type__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def attach_type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_attach_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_attach_type)
    
        
        def _get_entity_handle(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'entity_handle')
                self._cache[3] = r
            return r
    
        def _establish_parentage_entity_handle(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_entity_handle), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_entity_handle
                    v._pbf_establish_parent_callback = self._establish_parentage_entity_handle
    
        def _set_entity_handle(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_entity_handle(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field entity_handle"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "entity_handle"
    
        entity_handle = property(_get_entity_handle, _set_entity_handle, _del_entity_handle)
    
        @property
        def entity_handle__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def entity_handle__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_entity_handle(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_entity_handle)
    
        
    TYPE_CreateParticle = CreateParticle
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.CreateParticle')
    
    TYPE_CreateParticle = CreateParticle
    
    class DestroyParticle(ProtoBase):
        _required = []
        _field_map = {'destroy_immediately': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['destroy_immediately']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_destroy_immediately(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_bool, 'destroy_immediately')
                self._cache[1] = r
            return r
    
        def _establish_parentage_destroy_immediately(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_destroy_immediately), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_destroy_immediately
                    v._pbf_establish_parent_callback = self._establish_parentage_destroy_immediately
    
        def _set_destroy_immediately(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_destroy_immediately(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field destroy_immediately"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _mod_destroy_immediately(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _del_destroy_immediately(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "destroy_immediately"
    
        destroy_immediately = property(_get_destroy_immediately, _set_destroy_immediately, _del_destroy_immediately)
    
        @property
        def destroy_immediately__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def destroy_immediately__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_destroy_immediately(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_destroy_immediately)
    
        
    TYPE_DestroyParticle = DestroyParticle
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.DestroyParticle')
    
    TYPE_DestroyParticle = DestroyParticle
    
    class DestroyParticleInvolving(ProtoBase):
        _required = []
        _field_map = {'entity_handle': 3, 'destroy_immediately': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['destroy_immediately', 'entity_handle']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_destroy_immediately(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_bool, 'destroy_immediately')
                self._cache[1] = r
            return r
    
        def _establish_parentage_destroy_immediately(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_destroy_immediately), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_destroy_immediately
                    v._pbf_establish_parent_callback = self._establish_parentage_destroy_immediately
    
        def _set_destroy_immediately(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_destroy_immediately(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field destroy_immediately"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _mod_destroy_immediately(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _del_destroy_immediately(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "destroy_immediately"
    
        destroy_immediately = property(_get_destroy_immediately, _set_destroy_immediately, _del_destroy_immediately)
    
        @property
        def destroy_immediately__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def destroy_immediately__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_destroy_immediately(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_destroy_immediately)
    
        
        def _get_entity_handle(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'entity_handle')
                self._cache[3] = r
            return r
    
        def _establish_parentage_entity_handle(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_entity_handle), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_entity_handle
                    v._pbf_establish_parent_callback = self._establish_parentage_entity_handle
    
        def _set_entity_handle(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_entity_handle(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field entity_handle"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "entity_handle"
    
        entity_handle = property(_get_entity_handle, _set_entity_handle, _del_entity_handle)
    
        @property
        def entity_handle__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def entity_handle__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_entity_handle(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_entity_handle)
    
        
    TYPE_DestroyParticleInvolving = DestroyParticleInvolving
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.DestroyParticleInvolving')
    
    TYPE_DestroyParticleInvolving = DestroyParticleInvolving
    
    class UpdateParticle(ProtoBase):
        _required = []
        _field_map = {'position': 2, 'control_point': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'position']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_position(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CMsgVector, 'position')
                self._cache[2] = r
            return r
    
        def _establish_parentage_position(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_position), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_position
                    v._pbf_establish_parent_callback = self._establish_parentage_position
    
        def _set_position(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_position(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field position"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CMsgVector
    
        def _mod_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CMsgVector
    
        def _del_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "position"
    
        position = property(_get_position, _set_position, _del_position)
    
        @property
        def position__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def position__type(self):
            return TYPE_CMsgVector
    
        def _finalize_position(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_position)
    
        
    TYPE_UpdateParticle = UpdateParticle
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticle')
    
    TYPE_UpdateParticle = UpdateParticle
    
    class UpdateParticleFwd(ProtoBase):
        _required = []
        _field_map = {'forward': 2, 'control_point': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'forward']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_forward(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CMsgVector, 'forward')
                self._cache[2] = r
            return r
    
        def _establish_parentage_forward(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_forward), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_forward
                    v._pbf_establish_parent_callback = self._establish_parentage_forward
    
        def _set_forward(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_forward(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field forward"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CMsgVector
    
        def _mod_forward(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CMsgVector
    
        def _del_forward(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "forward"
    
        forward = property(_get_forward, _set_forward, _del_forward)
    
        @property
        def forward__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def forward__type(self):
            return TYPE_CMsgVector
    
        def _finalize_forward(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_forward)
    
        
    TYPE_UpdateParticleFwd = UpdateParticleFwd
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleFwd')
    
    TYPE_UpdateParticleFwd = UpdateParticleFwd
    
    class UpdateParticleOrient(ProtoBase):
        _required = []
        _field_map = {'forward': 2, 'right': 3, 'control_point': 1, 'up': 4}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'forward', 'right', 'up']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_forward(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CMsgVector, 'forward')
                self._cache[2] = r
            return r
    
        def _establish_parentage_forward(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_forward), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_forward
                    v._pbf_establish_parent_callback = self._establish_parentage_forward
    
        def _set_forward(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_forward(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field forward"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CMsgVector
    
        def _mod_forward(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CMsgVector
    
        def _del_forward(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "forward"
    
        forward = property(_get_forward, _set_forward, _del_forward)
    
        @property
        def forward__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def forward__type(self):
            return TYPE_CMsgVector
    
        def _finalize_forward(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_forward)
    
        
        def _get_right(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, TYPE_CMsgVector, 'right')
                self._cache[3] = r
            return r
    
        def _establish_parentage_right(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_right), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_right
                    v._pbf_establish_parent_callback = self._establish_parentage_right
    
        def _set_right(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_right(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field right"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = TYPE_CMsgVector
    
        def _mod_right(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = TYPE_CMsgVector
    
        def _del_right(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "right"
    
        right = property(_get_right, _set_right, _del_right)
    
        @property
        def right__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def right__type(self):
            return TYPE_CMsgVector
    
        def _finalize_right(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(3)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_right)
    
        
        def _get_up(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, TYPE_CMsgVector, 'up')
                self._cache[4] = r
            return r
    
        def _establish_parentage_up(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_up), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_up
                    v._pbf_establish_parent_callback = self._establish_parentage_up
    
        def _set_up(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_up(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field up"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = TYPE_CMsgVector
    
        def _mod_up(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = TYPE_CMsgVector
    
        def _del_up(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "up"
    
        up = property(_get_up, _set_up, _del_up)
    
        @property
        def up__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def up__type(self):
            return TYPE_CMsgVector
    
        def _finalize_up(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(4)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_up)
    
        
    TYPE_UpdateParticleOrient = UpdateParticleOrient
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleOrient')
    
    TYPE_UpdateParticleOrient = UpdateParticleOrient
    
    class UpdateParticleFallback(ProtoBase):
        _required = []
        _field_map = {'position': 2, 'control_point': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'position']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_position(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CMsgVector, 'position')
                self._cache[2] = r
            return r
    
        def _establish_parentage_position(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_position), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_position
                    v._pbf_establish_parent_callback = self._establish_parentage_position
    
        def _set_position(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_position(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field position"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CMsgVector
    
        def _mod_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CMsgVector
    
        def _del_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "position"
    
        position = property(_get_position, _set_position, _del_position)
    
        @property
        def position__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def position__type(self):
            return TYPE_CMsgVector
    
        def _finalize_position(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_position)
    
        
    TYPE_UpdateParticleFallback = UpdateParticleFallback
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleFallback')
    
    TYPE_UpdateParticleFallback = UpdateParticleFallback
    
    class UpdateParticleOffset(ProtoBase):
        _required = []
        _field_map = {'origin_offset': 2, 'control_point': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'origin_offset']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_origin_offset(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CMsgVector, 'origin_offset')
                self._cache[2] = r
            return r
    
        def _establish_parentage_origin_offset(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_origin_offset), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_origin_offset
                    v._pbf_establish_parent_callback = self._establish_parentage_origin_offset
    
        def _set_origin_offset(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_origin_offset(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field origin_offset"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CMsgVector
    
        def _mod_origin_offset(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CMsgVector
    
        def _del_origin_offset(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "origin_offset"
    
        origin_offset = property(_get_origin_offset, _set_origin_offset, _del_origin_offset)
    
        @property
        def origin_offset__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def origin_offset__type(self):
            return TYPE_CMsgVector
    
        def _finalize_origin_offset(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_origin_offset)
    
        
    TYPE_UpdateParticleOffset = UpdateParticleOffset
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleOffset')
    
    TYPE_UpdateParticleOffset = UpdateParticleOffset
    
    class UpdateParticleEnt(ProtoBase):
        _required = []
        _field_map = {'fallback_position': 5, 'control_point': 1, 'attach_type': 3, 'attachment': 4, 'entity_handle': 2, 'include_wearables': 6}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['control_point', 'entity_handle', 'attach_type', 'attachment', 'fallback_position', 'include_wearables']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_control_point(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'control_point')
                self._cache[1] = r
            return r
    
        def _establish_parentage_control_point(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_control_point), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_control_point
                    v._pbf_establish_parent_callback = self._establish_parentage_control_point
    
        def _set_control_point(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_control_point(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field control_point"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_control_point(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "control_point"
    
        control_point = property(_get_control_point, _set_control_point, _del_control_point)
    
        @property
        def control_point__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def control_point__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_control_point(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_control_point)
    
        
        def _get_entity_handle(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_int32, 'entity_handle')
                self._cache[2] = r
            return r
    
        def _establish_parentage_entity_handle(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_entity_handle), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_entity_handle
                    v._pbf_establish_parent_callback = self._establish_parentage_entity_handle
    
        def _set_entity_handle(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_entity_handle(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field entity_handle"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _mod_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_int32
    
        def _del_entity_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "entity_handle"
    
        entity_handle = property(_get_entity_handle, _set_entity_handle, _del_entity_handle)
    
        @property
        def entity_handle__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def entity_handle__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_entity_handle(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_entity_handle)
    
        
        def _get_attach_type(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'attach_type')
                self._cache[3] = r
            return r
    
        def _establish_parentage_attach_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_attach_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_attach_type
                    v._pbf_establish_parent_callback = self._establish_parentage_attach_type
    
        def _set_attach_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_attach_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field attach_type"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_attach_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_attach_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "attach_type"
    
        attach_type = property(_get_attach_type, _set_attach_type, _del_attach_type)
    
        @property
        def attach_type__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def attach_type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_attach_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_attach_type)
    
        
        def _get_attachment(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_int32, 'attachment')
                self._cache[4] = r
            return r
    
        def _establish_parentage_attachment(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_attachment), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_attachment
                    v._pbf_establish_parent_callback = self._establish_parentage_attachment
    
        def _set_attachment(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_attachment(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field attachment"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _mod_attachment(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _del_attachment(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "attachment"
    
        attachment = property(_get_attachment, _set_attachment, _del_attachment)
    
        @property
        def attachment__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def attachment__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_attachment(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_attachment)
    
        
        def _get_fallback_position(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                r = self._buf_get(5, TYPE_CMsgVector, 'fallback_position')
                self._cache[5] = r
            return r
    
        def _establish_parentage_fallback_position(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_fallback_position), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_fallback_position
                    v._pbf_establish_parent_callback = self._establish_parentage_fallback_position
    
        def _set_fallback_position(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_fallback_position(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field fallback_position"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = TYPE_CMsgVector
    
        def _mod_fallback_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = TYPE_CMsgVector
    
        def _del_fallback_position(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "fallback_position"
    
        fallback_position = property(_get_fallback_position, _set_fallback_position, _del_fallback_position)
    
        @property
        def fallback_position__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def fallback_position__type(self):
            return TYPE_CMsgVector
    
        def _finalize_fallback_position(cls):
            if is_string(TYPE_CMsgVector):
                cls._pbf_strings.append(5)
            elif _PB_type(TYPE_CMsgVector) is _PB_type:
                assert issubclass(TYPE_CMsgVector, RepeatedSequence)
                if is_string(TYPE_CMsgVector.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_fallback_position)
    
        
        def _get_include_wearables(self):
            if 6 in self._cache:
                r = self._cache[6]
            else:
                r = self._buf_get(6, ProtoBase.TYPE_bool, 'include_wearables')
                self._cache[6] = r
            return r
    
        def _establish_parentage_include_wearables(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_include_wearables), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_include_wearables
                    v._pbf_establish_parent_callback = self._establish_parentage_include_wearables
    
        def _set_include_wearables(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_include_wearables(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field include_wearables"
                raise ProtoValueError(list_assign_error)
            self._cache[6] = v
            self._mods[6] = ProtoBase.TYPE_bool
    
        def _mod_include_wearables(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[6] = ProtoBase.TYPE_bool
    
        def _del_include_wearables(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 6 in self._cache:
                del self._cache[6]
            if 6 in self._mods:
                del self._mods[6]
            self._buf_del(6)
    
        _pb_field_name_6 = "include_wearables"
    
        include_wearables = property(_get_include_wearables, _set_include_wearables, _del_include_wearables)
    
        @property
        def include_wearables__exists(self):
            return 6 in self._mods or self._buf_exists(6)
    
        @property
        def include_wearables__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_include_wearables(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(6)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(6)
    
        _pbf_finalizers.append(_finalize_include_wearables)
    
        
    TYPE_UpdateParticleEnt = UpdateParticleEnt
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleEnt')
    
    TYPE_UpdateParticleEnt = UpdateParticleEnt
    
    class UpdateParticleSetFrozen(ProtoBase):
        _required = []
        _field_map = {'set_frozen': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['set_frozen']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_set_frozen(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_bool, 'set_frozen')
                self._cache[1] = r
            return r
    
        def _establish_parentage_set_frozen(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_set_frozen), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_set_frozen
                    v._pbf_establish_parent_callback = self._establish_parentage_set_frozen
    
        def _set_set_frozen(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_set_frozen(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field set_frozen"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _mod_set_frozen(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _del_set_frozen(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "set_frozen"
    
        set_frozen = property(_get_set_frozen, _set_set_frozen, _del_set_frozen)
    
        @property
        def set_frozen__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def set_frozen__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_set_frozen(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_set_frozen)
    
        
    TYPE_UpdateParticleSetFrozen = UpdateParticleSetFrozen
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleSetFrozen')
    
    TYPE_UpdateParticleSetFrozen = UpdateParticleSetFrozen
    
    class UpdateParticleShouldDraw(ProtoBase):
        _required = []
        _field_map = {'should_draw': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['should_draw']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_should_draw(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_bool, 'should_draw')
                self._cache[1] = r
            return r
    
        def _establish_parentage_should_draw(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_should_draw), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_should_draw
                    v._pbf_establish_parent_callback = self._establish_parentage_should_draw
    
        def _set_should_draw(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_should_draw(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field should_draw"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _mod_should_draw(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_bool
    
        def _del_should_draw(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "should_draw"
    
        should_draw = property(_get_should_draw, _set_should_draw, _del_should_draw)
    
        @property
        def should_draw__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def should_draw__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_should_draw(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_should_draw)
    
        
    TYPE_UpdateParticleShouldDraw = UpdateParticleShouldDraw
    _PB_finalizers.append('CDOTAUserMsg_ParticleManager.UpdateParticleShouldDraw')
    
    TYPE_UpdateParticleShouldDraw = UpdateParticleShouldDraw

    def _get_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_DOTA_PARTICLE_MESSAGE, 'type')
            except:
                r = DOTA_PARTICLE_MANAGER_EVENT_CREATE
            self._cache[1] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_DOTA_PARTICLE_MESSAGE

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_DOTA_PARTICLE_MESSAGE

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def type__type(self):
        return TYPE_DOTA_PARTICLE_MESSAGE

    def _finalize_type(cls):
        if is_string(TYPE_DOTA_PARTICLE_MESSAGE):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_DOTA_PARTICLE_MESSAGE) is _PB_type:
            assert issubclass(TYPE_DOTA_PARTICLE_MESSAGE, RepeatedSequence)
            if is_string(TYPE_DOTA_PARTICLE_MESSAGE.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_type)


    def _get_index(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'index')
            self._cache[2] = r
        return r

    def _establish_parentage_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_index
                v._pbf_establish_parent_callback = self._establish_parentage_index

    def _set_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field index"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "index"

    index = property(_get_index, _set_index, _del_index)

    @property
    def index__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def index__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_index(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_index)


    def _get_release_particle_index(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex, 'release_particle_index')
            self._cache[3] = r
        return r

    def _establish_parentage_release_particle_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_release_particle_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_release_particle_index
                v._pbf_establish_parent_callback = self._establish_parentage_release_particle_index

    def _set_release_particle_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_release_particle_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field release_particle_index"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex

    def _mod_release_particle_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex

    def _del_release_particle_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "release_particle_index"

    release_particle_index = property(_get_release_particle_index, _set_release_particle_index, _del_release_particle_index)

    @property
    def release_particle_index__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def release_particle_index__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex

    def _finalize_release_particle_index(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex):
            cls._pbf_strings.append(3)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_ReleaseParticleIndex.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_release_particle_index)


    def _get_create_particle(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, CDOTAUserMsg_ParticleManager.TYPE_CreateParticle, 'create_particle')
            self._cache[4] = r
        return r

    def _establish_parentage_create_particle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_create_particle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_create_particle
                v._pbf_establish_parent_callback = self._establish_parentage_create_particle

    def _set_create_particle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_create_particle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field create_particle"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = CDOTAUserMsg_ParticleManager.TYPE_CreateParticle

    def _mod_create_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = CDOTAUserMsg_ParticleManager.TYPE_CreateParticle

    def _del_create_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "create_particle"

    create_particle = property(_get_create_particle, _set_create_particle, _del_create_particle)

    @property
    def create_particle__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def create_particle__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_CreateParticle

    def _finalize_create_particle(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_CreateParticle):
            cls._pbf_strings.append(4)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_CreateParticle) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_CreateParticle, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_CreateParticle.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_create_particle)


    def _get_destroy_particle(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle, 'destroy_particle')
            self._cache[5] = r
        return r

    def _establish_parentage_destroy_particle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_destroy_particle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_destroy_particle
                v._pbf_establish_parent_callback = self._establish_parentage_destroy_particle

    def _set_destroy_particle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_destroy_particle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field destroy_particle"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle

    def _mod_destroy_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle

    def _del_destroy_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "destroy_particle"

    destroy_particle = property(_get_destroy_particle, _set_destroy_particle, _del_destroy_particle)

    @property
    def destroy_particle__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def destroy_particle__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle

    def _finalize_destroy_particle(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle):
            cls._pbf_strings.append(5)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticle.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_destroy_particle)


    def _get_destroy_particle_involving(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving, 'destroy_particle_involving')
            self._cache[6] = r
        return r

    def _establish_parentage_destroy_particle_involving(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_destroy_particle_involving), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_destroy_particle_involving
                v._pbf_establish_parent_callback = self._establish_parentage_destroy_particle_involving

    def _set_destroy_particle_involving(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_destroy_particle_involving(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field destroy_particle_involving"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving

    def _mod_destroy_particle_involving(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving

    def _del_destroy_particle_involving(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "destroy_particle_involving"

    destroy_particle_involving = property(_get_destroy_particle_involving, _set_destroy_particle_involving, _del_destroy_particle_involving)

    @property
    def destroy_particle_involving__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def destroy_particle_involving__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving

    def _finalize_destroy_particle_involving(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving):
            cls._pbf_strings.append(6)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_DestroyParticleInvolving.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_destroy_particle_involving)


    def _get_update_particle(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle, 'update_particle')
            self._cache[7] = r
        return r

    def _establish_parentage_update_particle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle

    def _set_update_particle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle

    def _mod_update_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle

    def _del_update_particle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "update_particle"

    update_particle = property(_get_update_particle, _set_update_particle, _del_update_particle)

    @property
    def update_particle__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def update_particle__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle

    def _finalize_update_particle(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle):
            cls._pbf_strings.append(7)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticle.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_update_particle)


    def _get_update_particle_fwd(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd, 'update_particle_fwd')
            self._cache[8] = r
        return r

    def _establish_parentage_update_particle_fwd(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_fwd), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_fwd
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_fwd

    def _set_update_particle_fwd(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_fwd(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_fwd"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd

    def _mod_update_particle_fwd(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd

    def _del_update_particle_fwd(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "update_particle_fwd"

    update_particle_fwd = property(_get_update_particle_fwd, _set_update_particle_fwd, _del_update_particle_fwd)

    @property
    def update_particle_fwd__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def update_particle_fwd__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd

    def _finalize_update_particle_fwd(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd):
            cls._pbf_strings.append(8)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFwd.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_update_particle_fwd)


    def _get_update_particle_orient(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient, 'update_particle_orient')
            self._cache[9] = r
        return r

    def _establish_parentage_update_particle_orient(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_orient), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_orient
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_orient

    def _set_update_particle_orient(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_orient(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_orient"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient

    def _mod_update_particle_orient(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient

    def _del_update_particle_orient(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "update_particle_orient"

    update_particle_orient = property(_get_update_particle_orient, _set_update_particle_orient, _del_update_particle_orient)

    @property
    def update_particle_orient__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def update_particle_orient__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient

    def _finalize_update_particle_orient(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient):
            cls._pbf_strings.append(9)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOrient.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_update_particle_orient)


    def _get_update_particle_fallback(self):
        if 10 in self._cache:
            r = self._cache[10]
        else:
            r = self._buf_get(10, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback, 'update_particle_fallback')
            self._cache[10] = r
        return r

    def _establish_parentage_update_particle_fallback(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_fallback), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_fallback
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_fallback

    def _set_update_particle_fallback(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_fallback(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_fallback"
            raise ProtoValueError(list_assign_error)
        self._cache[10] = v
        self._mods[10] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback

    def _mod_update_particle_fallback(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[10] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback

    def _del_update_particle_fallback(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 10 in self._cache:
            del self._cache[10]
        if 10 in self._mods:
            del self._mods[10]
        self._buf_del(10)

    _pb_field_name_10 = "update_particle_fallback"

    update_particle_fallback = property(_get_update_particle_fallback, _set_update_particle_fallback, _del_update_particle_fallback)

    @property
    def update_particle_fallback__exists(self):
        return 10 in self._mods or self._buf_exists(10)

    @property
    def update_particle_fallback__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback

    def _finalize_update_particle_fallback(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback):
            cls._pbf_strings.append(10)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleFallback.pb_subtype):
                cls._pbf_strings.append(10)

    _pbf_finalizers.append(_finalize_update_particle_fallback)


    def _get_update_particle_offset(self):
        if 11 in self._cache:
            r = self._cache[11]
        else:
            r = self._buf_get(11, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset, 'update_particle_offset')
            self._cache[11] = r
        return r

    def _establish_parentage_update_particle_offset(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_offset), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_offset
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_offset

    def _set_update_particle_offset(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_offset(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_offset"
            raise ProtoValueError(list_assign_error)
        self._cache[11] = v
        self._mods[11] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset

    def _mod_update_particle_offset(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[11] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset

    def _del_update_particle_offset(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 11 in self._cache:
            del self._cache[11]
        if 11 in self._mods:
            del self._mods[11]
        self._buf_del(11)

    _pb_field_name_11 = "update_particle_offset"

    update_particle_offset = property(_get_update_particle_offset, _set_update_particle_offset, _del_update_particle_offset)

    @property
    def update_particle_offset__exists(self):
        return 11 in self._mods or self._buf_exists(11)

    @property
    def update_particle_offset__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset

    def _finalize_update_particle_offset(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset):
            cls._pbf_strings.append(11)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleOffset.pb_subtype):
                cls._pbf_strings.append(11)

    _pbf_finalizers.append(_finalize_update_particle_offset)


    def _get_update_particle_ent(self):
        if 12 in self._cache:
            r = self._cache[12]
        else:
            r = self._buf_get(12, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt, 'update_particle_ent')
            self._cache[12] = r
        return r

    def _establish_parentage_update_particle_ent(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_ent), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_ent
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_ent

    def _set_update_particle_ent(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_ent(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_ent"
            raise ProtoValueError(list_assign_error)
        self._cache[12] = v
        self._mods[12] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt

    def _mod_update_particle_ent(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[12] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt

    def _del_update_particle_ent(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 12 in self._cache:
            del self._cache[12]
        if 12 in self._mods:
            del self._mods[12]
        self._buf_del(12)

    _pb_field_name_12 = "update_particle_ent"

    update_particle_ent = property(_get_update_particle_ent, _set_update_particle_ent, _del_update_particle_ent)

    @property
    def update_particle_ent__exists(self):
        return 12 in self._mods or self._buf_exists(12)

    @property
    def update_particle_ent__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt

    def _finalize_update_particle_ent(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt):
            cls._pbf_strings.append(12)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleEnt.pb_subtype):
                cls._pbf_strings.append(12)

    _pbf_finalizers.append(_finalize_update_particle_ent)


    def _get_update_particle_should_draw(self):
        if 14 in self._cache:
            r = self._cache[14]
        else:
            r = self._buf_get(14, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw, 'update_particle_should_draw')
            self._cache[14] = r
        return r

    def _establish_parentage_update_particle_should_draw(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_should_draw), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_should_draw
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_should_draw

    def _set_update_particle_should_draw(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_should_draw(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_should_draw"
            raise ProtoValueError(list_assign_error)
        self._cache[14] = v
        self._mods[14] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw

    def _mod_update_particle_should_draw(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[14] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw

    def _del_update_particle_should_draw(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 14 in self._cache:
            del self._cache[14]
        if 14 in self._mods:
            del self._mods[14]
        self._buf_del(14)

    _pb_field_name_14 = "update_particle_should_draw"

    update_particle_should_draw = property(_get_update_particle_should_draw, _set_update_particle_should_draw, _del_update_particle_should_draw)

    @property
    def update_particle_should_draw__exists(self):
        return 14 in self._mods or self._buf_exists(14)

    @property
    def update_particle_should_draw__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw

    def _finalize_update_particle_should_draw(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw):
            cls._pbf_strings.append(14)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleShouldDraw.pb_subtype):
                cls._pbf_strings.append(14)

    _pbf_finalizers.append(_finalize_update_particle_should_draw)


    def _get_update_particle_set_frozen(self):
        if 15 in self._cache:
            r = self._cache[15]
        else:
            r = self._buf_get(15, CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen, 'update_particle_set_frozen')
            self._cache[15] = r
        return r

    def _establish_parentage_update_particle_set_frozen(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_particle_set_frozen), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_particle_set_frozen
                v._pbf_establish_parent_callback = self._establish_parentage_update_particle_set_frozen

    def _set_update_particle_set_frozen(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_particle_set_frozen(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_particle_set_frozen"
            raise ProtoValueError(list_assign_error)
        self._cache[15] = v
        self._mods[15] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen

    def _mod_update_particle_set_frozen(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[15] = CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen

    def _del_update_particle_set_frozen(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 15 in self._cache:
            del self._cache[15]
        if 15 in self._mods:
            del self._mods[15]
        self._buf_del(15)

    _pb_field_name_15 = "update_particle_set_frozen"

    update_particle_set_frozen = property(_get_update_particle_set_frozen, _set_update_particle_set_frozen, _del_update_particle_set_frozen)

    @property
    def update_particle_set_frozen__exists(self):
        return 15 in self._mods or self._buf_exists(15)

    @property
    def update_particle_set_frozen__type(self):
        return CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen

    def _finalize_update_particle_set_frozen(cls):
        if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen):
            cls._pbf_strings.append(15)
        elif _PB_type(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen) is _PB_type:
            assert issubclass(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen, RepeatedSequence)
            if is_string(CDOTAUserMsg_ParticleManager.TYPE_UpdateParticleSetFrozen.pb_subtype):
                cls._pbf_strings.append(15)

    _pbf_finalizers.append(_finalize_update_particle_set_frozen)


TYPE_CDOTAUserMsg_ParticleManager = CDOTAUserMsg_ParticleManager
_PB_finalizers.append('CDOTAUserMsg_ParticleManager')

class CDOTAUserMsg_OverheadEvent(ProtoBase):
    _required = [1]
    _field_map = {'target_entindex': 4, 'target_player_entindex': 3, 'message_type': 1, 'value': 2, 'source_player_entindex': 5}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message_type', 'value', 'target_player_entindex', 'target_entindex', 'source_player_entindex']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_DOTA_OVERHEAD_ALERT, 'message_type')
            except:
                r = OVERHEAD_ALERT_GOLD
            self._cache[1] = r
        return r

    def _establish_parentage_message_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message_type
                v._pbf_establish_parent_callback = self._establish_parentage_message_type

    def _set_message_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_DOTA_OVERHEAD_ALERT

    def _mod_message_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_DOTA_OVERHEAD_ALERT

    def _del_message_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message_type"

    message_type = property(_get_message_type, _set_message_type, _del_message_type)

    @property
    def message_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message_type__type(self):
        return TYPE_DOTA_OVERHEAD_ALERT

    def _finalize_message_type(cls):
        if is_string(TYPE_DOTA_OVERHEAD_ALERT):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_DOTA_OVERHEAD_ALERT) is _PB_type:
            assert issubclass(TYPE_DOTA_OVERHEAD_ALERT, RepeatedSequence)
            if is_string(TYPE_DOTA_OVERHEAD_ALERT.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message_type)


    def _get_value(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'value')
            self._cache[2] = r
        return r

    def _establish_parentage_value(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_value
                v._pbf_establish_parent_callback = self._establish_parentage_value

    def _set_value(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_value(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field value"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "value"

    value = property(_get_value, _set_value, _del_value)

    @property
    def value__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def value__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_value(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_value)


    def _get_target_player_entindex(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'target_player_entindex')
            self._cache[3] = r
        return r

    def _establish_parentage_target_player_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target_player_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target_player_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_target_player_entindex

    def _set_target_player_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target_player_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target_player_entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_target_player_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_target_player_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "target_player_entindex"

    target_player_entindex = property(_get_target_player_entindex, _set_target_player_entindex, _del_target_player_entindex)

    @property
    def target_player_entindex__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def target_player_entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_target_player_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_target_player_entindex)


    def _get_target_entindex(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'target_entindex')
            self._cache[4] = r
        return r

    def _establish_parentage_target_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_target_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_target_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_target_entindex

    def _set_target_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_target_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field target_entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_target_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_target_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "target_entindex"

    target_entindex = property(_get_target_entindex, _set_target_entindex, _del_target_entindex)

    @property
    def target_entindex__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def target_entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_target_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_target_entindex)


    def _get_source_player_entindex(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'source_player_entindex')
            self._cache[5] = r
        return r

    def _establish_parentage_source_player_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_source_player_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_source_player_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_source_player_entindex

    def _set_source_player_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_source_player_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field source_player_entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_source_player_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_source_player_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "source_player_entindex"

    source_player_entindex = property(_get_source_player_entindex, _set_source_player_entindex, _del_source_player_entindex)

    @property
    def source_player_entindex__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def source_player_entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_source_player_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_source_player_entindex)


TYPE_CDOTAUserMsg_OverheadEvent = CDOTAUserMsg_OverheadEvent
_PB_finalizers.append('CDOTAUserMsg_OverheadEvent')

class CDOTAUserMsg_TutorialTipInfo(ProtoBase):
    _required = []
    _field_map = {'progress': 2, 'name': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['name', 'progress']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
            self._cache[1] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_name)


    def _get_progress(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'progress')
            self._cache[2] = r
        return r

    def _establish_parentage_progress(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_progress), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_progress
                v._pbf_establish_parent_callback = self._establish_parentage_progress

    def _set_progress(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_progress(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field progress"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_progress(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_progress(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "progress"

    progress = property(_get_progress, _set_progress, _del_progress)

    @property
    def progress__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def progress__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_progress(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_progress)


TYPE_CDOTAUserMsg_TutorialTipInfo = CDOTAUserMsg_TutorialTipInfo
_PB_finalizers.append('CDOTAUserMsg_TutorialTipInfo')

class CDOTAUserMsg_TutorialFinish(ProtoBase):
    _required = []
    _field_map = {'body': 3, 'emblem': 2, 'heading': 1, 'success': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['heading', 'emblem', 'body', 'success']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_heading(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'heading')
            self._cache[1] = r
        return r

    def _establish_parentage_heading(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_heading), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_heading
                v._pbf_establish_parent_callback = self._establish_parentage_heading

    def _set_heading(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_heading(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field heading"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_heading(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_heading(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "heading"

    heading = property(_get_heading, _set_heading, _del_heading)

    @property
    def heading__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def heading__type(self):
        return ProtoBase.TYPE_string

    def _finalize_heading(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_heading)


    def _get_emblem(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'emblem')
            self._cache[2] = r
        return r

    def _establish_parentage_emblem(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_emblem), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_emblem
                v._pbf_establish_parent_callback = self._establish_parentage_emblem

    def _set_emblem(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_emblem(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field emblem"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_emblem(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_emblem(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "emblem"

    emblem = property(_get_emblem, _set_emblem, _del_emblem)

    @property
    def emblem__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def emblem__type(self):
        return ProtoBase.TYPE_string

    def _finalize_emblem(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_emblem)


    def _get_body(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'body')
            self._cache[3] = r
        return r

    def _establish_parentage_body(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_body), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_body
                v._pbf_establish_parent_callback = self._establish_parentage_body

    def _set_body(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_body(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field body"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_body(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_body(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "body"

    body = property(_get_body, _set_body, _del_body)

    @property
    def body__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def body__type(self):
        return ProtoBase.TYPE_string

    def _finalize_body(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_body)


    def _get_success(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'success')
            self._cache[4] = r
        return r

    def _establish_parentage_success(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_success), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_success
                v._pbf_establish_parent_callback = self._establish_parentage_success

    def _set_success(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_success(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field success"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_success(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_success(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "success"

    success = property(_get_success, _set_success, _del_success)

    @property
    def success__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def success__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_success(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_success)


TYPE_CDOTAUserMsg_TutorialFinish = CDOTAUserMsg_TutorialFinish
_PB_finalizers.append('CDOTAUserMsg_TutorialFinish')

class CDOTAUserMsg_TutorialMinimapPosition(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDOTAUserMsg_TutorialMinimapPosition = CDOTAUserMsg_TutorialMinimapPosition
_PB_finalizers.append('CDOTAUserMsg_TutorialMinimapPosition')

class CDOTAUserMsg_SendGenericToolTip(ProtoBase):
    _required = []
    _field_map = {'close': 4, 'text': 2, 'entindex': 3, 'title': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['title', 'text', 'entindex', 'close']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_title(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'title')
            self._cache[1] = r
        return r

    def _establish_parentage_title(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_title), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_title
                v._pbf_establish_parent_callback = self._establish_parentage_title

    def _set_title(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_title(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field title"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_title(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_title(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "title"

    title = property(_get_title, _set_title, _del_title)

    @property
    def title__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def title__type(self):
        return ProtoBase.TYPE_string

    def _finalize_title(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_title)


    def _get_text(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'text')
            self._cache[2] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_text)


    def _get_entindex(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'entindex')
            self._cache[3] = r
        return r

    def _establish_parentage_entindex(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entindex), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entindex
                v._pbf_establish_parent_callback = self._establish_parentage_entindex

    def _set_entindex(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entindex(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entindex"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_entindex(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "entindex"

    entindex = property(_get_entindex, _set_entindex, _del_entindex)

    @property
    def entindex__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def entindex__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entindex(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_entindex)


    def _get_close(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'close')
            self._cache[4] = r
        return r

    def _establish_parentage_close(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_close), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_close
                v._pbf_establish_parent_callback = self._establish_parentage_close

    def _set_close(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_close(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field close"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_close(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_close(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "close"

    close = property(_get_close, _set_close, _del_close)

    @property
    def close__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def close__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_close(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_close)


TYPE_CDOTAUserMsg_SendGenericToolTip = CDOTAUserMsg_SendGenericToolTip
_PB_finalizers.append('CDOTAUserMsg_SendGenericToolTip')

class CDOTAUserMsg_WorldLine(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'worldline': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'worldline']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_worldline(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_WorldLine, 'worldline')
            self._cache[2] = r
        return r

    def _establish_parentage_worldline(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_worldline), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_worldline
                v._pbf_establish_parent_callback = self._establish_parentage_worldline

    def _set_worldline(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_worldline(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field worldline"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_WorldLine

    def _mod_worldline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_WorldLine

    def _del_worldline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "worldline"

    worldline = property(_get_worldline, _set_worldline, _del_worldline)

    @property
    def worldline__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def worldline__type(self):
        return TYPE_CDOTAMsg_WorldLine

    def _finalize_worldline(cls):
        if is_string(TYPE_CDOTAMsg_WorldLine):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_WorldLine) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_WorldLine, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_WorldLine.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_worldline)


TYPE_CDOTAUserMsg_WorldLine = CDOTAUserMsg_WorldLine
_PB_finalizers.append('CDOTAUserMsg_WorldLine')

class CDOTAUserMsg_TournamentDrop(ProtoBase):
    _required = []
    _field_map = {'winner_name': 1, 'event_type': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['winner_name', 'event_type']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_winner_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'winner_name')
            self._cache[1] = r
        return r

    def _establish_parentage_winner_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_winner_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_winner_name
                v._pbf_establish_parent_callback = self._establish_parentage_winner_name

    def _set_winner_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_winner_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field winner_name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_winner_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_winner_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "winner_name"

    winner_name = property(_get_winner_name, _set_winner_name, _del_winner_name)

    @property
    def winner_name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def winner_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_winner_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_winner_name)


    def _get_event_type(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'event_type')
            self._cache[2] = r
        return r

    def _establish_parentage_event_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_type
                v._pbf_establish_parent_callback = self._establish_parentage_event_type

    def _set_event_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_type"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_event_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_event_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "event_type"

    event_type = property(_get_event_type, _set_event_type, _del_event_type)

    @property
    def event_type__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def event_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_event_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_event_type)


TYPE_CDOTAUserMsg_TournamentDrop = CDOTAUserMsg_TournamentDrop
_PB_finalizers.append('CDOTAUserMsg_TournamentDrop')

class CDOTAUserMsg_ChatWheel(ProtoBase):
    _required = []
    _field_map = {'player_id': 2, 'chat_message': 1, 'param_hero_id': 4, 'account_id': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['chat_message', 'player_id', 'account_id', 'param_hero_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_chat_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_EDOTAChatWheelMessage, 'chat_message')
            except:
                r = k_EDOTA_CW_Ok
            self._cache[1] = r
        return r

    def _establish_parentage_chat_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_chat_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_chat_message
                v._pbf_establish_parent_callback = self._establish_parentage_chat_message

    def _set_chat_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_chat_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field chat_message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_EDOTAChatWheelMessage

    def _mod_chat_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_EDOTAChatWheelMessage

    def _del_chat_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "chat_message"

    chat_message = property(_get_chat_message, _set_chat_message, _del_chat_message)

    @property
    def chat_message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def chat_message__type(self):
        return TYPE_EDOTAChatWheelMessage

    def _finalize_chat_message(cls):
        if is_string(TYPE_EDOTAChatWheelMessage):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_EDOTAChatWheelMessage) is _PB_type:
            assert issubclass(TYPE_EDOTAChatWheelMessage, RepeatedSequence)
            if is_string(TYPE_EDOTAChatWheelMessage.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_chat_message)


    def _get_player_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[2] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_account_id(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'account_id')
            self._cache[3] = r
        return r

    def _establish_parentage_account_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_account_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_account_id
                v._pbf_establish_parent_callback = self._establish_parentage_account_id

    def _set_account_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_account_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field account_id"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_account_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_account_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "account_id"

    account_id = property(_get_account_id, _set_account_id, _del_account_id)

    @property
    def account_id__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def account_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_account_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_account_id)


    def _get_param_hero_id(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_uint32, 'param_hero_id')
            self._cache[4] = r
        return r

    def _establish_parentage_param_hero_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_param_hero_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_param_hero_id
                v._pbf_establish_parent_callback = self._establish_parentage_param_hero_id

    def _set_param_hero_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_param_hero_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field param_hero_id"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_uint32

    def _mod_param_hero_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_uint32

    def _del_param_hero_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "param_hero_id"

    param_hero_id = property(_get_param_hero_id, _set_param_hero_id, _del_param_hero_id)

    @property
    def param_hero_id__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def param_hero_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_param_hero_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_param_hero_id)


TYPE_CDOTAUserMsg_ChatWheel = CDOTAUserMsg_ChatWheel
_PB_finalizers.append('CDOTAUserMsg_ChatWheel')

class CDOTAUserMsg_ReceivedXmasGift(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'item_name': 2, 'inventory_slot': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'item_name', 'inventory_slot']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_item_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'item_name')
            self._cache[2] = r
        return r

    def _establish_parentage_item_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_item_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_item_name
                v._pbf_establish_parent_callback = self._establish_parentage_item_name

    def _set_item_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_item_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field item_name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_item_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_item_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "item_name"

    item_name = property(_get_item_name, _set_item_name, _del_item_name)

    @property
    def item_name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def item_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_item_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_item_name)


    def _get_inventory_slot(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'inventory_slot')
            self._cache[3] = r
        return r

    def _establish_parentage_inventory_slot(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_inventory_slot), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_inventory_slot
                v._pbf_establish_parent_callback = self._establish_parentage_inventory_slot

    def _set_inventory_slot(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_inventory_slot(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field inventory_slot"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_inventory_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_inventory_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "inventory_slot"

    inventory_slot = property(_get_inventory_slot, _set_inventory_slot, _del_inventory_slot)

    @property
    def inventory_slot__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def inventory_slot__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_inventory_slot(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_inventory_slot)


TYPE_CDOTAUserMsg_ReceivedXmasGift = CDOTAUserMsg_ReceivedXmasGift
_PB_finalizers.append('CDOTAUserMsg_ReceivedXmasGift')

class CDOTAUserMsg_ShowSurvey(ProtoBase):
    _required = []
    _field_map = {'response_style': 3, 'survey_id': 1, 'match_id': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['survey_id', 'match_id', 'response_style']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_survey_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'survey_id')
            self._cache[1] = r
        return r

    def _establish_parentage_survey_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_survey_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_survey_id
                v._pbf_establish_parent_callback = self._establish_parentage_survey_id

    def _set_survey_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_survey_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field survey_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_survey_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_survey_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "survey_id"

    survey_id = property(_get_survey_id, _set_survey_id, _del_survey_id)

    @property
    def survey_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def survey_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_survey_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_survey_id)


    def _get_match_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'match_id')
            self._cache[2] = r
        return r

    def _establish_parentage_match_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_match_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_match_id
                v._pbf_establish_parent_callback = self._establish_parentage_match_id

    def _set_match_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_match_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field match_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_match_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_match_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "match_id"

    match_id = property(_get_match_id, _set_match_id, _del_match_id)

    @property
    def match_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def match_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_match_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_match_id)


    def _get_response_style(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'response_style')
            self._cache[3] = r
        return r

    def _establish_parentage_response_style(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_response_style), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_response_style
                v._pbf_establish_parent_callback = self._establish_parentage_response_style

    def _set_response_style(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_response_style(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field response_style"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_response_style(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_response_style(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "response_style"

    response_style = property(_get_response_style, _set_response_style, _del_response_style)

    @property
    def response_style__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def response_style__type(self):
        return ProtoBase.TYPE_string

    def _finalize_response_style(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_response_style)


TYPE_CDOTAUserMsg_ShowSurvey = CDOTAUserMsg_ShowSurvey
_PB_finalizers.append('CDOTAUserMsg_ShowSurvey')

class CDOTAUserMsg_UpdateSharedContent(ProtoBase):
    _required = []
    _field_map = {'slot_type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['slot_type']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_slot_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'slot_type')
            self._cache[1] = r
        return r

    def _establish_parentage_slot_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_slot_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_slot_type
                v._pbf_establish_parent_callback = self._establish_parentage_slot_type

    def _set_slot_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_slot_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field slot_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_slot_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_slot_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "slot_type"

    slot_type = property(_get_slot_type, _set_slot_type, _del_slot_type)

    @property
    def slot_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def slot_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_slot_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_slot_type)


TYPE_CDOTAUserMsg_UpdateSharedContent = CDOTAUserMsg_UpdateSharedContent
_PB_finalizers.append('CDOTAUserMsg_UpdateSharedContent')

class CDOTAUserMsg_TutorialRequestExp(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDOTAUserMsg_TutorialRequestExp = CDOTAUserMsg_TutorialRequestExp
_PB_finalizers.append('CDOTAUserMsg_TutorialRequestExp')

class CDOTAUserMsg_TutorialFade(ProtoBase):
    _required = []
    _field_map = {'tgt_alpha': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['tgt_alpha']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_tgt_alpha(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'tgt_alpha')
            self._cache[1] = r
        return r

    def _establish_parentage_tgt_alpha(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tgt_alpha), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tgt_alpha
                v._pbf_establish_parent_callback = self._establish_parentage_tgt_alpha

    def _set_tgt_alpha(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tgt_alpha(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tgt_alpha"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_tgt_alpha(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_tgt_alpha(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "tgt_alpha"

    tgt_alpha = property(_get_tgt_alpha, _set_tgt_alpha, _del_tgt_alpha)

    @property
    def tgt_alpha__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def tgt_alpha__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_tgt_alpha(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_tgt_alpha)


TYPE_CDOTAUserMsg_TutorialFade = CDOTAUserMsg_TutorialFade
_PB_finalizers.append('CDOTAUserMsg_TutorialFade')

class CDOTAUserMsg_TutorialPingMinimap(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'pos_z': 4, 'pos_x': 2, 'pos_y': 3, 'entity_index': 5}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'pos_x', 'pos_y', 'pos_z', 'entity_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_pos_x(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'pos_x')
            self._cache[2] = r
        return r

    def _establish_parentage_pos_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_pos_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_pos_x
                v._pbf_establish_parent_callback = self._establish_parentage_pos_x

    def _set_pos_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_pos_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field pos_x"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_pos_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_pos_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "pos_x"

    pos_x = property(_get_pos_x, _set_pos_x, _del_pos_x)

    @property
    def pos_x__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def pos_x__type(self):
        return ProtoBase.TYPE_float

    def _finalize_pos_x(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_pos_x)


    def _get_pos_y(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'pos_y')
            self._cache[3] = r
        return r

    def _establish_parentage_pos_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_pos_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_pos_y
                v._pbf_establish_parent_callback = self._establish_parentage_pos_y

    def _set_pos_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_pos_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field pos_y"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_pos_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_pos_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "pos_y"

    pos_y = property(_get_pos_y, _set_pos_y, _del_pos_y)

    @property
    def pos_y__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def pos_y__type(self):
        return ProtoBase.TYPE_float

    def _finalize_pos_y(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_pos_y)


    def _get_pos_z(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_float, 'pos_z')
            self._cache[4] = r
        return r

    def _establish_parentage_pos_z(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_pos_z), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_pos_z
                v._pbf_establish_parent_callback = self._establish_parentage_pos_z

    def _set_pos_z(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_pos_z(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field pos_z"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_float

    def _mod_pos_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_float

    def _del_pos_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "pos_z"

    pos_z = property(_get_pos_z, _set_pos_z, _del_pos_z)

    @property
    def pos_z__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def pos_z__type(self):
        return ProtoBase.TYPE_float

    def _finalize_pos_z(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_pos_z)


    def _get_entity_index(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'entity_index')
            self._cache[5] = r
        return r

    def _establish_parentage_entity_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_index
                v._pbf_establish_parent_callback = self._establish_parentage_entity_index

    def _set_entity_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_index"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "entity_index"

    entity_index = property(_get_entity_index, _set_entity_index, _del_entity_index)

    @property
    def entity_index__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def entity_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_entity_index)


TYPE_CDOTAUserMsg_TutorialPingMinimap = CDOTAUserMsg_TutorialPingMinimap
_PB_finalizers.append('CDOTAUserMsg_TutorialPingMinimap')

class CDOTA_UM_GamerulesStateChanged(ProtoBase):
    _required = []
    _field_map = {'state': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['state']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_state(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'state')
            self._cache[1] = r
        return r

    def _establish_parentage_state(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_state), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_state
                v._pbf_establish_parent_callback = self._establish_parentage_state

    def _set_state(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_state(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field state"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_state(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_state(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "state"

    state = property(_get_state, _set_state, _del_state)

    @property
    def state__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def state__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_state(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_state)


TYPE_CDOTA_UM_GamerulesStateChanged = CDOTA_UM_GamerulesStateChanged
_PB_finalizers.append('CDOTA_UM_GamerulesStateChanged')

class CDOTAUserMsg_AddQuestLogEntry(ProtoBase):
    _required = []
    _field_map = {'npc_name': 1, 'npc_dialog': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['npc_name', 'npc_dialog']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_npc_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'npc_name')
            self._cache[1] = r
        return r

    def _establish_parentage_npc_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_npc_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_npc_name
                v._pbf_establish_parent_callback = self._establish_parentage_npc_name

    def _set_npc_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_npc_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field npc_name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_npc_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_npc_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "npc_name"

    npc_name = property(_get_npc_name, _set_npc_name, _del_npc_name)

    @property
    def npc_name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def npc_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_npc_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_npc_name)


    def _get_npc_dialog(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'npc_dialog')
            self._cache[2] = r
        return r

    def _establish_parentage_npc_dialog(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_npc_dialog), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_npc_dialog
                v._pbf_establish_parent_callback = self._establish_parentage_npc_dialog

    def _set_npc_dialog(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_npc_dialog(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field npc_dialog"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_npc_dialog(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_npc_dialog(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "npc_dialog"

    npc_dialog = property(_get_npc_dialog, _set_npc_dialog, _del_npc_dialog)

    @property
    def npc_dialog__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def npc_dialog__type(self):
        return ProtoBase.TYPE_string

    def _finalize_npc_dialog(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_npc_dialog)


TYPE_CDOTAUserMsg_AddQuestLogEntry = CDOTAUserMsg_AddQuestLogEntry
_PB_finalizers.append('CDOTAUserMsg_AddQuestLogEntry')

class CDOTAUserMsg_SendStatPopup(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'statpopup': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'statpopup']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_statpopup(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_SendStatPopup, 'statpopup')
            self._cache[2] = r
        return r

    def _establish_parentage_statpopup(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_statpopup), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_statpopup
                v._pbf_establish_parent_callback = self._establish_parentage_statpopup

    def _set_statpopup(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_statpopup(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field statpopup"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_SendStatPopup

    def _mod_statpopup(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_SendStatPopup

    def _del_statpopup(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "statpopup"

    statpopup = property(_get_statpopup, _set_statpopup, _del_statpopup)

    @property
    def statpopup__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def statpopup__type(self):
        return TYPE_CDOTAMsg_SendStatPopup

    def _finalize_statpopup(cls):
        if is_string(TYPE_CDOTAMsg_SendStatPopup):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_SendStatPopup) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_SendStatPopup, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_SendStatPopup.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_statpopup)


TYPE_CDOTAUserMsg_SendStatPopup = CDOTAUserMsg_SendStatPopup
_PB_finalizers.append('CDOTAUserMsg_SendStatPopup')

class CDOTAUserMsg_SendRoshanPopup(ProtoBase):
    _required = []
    _field_map = {'gametime': 2, 'reclaimed': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['reclaimed', 'gametime']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_reclaimed(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'reclaimed')
            self._cache[1] = r
        return r

    def _establish_parentage_reclaimed(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_reclaimed), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_reclaimed
                v._pbf_establish_parent_callback = self._establish_parentage_reclaimed

    def _set_reclaimed(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_reclaimed(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field reclaimed"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_reclaimed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_reclaimed(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "reclaimed"

    reclaimed = property(_get_reclaimed, _set_reclaimed, _del_reclaimed)

    @property
    def reclaimed__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def reclaimed__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_reclaimed(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_reclaimed)


    def _get_gametime(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'gametime')
            self._cache[2] = r
        return r

    def _establish_parentage_gametime(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_gametime), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_gametime
                v._pbf_establish_parent_callback = self._establish_parentage_gametime

    def _set_gametime(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_gametime(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field gametime"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_gametime(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_gametime(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "gametime"

    gametime = property(_get_gametime, _set_gametime, _del_gametime)

    @property
    def gametime__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def gametime__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_gametime(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_gametime)


TYPE_CDOTAUserMsg_SendRoshanPopup = CDOTAUserMsg_SendRoshanPopup
_PB_finalizers.append('CDOTAUserMsg_SendRoshanPopup')

class CDOTAUserMsg_SendFinalGold(ProtoBase):
    _required = []
    _field_map = {'reliable_gold': 1, 'unreliable_gold': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['reliable_gold', 'unreliable_gold']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_reliable_gold(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_uint32
        pb_subtype = pb_subtype()


    TYPE_Repeated_reliable_gold = Repeated_reliable_gold


    def _get_reliable_gold(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_reliable_gold, 'reliable_gold')
            self._cache[1] = r
        return r

    def _establish_parentage_reliable_gold(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_reliable_gold), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_reliable_gold
                v._pbf_establish_parent_callback = self._establish_parentage_reliable_gold

    def _set_reliable_gold(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_reliable_gold(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field reliable_gold"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_reliable_gold

    def _mod_reliable_gold(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_reliable_gold

    def _del_reliable_gold(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "reliable_gold"

    reliable_gold = property(_get_reliable_gold, _set_reliable_gold, _del_reliable_gold)

    @property
    def reliable_gold__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def reliable_gold__type(self):
        return self.TYPE_Repeated_reliable_gold

    def _finalize_reliable_gold(cls):
        if is_string(cls.TYPE_Repeated_reliable_gold):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_reliable_gold) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_reliable_gold, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_reliable_gold.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_reliable_gold)


    class Repeated_unreliable_gold(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_uint32
        pb_subtype = pb_subtype()


    TYPE_Repeated_unreliable_gold = Repeated_unreliable_gold


    def _get_unreliable_gold(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_unreliable_gold, 'unreliable_gold')
            self._cache[2] = r
        return r

    def _establish_parentage_unreliable_gold(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_unreliable_gold), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_unreliable_gold
                v._pbf_establish_parent_callback = self._establish_parentage_unreliable_gold

    def _set_unreliable_gold(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_unreliable_gold(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field unreliable_gold"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_unreliable_gold

    def _mod_unreliable_gold(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_unreliable_gold

    def _del_unreliable_gold(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "unreliable_gold"

    unreliable_gold = property(_get_unreliable_gold, _set_unreliable_gold, _del_unreliable_gold)

    @property
    def unreliable_gold__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def unreliable_gold__type(self):
        return self.TYPE_Repeated_unreliable_gold

    def _finalize_unreliable_gold(cls):
        if is_string(cls.TYPE_Repeated_unreliable_gold):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_unreliable_gold) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_unreliable_gold, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_unreliable_gold.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_unreliable_gold)


TYPE_CDOTAUserMsg_SendFinalGold = CDOTAUserMsg_SendFinalGold
_PB_finalizers.append('CDOTAUserMsg_SendFinalGold')

class CDOTAUserMsg_CustomMsg(ProtoBase):
    _required = []
    _field_map = {'player_id': 2, 'message': 1, 'value': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message', 'player_id', 'value']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


    def _get_player_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'player_id')
            self._cache[2] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_value(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'value')
            self._cache[3] = r
        return r

    def _establish_parentage_value(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_value
                v._pbf_establish_parent_callback = self._establish_parentage_value

    def _set_value(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_value(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field value"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "value"

    value = property(_get_value, _set_value, _del_value)

    @property
    def value__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def value__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_value(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_value)


TYPE_CDOTAUserMsg_CustomMsg = CDOTAUserMsg_CustomMsg
_PB_finalizers.append('CDOTAUserMsg_CustomMsg')

class CDOTAUserMsg_CoachHUDPing(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'hud_ping': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'hud_ping']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_hud_ping(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CDOTAMsg_CoachHUDPing, 'hud_ping')
            self._cache[2] = r
        return r

    def _establish_parentage_hud_ping(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hud_ping), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hud_ping
                v._pbf_establish_parent_callback = self._establish_parentage_hud_ping

    def _set_hud_ping(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hud_ping(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hud_ping"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CDOTAMsg_CoachHUDPing

    def _mod_hud_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CDOTAMsg_CoachHUDPing

    def _del_hud_ping(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "hud_ping"

    hud_ping = property(_get_hud_ping, _set_hud_ping, _del_hud_ping)

    @property
    def hud_ping__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def hud_ping__type(self):
        return TYPE_CDOTAMsg_CoachHUDPing

    def _finalize_hud_ping(cls):
        if is_string(TYPE_CDOTAMsg_CoachHUDPing):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CDOTAMsg_CoachHUDPing) is _PB_type:
            assert issubclass(TYPE_CDOTAMsg_CoachHUDPing, RepeatedSequence)
            if is_string(TYPE_CDOTAMsg_CoachHUDPing.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_hud_ping)


TYPE_CDOTAUserMsg_CoachHUDPing = CDOTAUserMsg_CoachHUDPing
_PB_finalizers.append('CDOTAUserMsg_CoachHUDPing')

class CDOTAUserMsg_ClientLoadGridNav(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CDOTAUserMsg_ClientLoadGridNav = CDOTAUserMsg_ClientLoadGridNav
_PB_finalizers.append('CDOTAUserMsg_ClientLoadGridNav')

class CDOTAUserMsg_AbilityPing(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'ability_id': 2, 'type': 3, 'cooldown_seconds': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'ability_id', 'type', 'cooldown_seconds']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_ability_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'ability_id')
            self._cache[2] = r
        return r

    def _establish_parentage_ability_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ability_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ability_id
                v._pbf_establish_parent_callback = self._establish_parentage_ability_id

    def _set_ability_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ability_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ability_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_ability_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_ability_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "ability_id"

    ability_id = property(_get_ability_id, _set_ability_id, _del_ability_id)

    @property
    def ability_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def ability_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_ability_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_ability_id)


    def _get_type(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            try:
                r = self._buf_get(3, TYPE_DOTA_ABILITY_PING_TYPE, 'type')
            except:
                r = ABILITY_PING_READY
            self._cache[3] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_DOTA_ABILITY_PING_TYPE

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_DOTA_ABILITY_PING_TYPE

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def type__type(self):
        return TYPE_DOTA_ABILITY_PING_TYPE

    def _finalize_type(cls):
        if is_string(TYPE_DOTA_ABILITY_PING_TYPE):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_DOTA_ABILITY_PING_TYPE) is _PB_type:
            assert issubclass(TYPE_DOTA_ABILITY_PING_TYPE, RepeatedSequence)
            if is_string(TYPE_DOTA_ABILITY_PING_TYPE.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_type)


    def _get_cooldown_seconds(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_uint32, 'cooldown_seconds')
            self._cache[4] = r
        return r

    def _establish_parentage_cooldown_seconds(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cooldown_seconds), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cooldown_seconds
                v._pbf_establish_parent_callback = self._establish_parentage_cooldown_seconds

    def _set_cooldown_seconds(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cooldown_seconds(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cooldown_seconds"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_uint32

    def _mod_cooldown_seconds(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_uint32

    def _del_cooldown_seconds(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "cooldown_seconds"

    cooldown_seconds = property(_get_cooldown_seconds, _set_cooldown_seconds, _del_cooldown_seconds)

    @property
    def cooldown_seconds__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def cooldown_seconds__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_cooldown_seconds(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_cooldown_seconds)


TYPE_CDOTAUserMsg_AbilityPing = CDOTAUserMsg_AbilityPing
_PB_finalizers.append('CDOTAUserMsg_AbilityPing')

class CDOTAUserMsg_ShowGenericPopup(ProtoBase):
    _required = [1, 2]
    _field_map = {'body': 2, 'tint_screen': 5, 'show_no_other_dialogs': 6, 'header': 1, 'param2': 4, 'param1': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['header', 'body', 'param1', 'param2', 'tint_screen', 'show_no_other_dialogs']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_header(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'header')
            self._cache[1] = r
        return r

    def _establish_parentage_header(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_header), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_header
                v._pbf_establish_parent_callback = self._establish_parentage_header

    def _set_header(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_header(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field header"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_header(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_header(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "header"

    header = property(_get_header, _set_header, _del_header)

    @property
    def header__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def header__type(self):
        return ProtoBase.TYPE_string

    def _finalize_header(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_header)


    def _get_body(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'body')
            self._cache[2] = r
        return r

    def _establish_parentage_body(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_body), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_body
                v._pbf_establish_parent_callback = self._establish_parentage_body

    def _set_body(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_body(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field body"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_body(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_body(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "body"

    body = property(_get_body, _set_body, _del_body)

    @property
    def body__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def body__type(self):
        return ProtoBase.TYPE_string

    def _finalize_body(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_body)


    def _get_param1(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'param1')
            self._cache[3] = r
        return r

    def _establish_parentage_param1(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_param1), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_param1
                v._pbf_establish_parent_callback = self._establish_parentage_param1

    def _set_param1(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_param1(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field param1"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_param1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_param1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "param1"

    param1 = property(_get_param1, _set_param1, _del_param1)

    @property
    def param1__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def param1__type(self):
        return ProtoBase.TYPE_string

    def _finalize_param1(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_param1)


    def _get_param2(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'param2')
            self._cache[4] = r
        return r

    def _establish_parentage_param2(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_param2), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_param2
                v._pbf_establish_parent_callback = self._establish_parentage_param2

    def _set_param2(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_param2(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field param2"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_param2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_param2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "param2"

    param2 = property(_get_param2, _set_param2, _del_param2)

    @property
    def param2__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def param2__type(self):
        return ProtoBase.TYPE_string

    def _finalize_param2(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_param2)


    def _get_tint_screen(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bool, 'tint_screen')
            self._cache[5] = r
        return r

    def _establish_parentage_tint_screen(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tint_screen), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tint_screen
                v._pbf_establish_parent_callback = self._establish_parentage_tint_screen

    def _set_tint_screen(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tint_screen(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tint_screen"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bool

    def _mod_tint_screen(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bool

    def _del_tint_screen(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "tint_screen"

    tint_screen = property(_get_tint_screen, _set_tint_screen, _del_tint_screen)

    @property
    def tint_screen__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def tint_screen__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_tint_screen(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_tint_screen)


    def _get_show_no_other_dialogs(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_bool, 'show_no_other_dialogs')
            self._cache[6] = r
        return r

    def _establish_parentage_show_no_other_dialogs(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_show_no_other_dialogs), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_show_no_other_dialogs
                v._pbf_establish_parent_callback = self._establish_parentage_show_no_other_dialogs

    def _set_show_no_other_dialogs(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_show_no_other_dialogs(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field show_no_other_dialogs"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_bool

    def _mod_show_no_other_dialogs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_bool

    def _del_show_no_other_dialogs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "show_no_other_dialogs"

    show_no_other_dialogs = property(_get_show_no_other_dialogs, _set_show_no_other_dialogs, _del_show_no_other_dialogs)

    @property
    def show_no_other_dialogs__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def show_no_other_dialogs__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_show_no_other_dialogs(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_show_no_other_dialogs)


TYPE_CDOTAUserMsg_ShowGenericPopup = CDOTAUserMsg_ShowGenericPopup
_PB_finalizers.append('CDOTAUserMsg_ShowGenericPopup')

class CDOTAUserMsg_VoteStart(ProtoBase):
    _required = []
    _field_map = {'duration': 2, 'choices': 4, 'choice_count': 3, 'title': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['title', 'duration', 'choice_count', 'choices']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_title(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'title')
            self._cache[1] = r
        return r

    def _establish_parentage_title(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_title), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_title
                v._pbf_establish_parent_callback = self._establish_parentage_title

    def _set_title(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_title(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field title"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_title(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_title(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "title"

    title = property(_get_title, _set_title, _del_title)

    @property
    def title__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def title__type(self):
        return ProtoBase.TYPE_string

    def _finalize_title(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_title)


    def _get_duration(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'duration')
            self._cache[2] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_duration)


    def _get_choice_count(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'choice_count')
            self._cache[3] = r
        return r

    def _establish_parentage_choice_count(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_choice_count), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_choice_count
                v._pbf_establish_parent_callback = self._establish_parentage_choice_count

    def _set_choice_count(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_choice_count(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field choice_count"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_choice_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_choice_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "choice_count"

    choice_count = property(_get_choice_count, _set_choice_count, _del_choice_count)

    @property
    def choice_count__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def choice_count__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_choice_count(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_choice_count)


    class Repeated_choices(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_choices = Repeated_choices


    def _get_choices(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, self.TYPE_Repeated_choices, 'choices')
            self._cache[4] = r
        return r

    def _establish_parentage_choices(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_choices), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_choices
                v._pbf_establish_parent_callback = self._establish_parentage_choices

    def _set_choices(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_choices(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field choices"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = self.TYPE_Repeated_choices

    def _mod_choices(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = self.TYPE_Repeated_choices

    def _del_choices(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "choices"

    choices = property(_get_choices, _set_choices, _del_choices)

    @property
    def choices__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def choices__type(self):
        return self.TYPE_Repeated_choices

    def _finalize_choices(cls):
        if is_string(cls.TYPE_Repeated_choices):
            cls._pbf_strings.append(4)
        elif _PB_type(cls.TYPE_Repeated_choices) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_choices, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_choices.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_choices)


TYPE_CDOTAUserMsg_VoteStart = CDOTAUserMsg_VoteStart
_PB_finalizers.append('CDOTAUserMsg_VoteStart')

class CDOTAUserMsg_VoteUpdate(ProtoBase):
    _required = []
    _field_map = {'choice_counts': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['choice_counts']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_choice_counts(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_int32
        pb_subtype = pb_subtype()


    TYPE_Repeated_choice_counts = Repeated_choice_counts


    def _get_choice_counts(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_choice_counts, 'choice_counts')
            self._cache[1] = r
        return r

    def _establish_parentage_choice_counts(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_choice_counts), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_choice_counts
                v._pbf_establish_parent_callback = self._establish_parentage_choice_counts

    def _set_choice_counts(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_choice_counts(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field choice_counts"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_choice_counts

    def _mod_choice_counts(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_choice_counts

    def _del_choice_counts(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "choice_counts"

    choice_counts = property(_get_choice_counts, _set_choice_counts, _del_choice_counts)

    @property
    def choice_counts__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def choice_counts__type(self):
        return self.TYPE_Repeated_choice_counts

    def _finalize_choice_counts(cls):
        if is_string(cls.TYPE_Repeated_choice_counts):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_choice_counts) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_choice_counts, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_choice_counts.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_choice_counts)


TYPE_CDOTAUserMsg_VoteUpdate = CDOTAUserMsg_VoteUpdate
_PB_finalizers.append('CDOTAUserMsg_VoteUpdate')

class CDOTAUserMsg_VoteEnd(ProtoBase):
    _required = []
    _field_map = {'selected_choice': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['selected_choice']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_selected_choice(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'selected_choice')
            self._cache[1] = r
        return r

    def _establish_parentage_selected_choice(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_selected_choice), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_selected_choice
                v._pbf_establish_parent_callback = self._establish_parentage_selected_choice

    def _set_selected_choice(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_selected_choice(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field selected_choice"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_selected_choice(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_selected_choice(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "selected_choice"

    selected_choice = property(_get_selected_choice, _set_selected_choice, _del_selected_choice)

    @property
    def selected_choice__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def selected_choice__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_selected_choice(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_selected_choice)


TYPE_CDOTAUserMsg_VoteEnd = CDOTAUserMsg_VoteEnd
_PB_finalizers.append('CDOTAUserMsg_VoteEnd')

class CDOTAUserMsg_BoosterStatePlayer(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'bonus': 2, 'bonus_item_id': 4, 'event_bonus_item_id': 5, 'event_bonus': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'bonus', 'event_bonus', 'bonus_item_id', 'event_bonus_item_id']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_bonus(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'bonus')
            self._cache[2] = r
        return r

    def _establish_parentage_bonus(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_bonus), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_bonus
                v._pbf_establish_parent_callback = self._establish_parentage_bonus

    def _set_bonus(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_bonus(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field bonus"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_bonus(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_bonus(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "bonus"

    bonus = property(_get_bonus, _set_bonus, _del_bonus)

    @property
    def bonus__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def bonus__type(self):
        return ProtoBase.TYPE_float

    def _finalize_bonus(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_bonus)


    def _get_event_bonus(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'event_bonus')
            self._cache[3] = r
        return r

    def _establish_parentage_event_bonus(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_bonus), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_bonus
                v._pbf_establish_parent_callback = self._establish_parentage_event_bonus

    def _set_event_bonus(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_bonus(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_bonus"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_event_bonus(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_event_bonus(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "event_bonus"

    event_bonus = property(_get_event_bonus, _set_event_bonus, _del_event_bonus)

    @property
    def event_bonus__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def event_bonus__type(self):
        return ProtoBase.TYPE_float

    def _finalize_event_bonus(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_event_bonus)


    def _get_bonus_item_id(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_uint32, 'bonus_item_id')
            self._cache[4] = r
        return r

    def _establish_parentage_bonus_item_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_bonus_item_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_bonus_item_id
                v._pbf_establish_parent_callback = self._establish_parentage_bonus_item_id

    def _set_bonus_item_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_bonus_item_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field bonus_item_id"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_uint32

    def _mod_bonus_item_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_uint32

    def _del_bonus_item_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "bonus_item_id"

    bonus_item_id = property(_get_bonus_item_id, _set_bonus_item_id, _del_bonus_item_id)

    @property
    def bonus_item_id__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def bonus_item_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_bonus_item_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_bonus_item_id)


    def _get_event_bonus_item_id(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_uint32, 'event_bonus_item_id')
            self._cache[5] = r
        return r

    def _establish_parentage_event_bonus_item_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_bonus_item_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_bonus_item_id
                v._pbf_establish_parent_callback = self._establish_parentage_event_bonus_item_id

    def _set_event_bonus_item_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_bonus_item_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_bonus_item_id"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_uint32

    def _mod_event_bonus_item_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_uint32

    def _del_event_bonus_item_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "event_bonus_item_id"

    event_bonus_item_id = property(_get_event_bonus_item_id, _set_event_bonus_item_id, _del_event_bonus_item_id)

    @property
    def event_bonus_item_id__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def event_bonus_item_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_event_bonus_item_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_event_bonus_item_id)


TYPE_CDOTAUserMsg_BoosterStatePlayer = CDOTAUserMsg_BoosterStatePlayer
_PB_finalizers.append('CDOTAUserMsg_BoosterStatePlayer')

class CDOTAUserMsg_BoosterState(ProtoBase):
    _required = []
    _field_map = {'boosted_players': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['boosted_players']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_boosted_players(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return TYPE_CDOTAUserMsg_BoosterStatePlayer
        pb_subtype = pb_subtype()


    TYPE_Repeated_boosted_players = Repeated_boosted_players


    @property
    def boosted_players__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_boosted_players, "boosted_players", lazy=True)

    def boosted_players__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_boosted_players, value)

    def _get_boosted_players(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_boosted_players, 'boosted_players')
            self._cache[1] = r
        return r

    def _establish_parentage_boosted_players(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_boosted_players), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_boosted_players
                v._pbf_establish_parent_callback = self._establish_parentage_boosted_players

    def _set_boosted_players(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_boosted_players(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field boosted_players"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_boosted_players

    def _mod_boosted_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_boosted_players

    def _del_boosted_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "boosted_players"

    boosted_players = property(_get_boosted_players, _set_boosted_players, _del_boosted_players)

    @property
    def boosted_players__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def boosted_players__type(self):
        return self.TYPE_Repeated_boosted_players

    def _finalize_boosted_players(cls):
        if is_string(cls.TYPE_Repeated_boosted_players):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_boosted_players) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_boosted_players, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_boosted_players.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_boosted_players)


TYPE_CDOTAUserMsg_BoosterState = CDOTAUserMsg_BoosterState
_PB_finalizers.append('CDOTAUserMsg_BoosterState')

class CDOTAUserMsg_PlayerMMR(ProtoBase):
    _required = []
    _field_map = {'mmr': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['mmr']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_mmr(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_sint32
        pb_subtype = pb_subtype()


    TYPE_Repeated_mmr = Repeated_mmr


    def _get_mmr(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_mmr, 'mmr')
            self._cache[1] = r
        return r

    def _establish_parentage_mmr(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_mmr), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_mmr
                v._pbf_establish_parent_callback = self._establish_parentage_mmr

    def _set_mmr(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_mmr(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field mmr"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_mmr

    def _mod_mmr(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_mmr

    def _del_mmr(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "mmr"

    mmr = property(_get_mmr, _set_mmr, _del_mmr)

    @property
    def mmr__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def mmr__type(self):
        return self.TYPE_Repeated_mmr

    def _finalize_mmr(cls):
        if is_string(cls.TYPE_Repeated_mmr):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_mmr) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_mmr, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_mmr.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_mmr)


TYPE_CDOTAUserMsg_PlayerMMR = CDOTAUserMsg_PlayerMMR
_PB_finalizers.append('CDOTAUserMsg_PlayerMMR')

class CDOTAUserMsg_AbilitySteal(ProtoBase):
    _required = []
    _field_map = {'player_id': 1, 'ability_id': 2, 'ability_level': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player_id', 'ability_id', 'ability_level']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'player_id')
            self._cache[1] = r
        return r

    def _establish_parentage_player_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_id
                v._pbf_establish_parent_callback = self._establish_parentage_player_id

    def _set_player_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_player_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player_id"

    player_id = property(_get_player_id, _set_player_id, _del_player_id)

    @property
    def player_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_player_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player_id)


    def _get_ability_id(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'ability_id')
            self._cache[2] = r
        return r

    def _establish_parentage_ability_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ability_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ability_id
                v._pbf_establish_parent_callback = self._establish_parentage_ability_id

    def _set_ability_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ability_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ability_id"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_ability_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_ability_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "ability_id"

    ability_id = property(_get_ability_id, _set_ability_id, _del_ability_id)

    @property
    def ability_id__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def ability_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_ability_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_ability_id)


    def _get_ability_level(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'ability_level')
            self._cache[3] = r
        return r

    def _establish_parentage_ability_level(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ability_level), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ability_level
                v._pbf_establish_parent_callback = self._establish_parentage_ability_level

    def _set_ability_level(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ability_level(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ability_level"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_ability_level(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_ability_level(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "ability_level"

    ability_level = property(_get_ability_level, _set_ability_level, _del_ability_level)

    @property
    def ability_level__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def ability_level__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_ability_level(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_ability_level)


TYPE_CDOTAUserMsg_AbilitySteal = CDOTAUserMsg_AbilitySteal
_PB_finalizers.append('CDOTAUserMsg_AbilitySteal')

class CMsg_CVars(ProtoBase):
    _required = []
    _field_map = {'cvars': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['cvars']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class CVar(ProtoBase):
        _required = []
        _field_map = {'name': 1, 'value': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['name', 'value']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_name(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
                self._cache[1] = r
            return r
    
        def _establish_parentage_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_name
                    v._pbf_establish_parent_callback = self._establish_parentage_name
    
        def _set_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field name"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_string
    
        def _mod_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_string
    
        def _del_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "name"
    
        name = property(_get_name, _set_name, _del_name)
    
        @property
        def name__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_name)
    
        
        def _get_value(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'value')
                self._cache[2] = r
            return r
    
        def _establish_parentage_value(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_value
                    v._pbf_establish_parent_callback = self._establish_parentage_value
    
        def _set_value(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_value(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field value"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "value"
    
        value = property(_get_value, _set_value, _del_value)
    
        @property
        def value__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def value__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_value(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_value)
    
        
    TYPE_CVar = CVar
    _PB_finalizers.append('CMsg_CVars.CVar')
    
    TYPE_CVar = CVar

    class Repeated_cvars(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CMsg_CVars.TYPE_CVar
        pb_subtype = pb_subtype()


    TYPE_Repeated_cvars = Repeated_cvars


    @property
    def cvars__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_cvars, "cvars", lazy=True)

    def cvars__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_cvars, value)

    def _get_cvars(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_cvars, 'cvars')
            self._cache[1] = r
        return r

    def _establish_parentage_cvars(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cvars), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cvars
                v._pbf_establish_parent_callback = self._establish_parentage_cvars

    def _set_cvars(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cvars(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cvars"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_cvars

    def _mod_cvars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_cvars

    def _del_cvars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "cvars"

    cvars = property(_get_cvars, _set_cvars, _del_cvars)

    @property
    def cvars__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def cvars__type(self):
        return self.TYPE_Repeated_cvars

    def _finalize_cvars(cls):
        if is_string(cls.TYPE_Repeated_cvars):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_cvars) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_cvars, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_cvars.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_cvars)


TYPE_CMsg_CVars = CMsg_CVars
_PB_finalizers.append('CMsg_CVars')

class CNETMsg_NOP(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CNETMsg_NOP = CNETMsg_NOP
_PB_finalizers.append('CNETMsg_NOP')

class CNETMsg_Disconnect(ProtoBase):
    _required = []
    _field_map = {'reason': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['reason']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_reason(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            try:
                r = self._buf_get(2, TYPE_ENetworkDisconnectionReason, 'reason')
            except:
                r = NETWORK_DISCONNECT_INVALID
            self._cache[2] = r
        return r

    def _establish_parentage_reason(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_reason), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_reason
                v._pbf_establish_parent_callback = self._establish_parentage_reason

    def _set_reason(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_reason(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field reason"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_ENetworkDisconnectionReason

    def _mod_reason(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_ENetworkDisconnectionReason

    def _del_reason(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "reason"

    reason = property(_get_reason, _set_reason, _del_reason)

    @property
    def reason__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def reason__type(self):
        return TYPE_ENetworkDisconnectionReason

    def _finalize_reason(cls):
        if is_string(TYPE_ENetworkDisconnectionReason):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_ENetworkDisconnectionReason) is _PB_type:
            assert issubclass(TYPE_ENetworkDisconnectionReason, RepeatedSequence)
            if is_string(TYPE_ENetworkDisconnectionReason.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_reason)


TYPE_CNETMsg_Disconnect = CNETMsg_Disconnect
_PB_finalizers.append('CNETMsg_Disconnect')

class CNETMsg_File(ProtoBase):
    _required = []
    _field_map = {'transfer_id': 1, 'file_name': 2, 'deny': 4, 'is_replay_demo_file': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['transfer_id', 'file_name', 'is_replay_demo_file', 'deny']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_transfer_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'transfer_id')
            self._cache[1] = r
        return r

    def _establish_parentage_transfer_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_transfer_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_transfer_id
                v._pbf_establish_parent_callback = self._establish_parentage_transfer_id

    def _set_transfer_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_transfer_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field transfer_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_transfer_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_transfer_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "transfer_id"

    transfer_id = property(_get_transfer_id, _set_transfer_id, _del_transfer_id)

    @property
    def transfer_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def transfer_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_transfer_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_transfer_id)


    def _get_file_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'file_name')
            self._cache[2] = r
        return r

    def _establish_parentage_file_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_file_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_file_name
                v._pbf_establish_parent_callback = self._establish_parentage_file_name

    def _set_file_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_file_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field file_name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_file_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_file_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "file_name"

    file_name = property(_get_file_name, _set_file_name, _del_file_name)

    @property
    def file_name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def file_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_file_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_file_name)


    def _get_is_replay_demo_file(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'is_replay_demo_file')
            self._cache[3] = r
        return r

    def _establish_parentage_is_replay_demo_file(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_replay_demo_file), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_replay_demo_file
                v._pbf_establish_parent_callback = self._establish_parentage_is_replay_demo_file

    def _set_is_replay_demo_file(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_replay_demo_file(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_replay_demo_file"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_is_replay_demo_file(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_is_replay_demo_file(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "is_replay_demo_file"

    is_replay_demo_file = property(_get_is_replay_demo_file, _set_is_replay_demo_file, _del_is_replay_demo_file)

    @property
    def is_replay_demo_file__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def is_replay_demo_file__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_replay_demo_file(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_is_replay_demo_file)


    def _get_deny(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'deny')
            self._cache[4] = r
        return r

    def _establish_parentage_deny(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_deny), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_deny
                v._pbf_establish_parent_callback = self._establish_parentage_deny

    def _set_deny(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_deny(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field deny"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_deny(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_deny(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "deny"

    deny = property(_get_deny, _set_deny, _del_deny)

    @property
    def deny__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def deny__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_deny(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_deny)


TYPE_CNETMsg_File = CNETMsg_File
_PB_finalizers.append('CNETMsg_File')

class CNETMsg_SplitScreenUser(ProtoBase):
    _required = []
    _field_map = {'slot': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['slot']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_slot(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'slot')
            self._cache[1] = r
        return r

    def _establish_parentage_slot(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_slot), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_slot
                v._pbf_establish_parent_callback = self._establish_parentage_slot

    def _set_slot(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_slot(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field slot"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "slot"

    slot = property(_get_slot, _set_slot, _del_slot)

    @property
    def slot__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def slot__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_slot(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_slot)


TYPE_CNETMsg_SplitScreenUser = CNETMsg_SplitScreenUser
_PB_finalizers.append('CNETMsg_SplitScreenUser')

class CNETMsg_Tick(ProtoBase):
    _required = []
    _field_map = {'host_computationtime': 4, 'tick': 1, 'host_framestarttime_std_deviation': 6, 'host_computationtime_std_deviation': 5}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['tick', 'host_computationtime', 'host_computationtime_std_deviation', 'host_framestarttime_std_deviation']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_tick(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'tick')
            self._cache[1] = r
        return r

    def _establish_parentage_tick(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tick), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tick
                v._pbf_establish_parent_callback = self._establish_parentage_tick

    def _set_tick(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tick(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tick"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "tick"

    tick = property(_get_tick, _set_tick, _del_tick)

    @property
    def tick__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def tick__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_tick(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_tick)


    def _get_host_computationtime(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_uint32, 'host_computationtime')
            self._cache[4] = r
        return r

    def _establish_parentage_host_computationtime(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_host_computationtime), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_host_computationtime
                v._pbf_establish_parent_callback = self._establish_parentage_host_computationtime

    def _set_host_computationtime(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_host_computationtime(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field host_computationtime"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_uint32

    def _mod_host_computationtime(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_uint32

    def _del_host_computationtime(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "host_computationtime"

    host_computationtime = property(_get_host_computationtime, _set_host_computationtime, _del_host_computationtime)

    @property
    def host_computationtime__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def host_computationtime__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_host_computationtime(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_host_computationtime)


    def _get_host_computationtime_std_deviation(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_uint32, 'host_computationtime_std_deviation')
            self._cache[5] = r
        return r

    def _establish_parentage_host_computationtime_std_deviation(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_host_computationtime_std_deviation), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_host_computationtime_std_deviation
                v._pbf_establish_parent_callback = self._establish_parentage_host_computationtime_std_deviation

    def _set_host_computationtime_std_deviation(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_host_computationtime_std_deviation(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field host_computationtime_std_deviation"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_uint32

    def _mod_host_computationtime_std_deviation(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_uint32

    def _del_host_computationtime_std_deviation(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "host_computationtime_std_deviation"

    host_computationtime_std_deviation = property(_get_host_computationtime_std_deviation, _set_host_computationtime_std_deviation, _del_host_computationtime_std_deviation)

    @property
    def host_computationtime_std_deviation__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def host_computationtime_std_deviation__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_host_computationtime_std_deviation(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_host_computationtime_std_deviation)


    def _get_host_framestarttime_std_deviation(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_uint32, 'host_framestarttime_std_deviation')
            self._cache[6] = r
        return r

    def _establish_parentage_host_framestarttime_std_deviation(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_host_framestarttime_std_deviation), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_host_framestarttime_std_deviation
                v._pbf_establish_parent_callback = self._establish_parentage_host_framestarttime_std_deviation

    def _set_host_framestarttime_std_deviation(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_host_framestarttime_std_deviation(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field host_framestarttime_std_deviation"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_uint32

    def _mod_host_framestarttime_std_deviation(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_uint32

    def _del_host_framestarttime_std_deviation(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "host_framestarttime_std_deviation"

    host_framestarttime_std_deviation = property(_get_host_framestarttime_std_deviation, _set_host_framestarttime_std_deviation, _del_host_framestarttime_std_deviation)

    @property
    def host_framestarttime_std_deviation__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def host_framestarttime_std_deviation__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_host_framestarttime_std_deviation(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_host_framestarttime_std_deviation)


TYPE_CNETMsg_Tick = CNETMsg_Tick
_PB_finalizers.append('CNETMsg_Tick')

class CNETMsg_StringCmd(ProtoBase):
    _required = []
    _field_map = {'command': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['command']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_command(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'command')
            self._cache[1] = r
        return r

    def _establish_parentage_command(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_command), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_command
                v._pbf_establish_parent_callback = self._establish_parentage_command

    def _set_command(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_command(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field command"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "command"

    command = property(_get_command, _set_command, _del_command)

    @property
    def command__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def command__type(self):
        return ProtoBase.TYPE_string

    def _finalize_command(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_command)


TYPE_CNETMsg_StringCmd = CNETMsg_StringCmd
_PB_finalizers.append('CNETMsg_StringCmd')

class CNETMsg_SetConVar(ProtoBase):
    _required = []
    _field_map = {'convars': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['convars']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_convars(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsg_CVars, 'convars')
            self._cache[1] = r
        return r

    def _establish_parentage_convars(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_convars), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_convars
                v._pbf_establish_parent_callback = self._establish_parentage_convars

    def _set_convars(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_convars(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field convars"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsg_CVars

    def _mod_convars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsg_CVars

    def _del_convars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "convars"

    convars = property(_get_convars, _set_convars, _del_convars)

    @property
    def convars__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def convars__type(self):
        return TYPE_CMsg_CVars

    def _finalize_convars(cls):
        if is_string(TYPE_CMsg_CVars):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsg_CVars) is _PB_type:
            assert issubclass(TYPE_CMsg_CVars, RepeatedSequence)
            if is_string(TYPE_CMsg_CVars.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_convars)


TYPE_CNETMsg_SetConVar = CNETMsg_SetConVar
_PB_finalizers.append('CNETMsg_SetConVar')

class CNETMsg_SignonState(ProtoBase):
    _required = []
    _field_map = {'map_name': 5, 'signon_state': 1, 'players_networkids': 4, 'spawn_count': 2, 'num_server_players': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['signon_state', 'spawn_count', 'num_server_players', 'players_networkids', 'map_name']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_signon_state(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'signon_state')
            self._cache[1] = r
        return r

    def _establish_parentage_signon_state(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_signon_state), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_signon_state
                v._pbf_establish_parent_callback = self._establish_parentage_signon_state

    def _set_signon_state(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_signon_state(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field signon_state"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_signon_state(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_signon_state(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "signon_state"

    signon_state = property(_get_signon_state, _set_signon_state, _del_signon_state)

    @property
    def signon_state__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def signon_state__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_signon_state(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_signon_state)


    def _get_spawn_count(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'spawn_count')
            self._cache[2] = r
        return r

    def _establish_parentage_spawn_count(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_spawn_count), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_spawn_count
                v._pbf_establish_parent_callback = self._establish_parentage_spawn_count

    def _set_spawn_count(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_spawn_count(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field spawn_count"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_spawn_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_spawn_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "spawn_count"

    spawn_count = property(_get_spawn_count, _set_spawn_count, _del_spawn_count)

    @property
    def spawn_count__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def spawn_count__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_spawn_count(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_spawn_count)


    def _get_num_server_players(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'num_server_players')
            self._cache[3] = r
        return r

    def _establish_parentage_num_server_players(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_server_players), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_server_players
                v._pbf_establish_parent_callback = self._establish_parentage_num_server_players

    def _set_num_server_players(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_server_players(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_server_players"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_num_server_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_num_server_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "num_server_players"

    num_server_players = property(_get_num_server_players, _set_num_server_players, _del_num_server_players)

    @property
    def num_server_players__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def num_server_players__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_num_server_players(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_num_server_players)


    class Repeated_players_networkids(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_players_networkids = Repeated_players_networkids


    def _get_players_networkids(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, self.TYPE_Repeated_players_networkids, 'players_networkids')
            self._cache[4] = r
        return r

    def _establish_parentage_players_networkids(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_players_networkids), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_players_networkids
                v._pbf_establish_parent_callback = self._establish_parentage_players_networkids

    def _set_players_networkids(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_players_networkids(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field players_networkids"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = self.TYPE_Repeated_players_networkids

    def _mod_players_networkids(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = self.TYPE_Repeated_players_networkids

    def _del_players_networkids(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "players_networkids"

    players_networkids = property(_get_players_networkids, _set_players_networkids, _del_players_networkids)

    @property
    def players_networkids__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def players_networkids__type(self):
        return self.TYPE_Repeated_players_networkids

    def _finalize_players_networkids(cls):
        if is_string(cls.TYPE_Repeated_players_networkids):
            cls._pbf_strings.append(4)
        elif _PB_type(cls.TYPE_Repeated_players_networkids) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_players_networkids, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_players_networkids.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_players_networkids)


    def _get_map_name(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_string, 'map_name')
            self._cache[5] = r
        return r

    def _establish_parentage_map_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_map_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_map_name
                v._pbf_establish_parent_callback = self._establish_parentage_map_name

    def _set_map_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_map_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field map_name"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_string

    def _mod_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_string

    def _del_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "map_name"

    map_name = property(_get_map_name, _set_map_name, _del_map_name)

    @property
    def map_name__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def map_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_map_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_map_name)


TYPE_CNETMsg_SignonState = CNETMsg_SignonState
_PB_finalizers.append('CNETMsg_SignonState')

class CCLCMsg_ClientInfo(ProtoBase):
    _required = []
    _field_map = {'custom_files': 7, 'friends_id': 5, 'send_table_crc': 1, 'friends_name': 6, 'server_count': 2, 'is_hltv': 3, 'is_replay': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['send_table_crc', 'server_count', 'is_hltv', 'is_replay', 'friends_id', 'friends_name', 'custom_files']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_send_table_crc(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_fixed32, 'send_table_crc')
            self._cache[1] = r
        return r

    def _establish_parentage_send_table_crc(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_send_table_crc), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_send_table_crc
                v._pbf_establish_parent_callback = self._establish_parentage_send_table_crc

    def _set_send_table_crc(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_send_table_crc(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field send_table_crc"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_fixed32

    def _mod_send_table_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_fixed32

    def _del_send_table_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "send_table_crc"

    send_table_crc = property(_get_send_table_crc, _set_send_table_crc, _del_send_table_crc)

    @property
    def send_table_crc__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def send_table_crc__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_send_table_crc(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_send_table_crc)


    def _get_server_count(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'server_count')
            self._cache[2] = r
        return r

    def _establish_parentage_server_count(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_server_count), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_server_count
                v._pbf_establish_parent_callback = self._establish_parentage_server_count

    def _set_server_count(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_server_count(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field server_count"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_server_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_server_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "server_count"

    server_count = property(_get_server_count, _set_server_count, _del_server_count)

    @property
    def server_count__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def server_count__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_server_count(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_server_count)


    def _get_is_hltv(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'is_hltv')
            self._cache[3] = r
        return r

    def _establish_parentage_is_hltv(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_hltv), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_hltv
                v._pbf_establish_parent_callback = self._establish_parentage_is_hltv

    def _set_is_hltv(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_hltv(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_hltv"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_is_hltv(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_is_hltv(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "is_hltv"

    is_hltv = property(_get_is_hltv, _set_is_hltv, _del_is_hltv)

    @property
    def is_hltv__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def is_hltv__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_hltv(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_is_hltv)


    def _get_is_replay(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'is_replay')
            self._cache[4] = r
        return r

    def _establish_parentage_is_replay(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_replay), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_replay
                v._pbf_establish_parent_callback = self._establish_parentage_is_replay

    def _set_is_replay(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_replay(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_replay"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_is_replay(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_is_replay(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "is_replay"

    is_replay = property(_get_is_replay, _set_is_replay, _del_is_replay)

    @property
    def is_replay__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def is_replay__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_replay(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_is_replay)


    def _get_friends_id(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_uint32, 'friends_id')
            self._cache[5] = r
        return r

    def _establish_parentage_friends_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_friends_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_friends_id
                v._pbf_establish_parent_callback = self._establish_parentage_friends_id

    def _set_friends_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_friends_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field friends_id"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_uint32

    def _mod_friends_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_uint32

    def _del_friends_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "friends_id"

    friends_id = property(_get_friends_id, _set_friends_id, _del_friends_id)

    @property
    def friends_id__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def friends_id__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_friends_id(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_friends_id)


    def _get_friends_name(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_string, 'friends_name')
            self._cache[6] = r
        return r

    def _establish_parentage_friends_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_friends_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_friends_name
                v._pbf_establish_parent_callback = self._establish_parentage_friends_name

    def _set_friends_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_friends_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field friends_name"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_string

    def _mod_friends_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_string

    def _del_friends_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "friends_name"

    friends_name = property(_get_friends_name, _set_friends_name, _del_friends_name)

    @property
    def friends_name__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def friends_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_friends_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_friends_name)


    class Repeated_custom_files(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_fixed32
        pb_subtype = pb_subtype()


    TYPE_Repeated_custom_files = Repeated_custom_files


    def _get_custom_files(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, self.TYPE_Repeated_custom_files, 'custom_files')
            self._cache[7] = r
        return r

    def _establish_parentage_custom_files(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_custom_files), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_custom_files
                v._pbf_establish_parent_callback = self._establish_parentage_custom_files

    def _set_custom_files(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_custom_files(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field custom_files"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = self.TYPE_Repeated_custom_files

    def _mod_custom_files(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = self.TYPE_Repeated_custom_files

    def _del_custom_files(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "custom_files"

    custom_files = property(_get_custom_files, _set_custom_files, _del_custom_files)

    @property
    def custom_files__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def custom_files__type(self):
        return self.TYPE_Repeated_custom_files

    def _finalize_custom_files(cls):
        if is_string(cls.TYPE_Repeated_custom_files):
            cls._pbf_strings.append(7)
        elif _PB_type(cls.TYPE_Repeated_custom_files) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_custom_files, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_custom_files.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_custom_files)


TYPE_CCLCMsg_ClientInfo = CCLCMsg_ClientInfo
_PB_finalizers.append('CCLCMsg_ClientInfo')

class CCLCMsg_Move(ProtoBase):
    _required = []
    _field_map = {'num_new_commands': 2, 'num_backup_commands': 1, 'data': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['num_backup_commands', 'num_new_commands', 'data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_num_backup_commands(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'num_backup_commands')
            self._cache[1] = r
        return r

    def _establish_parentage_num_backup_commands(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_backup_commands), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_backup_commands
                v._pbf_establish_parent_callback = self._establish_parentage_num_backup_commands

    def _set_num_backup_commands(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_backup_commands(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_backup_commands"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_num_backup_commands(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_num_backup_commands(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "num_backup_commands"

    num_backup_commands = property(_get_num_backup_commands, _set_num_backup_commands, _del_num_backup_commands)

    @property
    def num_backup_commands__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def num_backup_commands__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_num_backup_commands(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_num_backup_commands)


    def _get_num_new_commands(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'num_new_commands')
            self._cache[2] = r
        return r

    def _establish_parentage_num_new_commands(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_new_commands), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_new_commands
                v._pbf_establish_parent_callback = self._establish_parentage_num_new_commands

    def _set_num_new_commands(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_new_commands(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_new_commands"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_num_new_commands(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_num_new_commands(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "num_new_commands"

    num_new_commands = property(_get_num_new_commands, _set_num_new_commands, _del_num_new_commands)

    @property
    def num_new_commands__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def num_new_commands__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_num_new_commands(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_num_new_commands)


    def _get_data(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bytes, 'data')
            self._cache[3] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_data)


TYPE_CCLCMsg_Move = CCLCMsg_Move
_PB_finalizers.append('CCLCMsg_Move')

class CCLCMsg_VoiceData(ProtoBase):
    _required = []
    _field_map = {'xuid': 2, 'data': 1, 'format': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['data', 'xuid', 'format']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_data(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bytes, 'data')
            self._cache[1] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_data)


    def _get_xuid(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_fixed64, 'xuid')
            self._cache[2] = r
        return r

    def _establish_parentage_xuid(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_xuid), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_xuid
                v._pbf_establish_parent_callback = self._establish_parentage_xuid

    def _set_xuid(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_xuid(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field xuid"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_fixed64

    def _mod_xuid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_fixed64

    def _del_xuid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "xuid"

    xuid = property(_get_xuid, _set_xuid, _del_xuid)

    @property
    def xuid__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def xuid__type(self):
        return ProtoBase.TYPE_fixed64

    def _finalize_xuid(cls):
        if is_string(ProtoBase.TYPE_fixed64):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_fixed64) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed64, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed64.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_xuid)


    def _get_format(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            try:
                r = self._buf_get(3, TYPE_VoiceDataFormat_t, 'format')
            except:
                r = VOICEDATA_FORMAT_STEAM
            self._cache[3] = r
        return r

    def _establish_parentage_format(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_format), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_format
                v._pbf_establish_parent_callback = self._establish_parentage_format

    def _set_format(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_format(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field format"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_VoiceDataFormat_t

    def _mod_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_VoiceDataFormat_t

    def _del_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "format"

    format = property(_get_format, _set_format, _del_format)

    @property
    def format__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def format__type(self):
        return TYPE_VoiceDataFormat_t

    def _finalize_format(cls):
        if is_string(TYPE_VoiceDataFormat_t):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_VoiceDataFormat_t) is _PB_type:
            assert issubclass(TYPE_VoiceDataFormat_t, RepeatedSequence)
            if is_string(TYPE_VoiceDataFormat_t.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_format)


TYPE_CCLCMsg_VoiceData = CCLCMsg_VoiceData
_PB_finalizers.append('CCLCMsg_VoiceData')

class CCLCMsg_BaselineAck(ProtoBase):
    _required = []
    _field_map = {'baseline_tick': 1, 'baseline_nr': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['baseline_tick', 'baseline_nr']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_baseline_tick(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'baseline_tick')
            self._cache[1] = r
        return r

    def _establish_parentage_baseline_tick(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_baseline_tick), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_baseline_tick
                v._pbf_establish_parent_callback = self._establish_parentage_baseline_tick

    def _set_baseline_tick(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_baseline_tick(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field baseline_tick"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_baseline_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_baseline_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "baseline_tick"

    baseline_tick = property(_get_baseline_tick, _set_baseline_tick, _del_baseline_tick)

    @property
    def baseline_tick__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def baseline_tick__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_baseline_tick(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_baseline_tick)


    def _get_baseline_nr(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'baseline_nr')
            self._cache[2] = r
        return r

    def _establish_parentage_baseline_nr(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_baseline_nr), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_baseline_nr
                v._pbf_establish_parent_callback = self._establish_parentage_baseline_nr

    def _set_baseline_nr(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_baseline_nr(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field baseline_nr"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_baseline_nr(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_baseline_nr(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "baseline_nr"

    baseline_nr = property(_get_baseline_nr, _set_baseline_nr, _del_baseline_nr)

    @property
    def baseline_nr__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def baseline_nr__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_baseline_nr(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_baseline_nr)


TYPE_CCLCMsg_BaselineAck = CCLCMsg_BaselineAck
_PB_finalizers.append('CCLCMsg_BaselineAck')

class CCLCMsg_ListenEvents(ProtoBase):
    _required = []
    _field_map = {'event_mask': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['event_mask']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_event_mask(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_fixed32
        pb_subtype = pb_subtype()


    TYPE_Repeated_event_mask = Repeated_event_mask


    def _get_event_mask(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_event_mask, 'event_mask')
            self._cache[1] = r
        return r

    def _establish_parentage_event_mask(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_mask), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_mask
                v._pbf_establish_parent_callback = self._establish_parentage_event_mask

    def _set_event_mask(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_mask(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_mask"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_event_mask

    def _mod_event_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_event_mask

    def _del_event_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "event_mask"

    event_mask = property(_get_event_mask, _set_event_mask, _del_event_mask)

    @property
    def event_mask__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def event_mask__type(self):
        return self.TYPE_Repeated_event_mask

    def _finalize_event_mask(cls):
        if is_string(cls.TYPE_Repeated_event_mask):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_event_mask) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_event_mask, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_event_mask.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_event_mask)


TYPE_CCLCMsg_ListenEvents = CCLCMsg_ListenEvents
_PB_finalizers.append('CCLCMsg_ListenEvents')

class CCLCMsg_RespondCvarValue(ProtoBase):
    _required = []
    _field_map = {'status_code': 2, 'cookie': 1, 'name': 3, 'value': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['cookie', 'status_code', 'name', 'value']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_cookie(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'cookie')
            self._cache[1] = r
        return r

    def _establish_parentage_cookie(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cookie), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cookie
                v._pbf_establish_parent_callback = self._establish_parentage_cookie

    def _set_cookie(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cookie(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cookie"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_cookie(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_cookie(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "cookie"

    cookie = property(_get_cookie, _set_cookie, _del_cookie)

    @property
    def cookie__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def cookie__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_cookie(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_cookie)


    def _get_status_code(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'status_code')
            self._cache[2] = r
        return r

    def _establish_parentage_status_code(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_status_code), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_status_code
                v._pbf_establish_parent_callback = self._establish_parentage_status_code

    def _set_status_code(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_status_code(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field status_code"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_status_code(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_status_code(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "status_code"

    status_code = property(_get_status_code, _set_status_code, _del_status_code)

    @property
    def status_code__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def status_code__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_status_code(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_status_code)


    def _get_name(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'name')
            self._cache[3] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_name)


    def _get_value(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'value')
            self._cache[4] = r
        return r

    def _establish_parentage_value(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_value
                v._pbf_establish_parent_callback = self._establish_parentage_value

    def _set_value(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_value(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field value"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_value(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "value"

    value = property(_get_value, _set_value, _del_value)

    @property
    def value__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def value__type(self):
        return ProtoBase.TYPE_string

    def _finalize_value(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_value)


TYPE_CCLCMsg_RespondCvarValue = CCLCMsg_RespondCvarValue
_PB_finalizers.append('CCLCMsg_RespondCvarValue')

class CCLCMsg_FileCRCCheck(ProtoBase):
    _required = []
    _field_map = {'path': 2, 'crc': 5, 'code_filename': 3, 'code_path': 1, 'filename': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['code_path', 'path', 'code_filename', 'filename', 'crc']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_code_path(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'code_path')
            self._cache[1] = r
        return r

    def _establish_parentage_code_path(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_code_path), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_code_path
                v._pbf_establish_parent_callback = self._establish_parentage_code_path

    def _set_code_path(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_code_path(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field code_path"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_code_path(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_code_path(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "code_path"

    code_path = property(_get_code_path, _set_code_path, _del_code_path)

    @property
    def code_path__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def code_path__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_code_path(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_code_path)


    def _get_path(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'path')
            self._cache[2] = r
        return r

    def _establish_parentage_path(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_path), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_path
                v._pbf_establish_parent_callback = self._establish_parentage_path

    def _set_path(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_path(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field path"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_path(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_path(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "path"

    path = property(_get_path, _set_path, _del_path)

    @property
    def path__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def path__type(self):
        return ProtoBase.TYPE_string

    def _finalize_path(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_path)


    def _get_code_filename(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'code_filename')
            self._cache[3] = r
        return r

    def _establish_parentage_code_filename(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_code_filename), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_code_filename
                v._pbf_establish_parent_callback = self._establish_parentage_code_filename

    def _set_code_filename(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_code_filename(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field code_filename"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_code_filename(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_code_filename(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "code_filename"

    code_filename = property(_get_code_filename, _set_code_filename, _del_code_filename)

    @property
    def code_filename__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def code_filename__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_code_filename(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_code_filename)


    def _get_filename(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'filename')
            self._cache[4] = r
        return r

    def _establish_parentage_filename(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_filename), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_filename
                v._pbf_establish_parent_callback = self._establish_parentage_filename

    def _set_filename(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_filename(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field filename"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_filename(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_filename(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "filename"

    filename = property(_get_filename, _set_filename, _del_filename)

    @property
    def filename__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def filename__type(self):
        return ProtoBase.TYPE_string

    def _finalize_filename(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_filename)


    def _get_crc(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_fixed32, 'crc')
            self._cache[5] = r
        return r

    def _establish_parentage_crc(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_crc), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_crc
                v._pbf_establish_parent_callback = self._establish_parentage_crc

    def _set_crc(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_crc(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field crc"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_fixed32

    def _mod_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_fixed32

    def _del_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "crc"

    crc = property(_get_crc, _set_crc, _del_crc)

    @property
    def crc__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def crc__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_crc(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_crc)


TYPE_CCLCMsg_FileCRCCheck = CCLCMsg_FileCRCCheck
_PB_finalizers.append('CCLCMsg_FileCRCCheck')

class CCLCMsg_LoadingProgress(ProtoBase):
    _required = []
    _field_map = {'progress': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['progress']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_progress(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'progress')
            self._cache[1] = r
        return r

    def _establish_parentage_progress(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_progress), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_progress
                v._pbf_establish_parent_callback = self._establish_parentage_progress

    def _set_progress(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_progress(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field progress"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_progress(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_progress(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "progress"

    progress = property(_get_progress, _set_progress, _del_progress)

    @property
    def progress__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def progress__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_progress(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_progress)


TYPE_CCLCMsg_LoadingProgress = CCLCMsg_LoadingProgress
_PB_finalizers.append('CCLCMsg_LoadingProgress')

class CCLCMsg_SplitPlayerConnect(ProtoBase):
    _required = []
    _field_map = {'convars': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['convars']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_convars(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsg_CVars, 'convars')
            self._cache[1] = r
        return r

    def _establish_parentage_convars(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_convars), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_convars
                v._pbf_establish_parent_callback = self._establish_parentage_convars

    def _set_convars(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_convars(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field convars"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsg_CVars

    def _mod_convars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsg_CVars

    def _del_convars(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "convars"

    convars = property(_get_convars, _set_convars, _del_convars)

    @property
    def convars__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def convars__type(self):
        return TYPE_CMsg_CVars

    def _finalize_convars(cls):
        if is_string(TYPE_CMsg_CVars):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsg_CVars) is _PB_type:
            assert issubclass(TYPE_CMsg_CVars, RepeatedSequence)
            if is_string(TYPE_CMsg_CVars.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_convars)


TYPE_CCLCMsg_SplitPlayerConnect = CCLCMsg_SplitPlayerConnect
_PB_finalizers.append('CCLCMsg_SplitPlayerConnect')

class CCLCMsg_ClientMessage(ProtoBase):
    _required = []
    _field_map = {'data': 2, 'msg_type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['msg_type', 'data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_msg_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'msg_type')
            self._cache[1] = r
        return r

    def _establish_parentage_msg_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_msg_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_msg_type
                v._pbf_establish_parent_callback = self._establish_parentage_msg_type

    def _set_msg_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_msg_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field msg_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "msg_type"

    msg_type = property(_get_msg_type, _set_msg_type, _del_msg_type)

    @property
    def msg_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def msg_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_msg_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_msg_type)


    def _get_data(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bytes, 'data')
            self._cache[2] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bytes

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bytes

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_data)


TYPE_CCLCMsg_ClientMessage = CCLCMsg_ClientMessage
_PB_finalizers.append('CCLCMsg_ClientMessage')

class CSVCMsg_ServerInfo(ProtoBase):
    _required = []
    _field_map = {'addon_name': 18, 'protocol': 1, 'player_slot': 12, 'max_classes': 11, 'is_dedicated': 3, 'tick_interval': 13, 'string_table_crc': 9, 'sky_name': 16, 'c_os': 6, 'map_name': 15, 'game_dir': 14, 'host_name': 17, 'client_crc': 8, 'map_crc': 7, 'max_clients': 10, 'server_count': 2, 'is_hltv': 4, 'is_replay': 5}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['protocol', 'server_count', 'is_dedicated', 'is_hltv', 'is_replay', 'c_os', 'map_crc', 'client_crc', 'string_table_crc', 'max_clients', 'max_classes', 'player_slot', 'tick_interval', 'game_dir', 'map_name', 'sky_name', 'host_name', 'addon_name']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_protocol(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'protocol')
            self._cache[1] = r
        return r

    def _establish_parentage_protocol(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_protocol), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_protocol
                v._pbf_establish_parent_callback = self._establish_parentage_protocol

    def _set_protocol(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_protocol(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field protocol"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_protocol(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_protocol(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "protocol"

    protocol = property(_get_protocol, _set_protocol, _del_protocol)

    @property
    def protocol__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def protocol__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_protocol(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_protocol)


    def _get_server_count(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'server_count')
            self._cache[2] = r
        return r

    def _establish_parentage_server_count(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_server_count), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_server_count
                v._pbf_establish_parent_callback = self._establish_parentage_server_count

    def _set_server_count(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_server_count(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field server_count"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_server_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_server_count(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "server_count"

    server_count = property(_get_server_count, _set_server_count, _del_server_count)

    @property
    def server_count__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def server_count__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_server_count(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_server_count)


    def _get_is_dedicated(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'is_dedicated')
            self._cache[3] = r
        return r

    def _establish_parentage_is_dedicated(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_dedicated), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_dedicated
                v._pbf_establish_parent_callback = self._establish_parentage_is_dedicated

    def _set_is_dedicated(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_dedicated(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_dedicated"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_is_dedicated(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_is_dedicated(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "is_dedicated"

    is_dedicated = property(_get_is_dedicated, _set_is_dedicated, _del_is_dedicated)

    @property
    def is_dedicated__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def is_dedicated__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_dedicated(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_is_dedicated)


    def _get_is_hltv(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'is_hltv')
            self._cache[4] = r
        return r

    def _establish_parentage_is_hltv(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_hltv), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_hltv
                v._pbf_establish_parent_callback = self._establish_parentage_is_hltv

    def _set_is_hltv(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_hltv(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_hltv"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_is_hltv(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_is_hltv(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "is_hltv"

    is_hltv = property(_get_is_hltv, _set_is_hltv, _del_is_hltv)

    @property
    def is_hltv__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def is_hltv__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_hltv(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_is_hltv)


    def _get_is_replay(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bool, 'is_replay')
            self._cache[5] = r
        return r

    def _establish_parentage_is_replay(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_replay), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_replay
                v._pbf_establish_parent_callback = self._establish_parentage_is_replay

    def _set_is_replay(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_replay(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_replay"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bool

    def _mod_is_replay(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bool

    def _del_is_replay(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "is_replay"

    is_replay = property(_get_is_replay, _set_is_replay, _del_is_replay)

    @property
    def is_replay__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def is_replay__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_replay(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_is_replay)


    def _get_c_os(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_int32, 'c_os')
            self._cache[6] = r
        return r

    def _establish_parentage_c_os(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_c_os), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_c_os
                v._pbf_establish_parent_callback = self._establish_parentage_c_os

    def _set_c_os(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_c_os(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field c_os"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_int32

    def _mod_c_os(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_int32

    def _del_c_os(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "c_os"

    c_os = property(_get_c_os, _set_c_os, _del_c_os)

    @property
    def c_os__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def c_os__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_c_os(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_c_os)


    def _get_map_crc(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_fixed32, 'map_crc')
            self._cache[7] = r
        return r

    def _establish_parentage_map_crc(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_map_crc), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_map_crc
                v._pbf_establish_parent_callback = self._establish_parentage_map_crc

    def _set_map_crc(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_map_crc(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field map_crc"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_fixed32

    def _mod_map_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_fixed32

    def _del_map_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "map_crc"

    map_crc = property(_get_map_crc, _set_map_crc, _del_map_crc)

    @property
    def map_crc__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def map_crc__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_map_crc(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_map_crc)


    def _get_client_crc(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_fixed32, 'client_crc')
            self._cache[8] = r
        return r

    def _establish_parentage_client_crc(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_client_crc), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_client_crc
                v._pbf_establish_parent_callback = self._establish_parentage_client_crc

    def _set_client_crc(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_client_crc(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field client_crc"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_fixed32

    def _mod_client_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_fixed32

    def _del_client_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "client_crc"

    client_crc = property(_get_client_crc, _set_client_crc, _del_client_crc)

    @property
    def client_crc__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def client_crc__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_client_crc(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_client_crc)


    def _get_string_table_crc(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, ProtoBase.TYPE_fixed32, 'string_table_crc')
            self._cache[9] = r
        return r

    def _establish_parentage_string_table_crc(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_string_table_crc), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_string_table_crc
                v._pbf_establish_parent_callback = self._establish_parentage_string_table_crc

    def _set_string_table_crc(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_string_table_crc(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field string_table_crc"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = ProtoBase.TYPE_fixed32

    def _mod_string_table_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = ProtoBase.TYPE_fixed32

    def _del_string_table_crc(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "string_table_crc"

    string_table_crc = property(_get_string_table_crc, _set_string_table_crc, _del_string_table_crc)

    @property
    def string_table_crc__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def string_table_crc__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_string_table_crc(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(9)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_string_table_crc)


    def _get_max_clients(self):
        if 10 in self._cache:
            r = self._cache[10]
        else:
            r = self._buf_get(10, ProtoBase.TYPE_int32, 'max_clients')
            self._cache[10] = r
        return r

    def _establish_parentage_max_clients(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_max_clients), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_max_clients
                v._pbf_establish_parent_callback = self._establish_parentage_max_clients

    def _set_max_clients(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_max_clients(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field max_clients"
            raise ProtoValueError(list_assign_error)
        self._cache[10] = v
        self._mods[10] = ProtoBase.TYPE_int32

    def _mod_max_clients(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[10] = ProtoBase.TYPE_int32

    def _del_max_clients(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 10 in self._cache:
            del self._cache[10]
        if 10 in self._mods:
            del self._mods[10]
        self._buf_del(10)

    _pb_field_name_10 = "max_clients"

    max_clients = property(_get_max_clients, _set_max_clients, _del_max_clients)

    @property
    def max_clients__exists(self):
        return 10 in self._mods or self._buf_exists(10)

    @property
    def max_clients__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_max_clients(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(10)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(10)

    _pbf_finalizers.append(_finalize_max_clients)


    def _get_max_classes(self):
        if 11 in self._cache:
            r = self._cache[11]
        else:
            r = self._buf_get(11, ProtoBase.TYPE_int32, 'max_classes')
            self._cache[11] = r
        return r

    def _establish_parentage_max_classes(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_max_classes), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_max_classes
                v._pbf_establish_parent_callback = self._establish_parentage_max_classes

    def _set_max_classes(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_max_classes(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field max_classes"
            raise ProtoValueError(list_assign_error)
        self._cache[11] = v
        self._mods[11] = ProtoBase.TYPE_int32

    def _mod_max_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[11] = ProtoBase.TYPE_int32

    def _del_max_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 11 in self._cache:
            del self._cache[11]
        if 11 in self._mods:
            del self._mods[11]
        self._buf_del(11)

    _pb_field_name_11 = "max_classes"

    max_classes = property(_get_max_classes, _set_max_classes, _del_max_classes)

    @property
    def max_classes__exists(self):
        return 11 in self._mods or self._buf_exists(11)

    @property
    def max_classes__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_max_classes(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(11)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(11)

    _pbf_finalizers.append(_finalize_max_classes)


    def _get_player_slot(self):
        if 12 in self._cache:
            r = self._cache[12]
        else:
            r = self._buf_get(12, ProtoBase.TYPE_int32, 'player_slot')
            self._cache[12] = r
        return r

    def _establish_parentage_player_slot(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_slot), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_slot
                v._pbf_establish_parent_callback = self._establish_parentage_player_slot

    def _set_player_slot(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_slot(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_slot"
            raise ProtoValueError(list_assign_error)
        self._cache[12] = v
        self._mods[12] = ProtoBase.TYPE_int32

    def _mod_player_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[12] = ProtoBase.TYPE_int32

    def _del_player_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 12 in self._cache:
            del self._cache[12]
        if 12 in self._mods:
            del self._mods[12]
        self._buf_del(12)

    _pb_field_name_12 = "player_slot"

    player_slot = property(_get_player_slot, _set_player_slot, _del_player_slot)

    @property
    def player_slot__exists(self):
        return 12 in self._mods or self._buf_exists(12)

    @property
    def player_slot__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_slot(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(12)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(12)

    _pbf_finalizers.append(_finalize_player_slot)


    def _get_tick_interval(self):
        if 13 in self._cache:
            r = self._cache[13]
        else:
            r = self._buf_get(13, ProtoBase.TYPE_float, 'tick_interval')
            self._cache[13] = r
        return r

    def _establish_parentage_tick_interval(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tick_interval), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tick_interval
                v._pbf_establish_parent_callback = self._establish_parentage_tick_interval

    def _set_tick_interval(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tick_interval(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tick_interval"
            raise ProtoValueError(list_assign_error)
        self._cache[13] = v
        self._mods[13] = ProtoBase.TYPE_float

    def _mod_tick_interval(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[13] = ProtoBase.TYPE_float

    def _del_tick_interval(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 13 in self._cache:
            del self._cache[13]
        if 13 in self._mods:
            del self._mods[13]
        self._buf_del(13)

    _pb_field_name_13 = "tick_interval"

    tick_interval = property(_get_tick_interval, _set_tick_interval, _del_tick_interval)

    @property
    def tick_interval__exists(self):
        return 13 in self._mods or self._buf_exists(13)

    @property
    def tick_interval__type(self):
        return ProtoBase.TYPE_float

    def _finalize_tick_interval(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(13)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(13)

    _pbf_finalizers.append(_finalize_tick_interval)


    def _get_game_dir(self):
        if 14 in self._cache:
            r = self._cache[14]
        else:
            r = self._buf_get(14, ProtoBase.TYPE_string, 'game_dir')
            self._cache[14] = r
        return r

    def _establish_parentage_game_dir(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_game_dir), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_game_dir
                v._pbf_establish_parent_callback = self._establish_parentage_game_dir

    def _set_game_dir(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_game_dir(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field game_dir"
            raise ProtoValueError(list_assign_error)
        self._cache[14] = v
        self._mods[14] = ProtoBase.TYPE_string

    def _mod_game_dir(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[14] = ProtoBase.TYPE_string

    def _del_game_dir(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 14 in self._cache:
            del self._cache[14]
        if 14 in self._mods:
            del self._mods[14]
        self._buf_del(14)

    _pb_field_name_14 = "game_dir"

    game_dir = property(_get_game_dir, _set_game_dir, _del_game_dir)

    @property
    def game_dir__exists(self):
        return 14 in self._mods or self._buf_exists(14)

    @property
    def game_dir__type(self):
        return ProtoBase.TYPE_string

    def _finalize_game_dir(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(14)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(14)

    _pbf_finalizers.append(_finalize_game_dir)


    def _get_map_name(self):
        if 15 in self._cache:
            r = self._cache[15]
        else:
            r = self._buf_get(15, ProtoBase.TYPE_string, 'map_name')
            self._cache[15] = r
        return r

    def _establish_parentage_map_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_map_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_map_name
                v._pbf_establish_parent_callback = self._establish_parentage_map_name

    def _set_map_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_map_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field map_name"
            raise ProtoValueError(list_assign_error)
        self._cache[15] = v
        self._mods[15] = ProtoBase.TYPE_string

    def _mod_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[15] = ProtoBase.TYPE_string

    def _del_map_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 15 in self._cache:
            del self._cache[15]
        if 15 in self._mods:
            del self._mods[15]
        self._buf_del(15)

    _pb_field_name_15 = "map_name"

    map_name = property(_get_map_name, _set_map_name, _del_map_name)

    @property
    def map_name__exists(self):
        return 15 in self._mods or self._buf_exists(15)

    @property
    def map_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_map_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(15)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(15)

    _pbf_finalizers.append(_finalize_map_name)


    def _get_sky_name(self):
        if 16 in self._cache:
            r = self._cache[16]
        else:
            r = self._buf_get(16, ProtoBase.TYPE_string, 'sky_name')
            self._cache[16] = r
        return r

    def _establish_parentage_sky_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_sky_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_sky_name
                v._pbf_establish_parent_callback = self._establish_parentage_sky_name

    def _set_sky_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_sky_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field sky_name"
            raise ProtoValueError(list_assign_error)
        self._cache[16] = v
        self._mods[16] = ProtoBase.TYPE_string

    def _mod_sky_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[16] = ProtoBase.TYPE_string

    def _del_sky_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 16 in self._cache:
            del self._cache[16]
        if 16 in self._mods:
            del self._mods[16]
        self._buf_del(16)

    _pb_field_name_16 = "sky_name"

    sky_name = property(_get_sky_name, _set_sky_name, _del_sky_name)

    @property
    def sky_name__exists(self):
        return 16 in self._mods or self._buf_exists(16)

    @property
    def sky_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_sky_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(16)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(16)

    _pbf_finalizers.append(_finalize_sky_name)


    def _get_host_name(self):
        if 17 in self._cache:
            r = self._cache[17]
        else:
            r = self._buf_get(17, ProtoBase.TYPE_string, 'host_name')
            self._cache[17] = r
        return r

    def _establish_parentage_host_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_host_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_host_name
                v._pbf_establish_parent_callback = self._establish_parentage_host_name

    def _set_host_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_host_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field host_name"
            raise ProtoValueError(list_assign_error)
        self._cache[17] = v
        self._mods[17] = ProtoBase.TYPE_string

    def _mod_host_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[17] = ProtoBase.TYPE_string

    def _del_host_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 17 in self._cache:
            del self._cache[17]
        if 17 in self._mods:
            del self._mods[17]
        self._buf_del(17)

    _pb_field_name_17 = "host_name"

    host_name = property(_get_host_name, _set_host_name, _del_host_name)

    @property
    def host_name__exists(self):
        return 17 in self._mods or self._buf_exists(17)

    @property
    def host_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_host_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(17)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(17)

    _pbf_finalizers.append(_finalize_host_name)


    def _get_addon_name(self):
        if 18 in self._cache:
            r = self._cache[18]
        else:
            r = self._buf_get(18, ProtoBase.TYPE_string, 'addon_name')
            self._cache[18] = r
        return r

    def _establish_parentage_addon_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_addon_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_addon_name
                v._pbf_establish_parent_callback = self._establish_parentage_addon_name

    def _set_addon_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_addon_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field addon_name"
            raise ProtoValueError(list_assign_error)
        self._cache[18] = v
        self._mods[18] = ProtoBase.TYPE_string

    def _mod_addon_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[18] = ProtoBase.TYPE_string

    def _del_addon_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 18 in self._cache:
            del self._cache[18]
        if 18 in self._mods:
            del self._mods[18]
        self._buf_del(18)

    _pb_field_name_18 = "addon_name"

    addon_name = property(_get_addon_name, _set_addon_name, _del_addon_name)

    @property
    def addon_name__exists(self):
        return 18 in self._mods or self._buf_exists(18)

    @property
    def addon_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_addon_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(18)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(18)

    _pbf_finalizers.append(_finalize_addon_name)


TYPE_CSVCMsg_ServerInfo = CSVCMsg_ServerInfo
_PB_finalizers.append('CSVCMsg_ServerInfo')

class CSVCMsg_ClassInfo(ProtoBase):
    _required = []
    _field_map = {'classes': 2, 'create_on_client': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['create_on_client', 'classes']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class class_t(ProtoBase):
        _required = []
        _field_map = {'class_id': 1, 'class_name': 3, 'data_table_name': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['class_id', 'data_table_name', 'class_name']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_class_id(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'class_id')
                self._cache[1] = r
            return r
    
        def _establish_parentage_class_id(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_class_id), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_class_id
                    v._pbf_establish_parent_callback = self._establish_parentage_class_id
    
        def _set_class_id(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_class_id(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field class_id"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_class_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_class_id(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "class_id"
    
        class_id = property(_get_class_id, _set_class_id, _del_class_id)
    
        @property
        def class_id__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def class_id__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_class_id(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_class_id)
    
        
        def _get_data_table_name(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'data_table_name')
                self._cache[2] = r
            return r
    
        def _establish_parentage_data_table_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_data_table_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_data_table_name
                    v._pbf_establish_parent_callback = self._establish_parentage_data_table_name
    
        def _set_data_table_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_data_table_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field data_table_name"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_data_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_data_table_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "data_table_name"
    
        data_table_name = property(_get_data_table_name, _set_data_table_name, _del_data_table_name)
    
        @property
        def data_table_name__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def data_table_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_data_table_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_data_table_name)
    
        
        def _get_class_name(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_string, 'class_name')
                self._cache[3] = r
            return r
    
        def _establish_parentage_class_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_class_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_class_name
                    v._pbf_establish_parent_callback = self._establish_parentage_class_name
    
        def _set_class_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_class_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field class_name"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_string
    
        def _mod_class_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_string
    
        def _del_class_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "class_name"
    
        class_name = property(_get_class_name, _set_class_name, _del_class_name)
    
        @property
        def class_name__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def class_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_class_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_class_name)
    
        
    TYPE_class_t = class_t
    _PB_finalizers.append('CSVCMsg_ClassInfo.class_t')
    
    TYPE_class_t = class_t

    def _get_create_on_client(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'create_on_client')
            self._cache[1] = r
        return r

    def _establish_parentage_create_on_client(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_create_on_client), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_create_on_client
                v._pbf_establish_parent_callback = self._establish_parentage_create_on_client

    def _set_create_on_client(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_create_on_client(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field create_on_client"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_create_on_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_create_on_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "create_on_client"

    create_on_client = property(_get_create_on_client, _set_create_on_client, _del_create_on_client)

    @property
    def create_on_client__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def create_on_client__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_create_on_client(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_create_on_client)


    class Repeated_classes(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsg_ClassInfo.TYPE_class_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_classes = Repeated_classes


    @property
    def classes__stream(self):
        if 2 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[2]]
        return self._get_repeated(2, self.TYPE_Repeated_classes, "classes", lazy=True)

    def classes__fast_append(self, value):
        self._append_to_repeated(2, self.TYPE_Repeated_classes, value)

    def _get_classes(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_classes, 'classes')
            self._cache[2] = r
        return r

    def _establish_parentage_classes(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_classes), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_classes
                v._pbf_establish_parent_callback = self._establish_parentage_classes

    def _set_classes(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_classes(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field classes"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_classes

    def _mod_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_classes

    def _del_classes(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "classes"

    classes = property(_get_classes, _set_classes, _del_classes)

    @property
    def classes__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def classes__type(self):
        return self.TYPE_Repeated_classes

    def _finalize_classes(cls):
        if is_string(cls.TYPE_Repeated_classes):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_classes) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_classes, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_classes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_classes)


TYPE_CSVCMsg_ClassInfo = CSVCMsg_ClassInfo
_PB_finalizers.append('CSVCMsg_ClassInfo')

class CSVCMsg_SetPause(ProtoBase):
    _required = []
    _field_map = {'paused': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['paused']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_paused(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'paused')
            self._cache[1] = r
        return r

    def _establish_parentage_paused(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_paused), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_paused
                v._pbf_establish_parent_callback = self._establish_parentage_paused

    def _set_paused(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_paused(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field paused"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_paused(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_paused(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "paused"

    paused = property(_get_paused, _set_paused, _del_paused)

    @property
    def paused__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def paused__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_paused(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_paused)


TYPE_CSVCMsg_SetPause = CSVCMsg_SetPause
_PB_finalizers.append('CSVCMsg_SetPause')

class CSVCMsg_VoiceInit(ProtoBase):
    _required = []
    _field_map = {'codec': 2, 'quality': 1, 'version': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['quality', 'codec', 'version']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_quality(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'quality')
            self._cache[1] = r
        return r

    def _establish_parentage_quality(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_quality), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_quality
                v._pbf_establish_parent_callback = self._establish_parentage_quality

    def _set_quality(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_quality(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field quality"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_quality(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_quality(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "quality"

    quality = property(_get_quality, _set_quality, _del_quality)

    @property
    def quality__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def quality__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_quality(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_quality)


    def _get_codec(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'codec')
            self._cache[2] = r
        return r

    def _establish_parentage_codec(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_codec), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_codec
                v._pbf_establish_parent_callback = self._establish_parentage_codec

    def _set_codec(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_codec(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field codec"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_codec(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_codec(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "codec"

    codec = property(_get_codec, _set_codec, _del_codec)

    @property
    def codec__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def codec__type(self):
        return ProtoBase.TYPE_string

    def _finalize_codec(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_codec)


    def _get_version(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            try:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'version')
            except:
                r = 0
            self._cache[3] = r
        return r

    def _establish_parentage_version(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_version), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_version
                v._pbf_establish_parent_callback = self._establish_parentage_version

    def _set_version(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_version(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field version"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_version(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "version"

    version = property(_get_version, _set_version, _del_version)

    @property
    def version__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def version__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_version(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_version)


TYPE_CSVCMsg_VoiceInit = CSVCMsg_VoiceInit
_PB_finalizers.append('CSVCMsg_VoiceInit')

class CSVCMsg_Print(ProtoBase):
    _required = []
    _field_map = {'text': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['text']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_text(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'text')
            self._cache[1] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_text)


TYPE_CSVCMsg_Print = CSVCMsg_Print
_PB_finalizers.append('CSVCMsg_Print')

class CSVCMsg_Sounds(ProtoBase):
    _required = []
    _field_map = {'reliable_sound': 1, 'sounds': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['reliable_sound', 'sounds']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class sounddata_t(ProtoBase):
        _required = []
        _field_map = {'delay_value': 5, 'entity_index': 7, 'channel': 8, 'sound_num': 11, 'pitch': 9, 'sound_level': 15, 'volume': 4, 'is_sentence': 16, 'is_ambient': 17, 'flags': 10, 'origin_z': 3, 'origin_y': 2, 'origin_x': 1, 'random_seed': 14, 'sound_num_handle': 12, 'sequence_number': 6, 'speaker_entity': 13}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['origin_x', 'origin_y', 'origin_z', 'volume', 'delay_value', 'sequence_number', 'entity_index', 'channel', 'pitch', 'flags', 'sound_num', 'sound_num_handle', 'speaker_entity', 'random_seed', 'sound_level', 'is_sentence', 'is_ambient']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_origin_x(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_sint32, 'origin_x')
                self._cache[1] = r
            return r
    
        def _establish_parentage_origin_x(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_origin_x), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_origin_x
                    v._pbf_establish_parent_callback = self._establish_parentage_origin_x
    
        def _set_origin_x(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_origin_x(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field origin_x"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_sint32
    
        def _mod_origin_x(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_sint32
    
        def _del_origin_x(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "origin_x"
    
        origin_x = property(_get_origin_x, _set_origin_x, _del_origin_x)
    
        @property
        def origin_x__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def origin_x__type(self):
            return ProtoBase.TYPE_sint32
    
        def _finalize_origin_x(cls):
            if is_string(ProtoBase.TYPE_sint32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_origin_x)
    
        
        def _get_origin_y(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_sint32, 'origin_y')
                self._cache[2] = r
            return r
    
        def _establish_parentage_origin_y(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_origin_y), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_origin_y
                    v._pbf_establish_parent_callback = self._establish_parentage_origin_y
    
        def _set_origin_y(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_origin_y(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field origin_y"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_sint32
    
        def _mod_origin_y(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_sint32
    
        def _del_origin_y(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "origin_y"
    
        origin_y = property(_get_origin_y, _set_origin_y, _del_origin_y)
    
        @property
        def origin_y__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def origin_y__type(self):
            return ProtoBase.TYPE_sint32
    
        def _finalize_origin_y(cls):
            if is_string(ProtoBase.TYPE_sint32):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_origin_y)
    
        
        def _get_origin_z(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_sint32, 'origin_z')
                self._cache[3] = r
            return r
    
        def _establish_parentage_origin_z(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_origin_z), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_origin_z
                    v._pbf_establish_parent_callback = self._establish_parentage_origin_z
    
        def _set_origin_z(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_origin_z(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field origin_z"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_sint32
    
        def _mod_origin_z(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_sint32
    
        def _del_origin_z(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "origin_z"
    
        origin_z = property(_get_origin_z, _set_origin_z, _del_origin_z)
    
        @property
        def origin_z__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def origin_z__type(self):
            return ProtoBase.TYPE_sint32
    
        def _finalize_origin_z(cls):
            if is_string(ProtoBase.TYPE_sint32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_sint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_sint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_sint32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_origin_z)
    
        
        def _get_volume(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_uint32, 'volume')
                self._cache[4] = r
            return r
    
        def _establish_parentage_volume(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_volume), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_volume
                    v._pbf_establish_parent_callback = self._establish_parentage_volume
    
        def _set_volume(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_volume(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field volume"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_uint32
    
        def _mod_volume(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_uint32
    
        def _del_volume(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "volume"
    
        volume = property(_get_volume, _set_volume, _del_volume)
    
        @property
        def volume__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def volume__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_volume(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_volume)
    
        
        def _get_delay_value(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                r = self._buf_get(5, ProtoBase.TYPE_float, 'delay_value')
                self._cache[5] = r
            return r
    
        def _establish_parentage_delay_value(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_delay_value), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_delay_value
                    v._pbf_establish_parent_callback = self._establish_parentage_delay_value
    
        def _set_delay_value(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_delay_value(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field delay_value"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = ProtoBase.TYPE_float
    
        def _mod_delay_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = ProtoBase.TYPE_float
    
        def _del_delay_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "delay_value"
    
        delay_value = property(_get_delay_value, _set_delay_value, _del_delay_value)
    
        @property
        def delay_value__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def delay_value__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_delay_value(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(5)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_delay_value)
    
        
        def _get_sequence_number(self):
            if 6 in self._cache:
                r = self._cache[6]
            else:
                r = self._buf_get(6, ProtoBase.TYPE_int32, 'sequence_number')
                self._cache[6] = r
            return r
    
        def _establish_parentage_sequence_number(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_sequence_number), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_sequence_number
                    v._pbf_establish_parent_callback = self._establish_parentage_sequence_number
    
        def _set_sequence_number(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_sequence_number(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field sequence_number"
                raise ProtoValueError(list_assign_error)
            self._cache[6] = v
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _mod_sequence_number(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _del_sequence_number(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 6 in self._cache:
                del self._cache[6]
            if 6 in self._mods:
                del self._mods[6]
            self._buf_del(6)
    
        _pb_field_name_6 = "sequence_number"
    
        sequence_number = property(_get_sequence_number, _set_sequence_number, _del_sequence_number)
    
        @property
        def sequence_number__exists(self):
            return 6 in self._mods or self._buf_exists(6)
    
        @property
        def sequence_number__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_sequence_number(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(6)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(6)
    
        _pbf_finalizers.append(_finalize_sequence_number)
    
        
        def _get_entity_index(self):
            if 7 in self._cache:
                r = self._cache[7]
            else:
                r = self._buf_get(7, ProtoBase.TYPE_int32, 'entity_index')
                self._cache[7] = r
            return r
    
        def _establish_parentage_entity_index(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_entity_index), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_entity_index
                    v._pbf_establish_parent_callback = self._establish_parentage_entity_index
    
        def _set_entity_index(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_entity_index(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field entity_index"
                raise ProtoValueError(list_assign_error)
            self._cache[7] = v
            self._mods[7] = ProtoBase.TYPE_int32
    
        def _mod_entity_index(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[7] = ProtoBase.TYPE_int32
    
        def _del_entity_index(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 7 in self._cache:
                del self._cache[7]
            if 7 in self._mods:
                del self._mods[7]
            self._buf_del(7)
    
        _pb_field_name_7 = "entity_index"
    
        entity_index = property(_get_entity_index, _set_entity_index, _del_entity_index)
    
        @property
        def entity_index__exists(self):
            return 7 in self._mods or self._buf_exists(7)
    
        @property
        def entity_index__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_entity_index(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(7)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(7)
    
        _pbf_finalizers.append(_finalize_entity_index)
    
        
        def _get_channel(self):
            if 8 in self._cache:
                r = self._cache[8]
            else:
                r = self._buf_get(8, ProtoBase.TYPE_int32, 'channel')
                self._cache[8] = r
            return r
    
        def _establish_parentage_channel(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_channel), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_channel
                    v._pbf_establish_parent_callback = self._establish_parentage_channel
    
        def _set_channel(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_channel(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field channel"
                raise ProtoValueError(list_assign_error)
            self._cache[8] = v
            self._mods[8] = ProtoBase.TYPE_int32
    
        def _mod_channel(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[8] = ProtoBase.TYPE_int32
    
        def _del_channel(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 8 in self._cache:
                del self._cache[8]
            if 8 in self._mods:
                del self._mods[8]
            self._buf_del(8)
    
        _pb_field_name_8 = "channel"
    
        channel = property(_get_channel, _set_channel, _del_channel)
    
        @property
        def channel__exists(self):
            return 8 in self._mods or self._buf_exists(8)
    
        @property
        def channel__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_channel(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(8)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(8)
    
        _pbf_finalizers.append(_finalize_channel)
    
        
        def _get_pitch(self):
            if 9 in self._cache:
                r = self._cache[9]
            else:
                r = self._buf_get(9, ProtoBase.TYPE_int32, 'pitch')
                self._cache[9] = r
            return r
    
        def _establish_parentage_pitch(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_pitch), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_pitch
                    v._pbf_establish_parent_callback = self._establish_parentage_pitch
    
        def _set_pitch(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_pitch(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field pitch"
                raise ProtoValueError(list_assign_error)
            self._cache[9] = v
            self._mods[9] = ProtoBase.TYPE_int32
    
        def _mod_pitch(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[9] = ProtoBase.TYPE_int32
    
        def _del_pitch(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 9 in self._cache:
                del self._cache[9]
            if 9 in self._mods:
                del self._mods[9]
            self._buf_del(9)
    
        _pb_field_name_9 = "pitch"
    
        pitch = property(_get_pitch, _set_pitch, _del_pitch)
    
        @property
        def pitch__exists(self):
            return 9 in self._mods or self._buf_exists(9)
    
        @property
        def pitch__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_pitch(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(9)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(9)
    
        _pbf_finalizers.append(_finalize_pitch)
    
        
        def _get_flags(self):
            if 10 in self._cache:
                r = self._cache[10]
            else:
                r = self._buf_get(10, ProtoBase.TYPE_int32, 'flags')
                self._cache[10] = r
            return r
    
        def _establish_parentage_flags(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_flags), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_flags
                    v._pbf_establish_parent_callback = self._establish_parentage_flags
    
        def _set_flags(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_flags(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field flags"
                raise ProtoValueError(list_assign_error)
            self._cache[10] = v
            self._mods[10] = ProtoBase.TYPE_int32
    
        def _mod_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[10] = ProtoBase.TYPE_int32
    
        def _del_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 10 in self._cache:
                del self._cache[10]
            if 10 in self._mods:
                del self._mods[10]
            self._buf_del(10)
    
        _pb_field_name_10 = "flags"
    
        flags = property(_get_flags, _set_flags, _del_flags)
    
        @property
        def flags__exists(self):
            return 10 in self._mods or self._buf_exists(10)
    
        @property
        def flags__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_flags(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(10)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(10)
    
        _pbf_finalizers.append(_finalize_flags)
    
        
        def _get_sound_num(self):
            if 11 in self._cache:
                r = self._cache[11]
            else:
                r = self._buf_get(11, ProtoBase.TYPE_uint32, 'sound_num')
                self._cache[11] = r
            return r
    
        def _establish_parentage_sound_num(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_sound_num), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_sound_num
                    v._pbf_establish_parent_callback = self._establish_parentage_sound_num
    
        def _set_sound_num(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_sound_num(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field sound_num"
                raise ProtoValueError(list_assign_error)
            self._cache[11] = v
            self._mods[11] = ProtoBase.TYPE_uint32
    
        def _mod_sound_num(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[11] = ProtoBase.TYPE_uint32
    
        def _del_sound_num(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 11 in self._cache:
                del self._cache[11]
            if 11 in self._mods:
                del self._mods[11]
            self._buf_del(11)
    
        _pb_field_name_11 = "sound_num"
    
        sound_num = property(_get_sound_num, _set_sound_num, _del_sound_num)
    
        @property
        def sound_num__exists(self):
            return 11 in self._mods or self._buf_exists(11)
    
        @property
        def sound_num__type(self):
            return ProtoBase.TYPE_uint32
    
        def _finalize_sound_num(cls):
            if is_string(ProtoBase.TYPE_uint32):
                cls._pbf_strings.append(11)
            elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                    cls._pbf_strings.append(11)
    
        _pbf_finalizers.append(_finalize_sound_num)
    
        
        def _get_sound_num_handle(self):
            if 12 in self._cache:
                r = self._cache[12]
            else:
                r = self._buf_get(12, ProtoBase.TYPE_fixed32, 'sound_num_handle')
                self._cache[12] = r
            return r
    
        def _establish_parentage_sound_num_handle(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_sound_num_handle), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_sound_num_handle
                    v._pbf_establish_parent_callback = self._establish_parentage_sound_num_handle
    
        def _set_sound_num_handle(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_sound_num_handle(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field sound_num_handle"
                raise ProtoValueError(list_assign_error)
            self._cache[12] = v
            self._mods[12] = ProtoBase.TYPE_fixed32
    
        def _mod_sound_num_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[12] = ProtoBase.TYPE_fixed32
    
        def _del_sound_num_handle(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 12 in self._cache:
                del self._cache[12]
            if 12 in self._mods:
                del self._mods[12]
            self._buf_del(12)
    
        _pb_field_name_12 = "sound_num_handle"
    
        sound_num_handle = property(_get_sound_num_handle, _set_sound_num_handle, _del_sound_num_handle)
    
        @property
        def sound_num_handle__exists(self):
            return 12 in self._mods or self._buf_exists(12)
    
        @property
        def sound_num_handle__type(self):
            return ProtoBase.TYPE_fixed32
    
        def _finalize_sound_num_handle(cls):
            if is_string(ProtoBase.TYPE_fixed32):
                cls._pbf_strings.append(12)
            elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                    cls._pbf_strings.append(12)
    
        _pbf_finalizers.append(_finalize_sound_num_handle)
    
        
        def _get_speaker_entity(self):
            if 13 in self._cache:
                r = self._cache[13]
            else:
                r = self._buf_get(13, ProtoBase.TYPE_int32, 'speaker_entity')
                self._cache[13] = r
            return r
    
        def _establish_parentage_speaker_entity(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_speaker_entity), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_speaker_entity
                    v._pbf_establish_parent_callback = self._establish_parentage_speaker_entity
    
        def _set_speaker_entity(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_speaker_entity(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field speaker_entity"
                raise ProtoValueError(list_assign_error)
            self._cache[13] = v
            self._mods[13] = ProtoBase.TYPE_int32
    
        def _mod_speaker_entity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[13] = ProtoBase.TYPE_int32
    
        def _del_speaker_entity(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 13 in self._cache:
                del self._cache[13]
            if 13 in self._mods:
                del self._mods[13]
            self._buf_del(13)
    
        _pb_field_name_13 = "speaker_entity"
    
        speaker_entity = property(_get_speaker_entity, _set_speaker_entity, _del_speaker_entity)
    
        @property
        def speaker_entity__exists(self):
            return 13 in self._mods or self._buf_exists(13)
    
        @property
        def speaker_entity__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_speaker_entity(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(13)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(13)
    
        _pbf_finalizers.append(_finalize_speaker_entity)
    
        
        def _get_random_seed(self):
            if 14 in self._cache:
                r = self._cache[14]
            else:
                r = self._buf_get(14, ProtoBase.TYPE_int32, 'random_seed')
                self._cache[14] = r
            return r
    
        def _establish_parentage_random_seed(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_random_seed), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_random_seed
                    v._pbf_establish_parent_callback = self._establish_parentage_random_seed
    
        def _set_random_seed(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_random_seed(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field random_seed"
                raise ProtoValueError(list_assign_error)
            self._cache[14] = v
            self._mods[14] = ProtoBase.TYPE_int32
    
        def _mod_random_seed(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[14] = ProtoBase.TYPE_int32
    
        def _del_random_seed(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 14 in self._cache:
                del self._cache[14]
            if 14 in self._mods:
                del self._mods[14]
            self._buf_del(14)
    
        _pb_field_name_14 = "random_seed"
    
        random_seed = property(_get_random_seed, _set_random_seed, _del_random_seed)
    
        @property
        def random_seed__exists(self):
            return 14 in self._mods or self._buf_exists(14)
    
        @property
        def random_seed__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_random_seed(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(14)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(14)
    
        _pbf_finalizers.append(_finalize_random_seed)
    
        
        def _get_sound_level(self):
            if 15 in self._cache:
                r = self._cache[15]
            else:
                r = self._buf_get(15, ProtoBase.TYPE_int32, 'sound_level')
                self._cache[15] = r
            return r
    
        def _establish_parentage_sound_level(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_sound_level), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_sound_level
                    v._pbf_establish_parent_callback = self._establish_parentage_sound_level
    
        def _set_sound_level(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_sound_level(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field sound_level"
                raise ProtoValueError(list_assign_error)
            self._cache[15] = v
            self._mods[15] = ProtoBase.TYPE_int32
    
        def _mod_sound_level(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[15] = ProtoBase.TYPE_int32
    
        def _del_sound_level(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 15 in self._cache:
                del self._cache[15]
            if 15 in self._mods:
                del self._mods[15]
            self._buf_del(15)
    
        _pb_field_name_15 = "sound_level"
    
        sound_level = property(_get_sound_level, _set_sound_level, _del_sound_level)
    
        @property
        def sound_level__exists(self):
            return 15 in self._mods or self._buf_exists(15)
    
        @property
        def sound_level__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_sound_level(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(15)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(15)
    
        _pbf_finalizers.append(_finalize_sound_level)
    
        
        def _get_is_sentence(self):
            if 16 in self._cache:
                r = self._cache[16]
            else:
                r = self._buf_get(16, ProtoBase.TYPE_bool, 'is_sentence')
                self._cache[16] = r
            return r
    
        def _establish_parentage_is_sentence(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_is_sentence), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_is_sentence
                    v._pbf_establish_parent_callback = self._establish_parentage_is_sentence
    
        def _set_is_sentence(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_is_sentence(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field is_sentence"
                raise ProtoValueError(list_assign_error)
            self._cache[16] = v
            self._mods[16] = ProtoBase.TYPE_bool
    
        def _mod_is_sentence(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[16] = ProtoBase.TYPE_bool
    
        def _del_is_sentence(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 16 in self._cache:
                del self._cache[16]
            if 16 in self._mods:
                del self._mods[16]
            self._buf_del(16)
    
        _pb_field_name_16 = "is_sentence"
    
        is_sentence = property(_get_is_sentence, _set_is_sentence, _del_is_sentence)
    
        @property
        def is_sentence__exists(self):
            return 16 in self._mods or self._buf_exists(16)
    
        @property
        def is_sentence__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_is_sentence(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(16)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(16)
    
        _pbf_finalizers.append(_finalize_is_sentence)
    
        
        def _get_is_ambient(self):
            if 17 in self._cache:
                r = self._cache[17]
            else:
                r = self._buf_get(17, ProtoBase.TYPE_bool, 'is_ambient')
                self._cache[17] = r
            return r
    
        def _establish_parentage_is_ambient(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_is_ambient), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_is_ambient
                    v._pbf_establish_parent_callback = self._establish_parentage_is_ambient
    
        def _set_is_ambient(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_is_ambient(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field is_ambient"
                raise ProtoValueError(list_assign_error)
            self._cache[17] = v
            self._mods[17] = ProtoBase.TYPE_bool
    
        def _mod_is_ambient(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[17] = ProtoBase.TYPE_bool
    
        def _del_is_ambient(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 17 in self._cache:
                del self._cache[17]
            if 17 in self._mods:
                del self._mods[17]
            self._buf_del(17)
    
        _pb_field_name_17 = "is_ambient"
    
        is_ambient = property(_get_is_ambient, _set_is_ambient, _del_is_ambient)
    
        @property
        def is_ambient__exists(self):
            return 17 in self._mods or self._buf_exists(17)
    
        @property
        def is_ambient__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_is_ambient(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(17)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(17)
    
        _pbf_finalizers.append(_finalize_is_ambient)
    
        
    TYPE_sounddata_t = sounddata_t
    _PB_finalizers.append('CSVCMsg_Sounds.sounddata_t')
    
    TYPE_sounddata_t = sounddata_t

    def _get_reliable_sound(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'reliable_sound')
            self._cache[1] = r
        return r

    def _establish_parentage_reliable_sound(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_reliable_sound), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_reliable_sound
                v._pbf_establish_parent_callback = self._establish_parentage_reliable_sound

    def _set_reliable_sound(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_reliable_sound(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field reliable_sound"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_reliable_sound(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_reliable_sound(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "reliable_sound"

    reliable_sound = property(_get_reliable_sound, _set_reliable_sound, _del_reliable_sound)

    @property
    def reliable_sound__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def reliable_sound__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_reliable_sound(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_reliable_sound)


    class Repeated_sounds(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsg_Sounds.TYPE_sounddata_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_sounds = Repeated_sounds


    @property
    def sounds__stream(self):
        if 2 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[2]]
        return self._get_repeated(2, self.TYPE_Repeated_sounds, "sounds", lazy=True)

    def sounds__fast_append(self, value):
        self._append_to_repeated(2, self.TYPE_Repeated_sounds, value)

    def _get_sounds(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_sounds, 'sounds')
            self._cache[2] = r
        return r

    def _establish_parentage_sounds(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_sounds), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_sounds
                v._pbf_establish_parent_callback = self._establish_parentage_sounds

    def _set_sounds(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_sounds(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field sounds"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_sounds

    def _mod_sounds(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_sounds

    def _del_sounds(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "sounds"

    sounds = property(_get_sounds, _set_sounds, _del_sounds)

    @property
    def sounds__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def sounds__type(self):
        return self.TYPE_Repeated_sounds

    def _finalize_sounds(cls):
        if is_string(cls.TYPE_Repeated_sounds):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_sounds) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_sounds, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_sounds.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_sounds)


TYPE_CSVCMsg_Sounds = CSVCMsg_Sounds
_PB_finalizers.append('CSVCMsg_Sounds')

class CSVCMsg_Prefetch(ProtoBase):
    _required = []
    _field_map = {'sound_index': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['sound_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_sound_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'sound_index')
            self._cache[1] = r
        return r

    def _establish_parentage_sound_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_sound_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_sound_index
                v._pbf_establish_parent_callback = self._establish_parentage_sound_index

    def _set_sound_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_sound_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field sound_index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_sound_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_sound_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "sound_index"

    sound_index = property(_get_sound_index, _set_sound_index, _del_sound_index)

    @property
    def sound_index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def sound_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_sound_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_sound_index)


TYPE_CSVCMsg_Prefetch = CSVCMsg_Prefetch
_PB_finalizers.append('CSVCMsg_Prefetch')

class CSVCMsg_SetView(ProtoBase):
    _required = []
    _field_map = {'entity_index': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['entity_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_entity_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'entity_index')
            self._cache[1] = r
        return r

    def _establish_parentage_entity_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_index
                v._pbf_establish_parent_callback = self._establish_parentage_entity_index

    def _set_entity_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "entity_index"

    entity_index = property(_get_entity_index, _set_entity_index, _del_entity_index)

    @property
    def entity_index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def entity_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_entity_index)


TYPE_CSVCMsg_SetView = CSVCMsg_SetView
_PB_finalizers.append('CSVCMsg_SetView')

class CSVCMsg_FixAngle(ProtoBase):
    _required = []
    _field_map = {'relative': 1, 'angle': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['relative', 'angle']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_relative(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'relative')
            self._cache[1] = r
        return r

    def _establish_parentage_relative(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_relative), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_relative
                v._pbf_establish_parent_callback = self._establish_parentage_relative

    def _set_relative(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_relative(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field relative"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_relative(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_relative(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "relative"

    relative = property(_get_relative, _set_relative, _del_relative)

    @property
    def relative__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def relative__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_relative(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_relative)


    def _get_angle(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CMsgQAngle, 'angle')
            self._cache[2] = r
        return r

    def _establish_parentage_angle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_angle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_angle
                v._pbf_establish_parent_callback = self._establish_parentage_angle

    def _set_angle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_angle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field angle"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CMsgQAngle

    def _mod_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CMsgQAngle

    def _del_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "angle"

    angle = property(_get_angle, _set_angle, _del_angle)

    @property
    def angle__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def angle__type(self):
        return TYPE_CMsgQAngle

    def _finalize_angle(cls):
        if is_string(TYPE_CMsgQAngle):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CMsgQAngle) is _PB_type:
            assert issubclass(TYPE_CMsgQAngle, RepeatedSequence)
            if is_string(TYPE_CMsgQAngle.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_angle)


TYPE_CSVCMsg_FixAngle = CSVCMsg_FixAngle
_PB_finalizers.append('CSVCMsg_FixAngle')

class CSVCMsg_CrosshairAngle(ProtoBase):
    _required = []
    _field_map = {'angle': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['angle']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_angle(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsgQAngle, 'angle')
            self._cache[1] = r
        return r

    def _establish_parentage_angle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_angle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_angle
                v._pbf_establish_parent_callback = self._establish_parentage_angle

    def _set_angle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_angle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field angle"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsgQAngle

    def _mod_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsgQAngle

    def _del_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "angle"

    angle = property(_get_angle, _set_angle, _del_angle)

    @property
    def angle__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def angle__type(self):
        return TYPE_CMsgQAngle

    def _finalize_angle(cls):
        if is_string(TYPE_CMsgQAngle):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsgQAngle) is _PB_type:
            assert issubclass(TYPE_CMsgQAngle, RepeatedSequence)
            if is_string(TYPE_CMsgQAngle.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_angle)


TYPE_CSVCMsg_CrosshairAngle = CSVCMsg_CrosshairAngle
_PB_finalizers.append('CSVCMsg_CrosshairAngle')

class CSVCMsg_BSPDecal(ProtoBase):
    _required = []
    _field_map = {'decal_texture_index': 2, 'entity_index': 3, 'pos': 1, 'low_priority': 5, 'model_index': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['pos', 'decal_texture_index', 'entity_index', 'model_index', 'low_priority']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_pos(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CMsgVector, 'pos')
            self._cache[1] = r
        return r

    def _establish_parentage_pos(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_pos), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_pos
                v._pbf_establish_parent_callback = self._establish_parentage_pos

    def _set_pos(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_pos(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field pos"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CMsgVector

    def _mod_pos(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CMsgVector

    def _del_pos(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "pos"

    pos = property(_get_pos, _set_pos, _del_pos)

    @property
    def pos__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def pos__type(self):
        return TYPE_CMsgVector

    def _finalize_pos(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_pos)


    def _get_decal_texture_index(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'decal_texture_index')
            self._cache[2] = r
        return r

    def _establish_parentage_decal_texture_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_decal_texture_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_decal_texture_index
                v._pbf_establish_parent_callback = self._establish_parentage_decal_texture_index

    def _set_decal_texture_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_decal_texture_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field decal_texture_index"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_decal_texture_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_decal_texture_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "decal_texture_index"

    decal_texture_index = property(_get_decal_texture_index, _set_decal_texture_index, _del_decal_texture_index)

    @property
    def decal_texture_index__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def decal_texture_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_decal_texture_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_decal_texture_index)


    def _get_entity_index(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'entity_index')
            self._cache[3] = r
        return r

    def _establish_parentage_entity_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_index
                v._pbf_establish_parent_callback = self._establish_parentage_entity_index

    def _set_entity_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_index"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_entity_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "entity_index"

    entity_index = property(_get_entity_index, _set_entity_index, _del_entity_index)

    @property
    def entity_index__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def entity_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_entity_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_entity_index)


    def _get_model_index(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'model_index')
            self._cache[4] = r
        return r

    def _establish_parentage_model_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_model_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_model_index
                v._pbf_establish_parent_callback = self._establish_parentage_model_index

    def _set_model_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_model_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field model_index"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_model_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_model_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "model_index"

    model_index = property(_get_model_index, _set_model_index, _del_model_index)

    @property
    def model_index__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def model_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_model_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_model_index)


    def _get_low_priority(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bool, 'low_priority')
            self._cache[5] = r
        return r

    def _establish_parentage_low_priority(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_low_priority), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_low_priority
                v._pbf_establish_parent_callback = self._establish_parentage_low_priority

    def _set_low_priority(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_low_priority(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field low_priority"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bool

    def _mod_low_priority(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bool

    def _del_low_priority(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "low_priority"

    low_priority = property(_get_low_priority, _set_low_priority, _del_low_priority)

    @property
    def low_priority__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def low_priority__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_low_priority(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_low_priority)


TYPE_CSVCMsg_BSPDecal = CSVCMsg_BSPDecal
_PB_finalizers.append('CSVCMsg_BSPDecal')

class CSVCMsg_SplitScreen(ProtoBase):
    _required = []
    _field_map = {'slot': 2, 'player_index': 3, 'type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['type', 'slot', 'player_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            try:
                r = self._buf_get(1, TYPE_ESplitScreenMessageType, 'type')
            except:
                r = MSG_SPLITSCREEN_ADDUSER
            self._cache[1] = r
        return r

    def _establish_parentage_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_type
                v._pbf_establish_parent_callback = self._establish_parentage_type

    def _set_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_ESplitScreenMessageType

    def _mod_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_ESplitScreenMessageType

    def _del_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "type"

    type = property(_get_type, _set_type, _del_type)

    @property
    def type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def type__type(self):
        return TYPE_ESplitScreenMessageType

    def _finalize_type(cls):
        if is_string(TYPE_ESplitScreenMessageType):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_ESplitScreenMessageType) is _PB_type:
            assert issubclass(TYPE_ESplitScreenMessageType, RepeatedSequence)
            if is_string(TYPE_ESplitScreenMessageType.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_type)


    def _get_slot(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'slot')
            self._cache[2] = r
        return r

    def _establish_parentage_slot(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_slot), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_slot
                v._pbf_establish_parent_callback = self._establish_parentage_slot

    def _set_slot(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_slot(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field slot"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_slot(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "slot"

    slot = property(_get_slot, _set_slot, _del_slot)

    @property
    def slot__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def slot__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_slot(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_slot)


    def _get_player_index(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'player_index')
            self._cache[3] = r
        return r

    def _establish_parentage_player_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_index
                v._pbf_establish_parent_callback = self._establish_parentage_player_index

    def _set_player_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_index"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_player_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_player_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "player_index"

    player_index = property(_get_player_index, _set_player_index, _del_player_index)

    @property
    def player_index__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def player_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_player_index)


TYPE_CSVCMsg_SplitScreen = CSVCMsg_SplitScreen
_PB_finalizers.append('CSVCMsg_SplitScreen')

class CSVCMsg_GetCvarValue(ProtoBase):
    _required = []
    _field_map = {'cookie': 1, 'cvar_name': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['cookie', 'cvar_name']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_cookie(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'cookie')
            self._cache[1] = r
        return r

    def _establish_parentage_cookie(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cookie), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cookie
                v._pbf_establish_parent_callback = self._establish_parentage_cookie

    def _set_cookie(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cookie(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cookie"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_cookie(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_cookie(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "cookie"

    cookie = property(_get_cookie, _set_cookie, _del_cookie)

    @property
    def cookie__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def cookie__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_cookie(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_cookie)


    def _get_cvar_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'cvar_name')
            self._cache[2] = r
        return r

    def _establish_parentage_cvar_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_cvar_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_cvar_name
                v._pbf_establish_parent_callback = self._establish_parentage_cvar_name

    def _set_cvar_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_cvar_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field cvar_name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_cvar_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_cvar_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "cvar_name"

    cvar_name = property(_get_cvar_name, _set_cvar_name, _del_cvar_name)

    @property
    def cvar_name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def cvar_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_cvar_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_cvar_name)


TYPE_CSVCMsg_GetCvarValue = CSVCMsg_GetCvarValue
_PB_finalizers.append('CSVCMsg_GetCvarValue')

class CSVCMsg_Menu(ProtoBase):
    _required = []
    _field_map = {'dialog_type': 1, 'menu_key_values': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['dialog_type', 'menu_key_values']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_dialog_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'dialog_type')
            self._cache[1] = r
        return r

    def _establish_parentage_dialog_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_dialog_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_dialog_type
                v._pbf_establish_parent_callback = self._establish_parentage_dialog_type

    def _set_dialog_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_dialog_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field dialog_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_dialog_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_dialog_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "dialog_type"

    dialog_type = property(_get_dialog_type, _set_dialog_type, _del_dialog_type)

    @property
    def dialog_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def dialog_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_dialog_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_dialog_type)


    def _get_menu_key_values(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bytes, 'menu_key_values')
            self._cache[2] = r
        return r

    def _establish_parentage_menu_key_values(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_menu_key_values), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_menu_key_values
                v._pbf_establish_parent_callback = self._establish_parentage_menu_key_values

    def _set_menu_key_values(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_menu_key_values(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field menu_key_values"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bytes

    def _mod_menu_key_values(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bytes

    def _del_menu_key_values(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "menu_key_values"

    menu_key_values = property(_get_menu_key_values, _set_menu_key_values, _del_menu_key_values)

    @property
    def menu_key_values__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def menu_key_values__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_menu_key_values(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_menu_key_values)


TYPE_CSVCMsg_Menu = CSVCMsg_Menu
_PB_finalizers.append('CSVCMsg_Menu')

class CSVCMsg_SendTable(ProtoBase):
    _required = []
    _field_map = {'is_end': 1, 'props': 4, 'net_table_name': 2, 'needs_decoder': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['is_end', 'net_table_name', 'needs_decoder', 'props']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class sendprop_t(ProtoBase):
        _required = []
        _field_map = {'num_elements': 6, 'dt_name': 5, 'low_value': 7, 'priority': 4, 'var_name': 2, 'flags': 3, 'num_bits': 9, 'high_value': 8, 'type': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['type', 'var_name', 'flags', 'priority', 'dt_name', 'num_elements', 'low_value', 'high_value', 'num_bits']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_type(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'type')
                self._cache[1] = r
            return r
    
        def _establish_parentage_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_type
                    v._pbf_establish_parent_callback = self._establish_parentage_type
    
        def _set_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field type"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "type"
    
        type = property(_get_type, _set_type, _del_type)
    
        @property
        def type__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_type)
    
        
        def _get_var_name(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'var_name')
                self._cache[2] = r
            return r
    
        def _establish_parentage_var_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_var_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_var_name
                    v._pbf_establish_parent_callback = self._establish_parentage_var_name
    
        def _set_var_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_var_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field var_name"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_var_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_var_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "var_name"
    
        var_name = property(_get_var_name, _set_var_name, _del_var_name)
    
        @property
        def var_name__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def var_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_var_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_var_name)
    
        
        def _get_flags(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_int32, 'flags')
                self._cache[3] = r
            return r
    
        def _establish_parentage_flags(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_flags), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_flags
                    v._pbf_establish_parent_callback = self._establish_parentage_flags
    
        def _set_flags(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_flags(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field flags"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _mod_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_int32
    
        def _del_flags(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "flags"
    
        flags = property(_get_flags, _set_flags, _del_flags)
    
        @property
        def flags__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def flags__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_flags(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_flags)
    
        
        def _get_priority(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_int32, 'priority')
                self._cache[4] = r
            return r
    
        def _establish_parentage_priority(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_priority), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_priority
                    v._pbf_establish_parent_callback = self._establish_parentage_priority
    
        def _set_priority(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_priority(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field priority"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _mod_priority(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _del_priority(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "priority"
    
        priority = property(_get_priority, _set_priority, _del_priority)
    
        @property
        def priority__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def priority__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_priority(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_priority)
    
        
        def _get_dt_name(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                r = self._buf_get(5, ProtoBase.TYPE_string, 'dt_name')
                self._cache[5] = r
            return r
    
        def _establish_parentage_dt_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_dt_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_dt_name
                    v._pbf_establish_parent_callback = self._establish_parentage_dt_name
    
        def _set_dt_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_dt_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field dt_name"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = ProtoBase.TYPE_string
    
        def _mod_dt_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = ProtoBase.TYPE_string
    
        def _del_dt_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "dt_name"
    
        dt_name = property(_get_dt_name, _set_dt_name, _del_dt_name)
    
        @property
        def dt_name__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def dt_name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_dt_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(5)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_dt_name)
    
        
        def _get_num_elements(self):
            if 6 in self._cache:
                r = self._cache[6]
            else:
                r = self._buf_get(6, ProtoBase.TYPE_int32, 'num_elements')
                self._cache[6] = r
            return r
    
        def _establish_parentage_num_elements(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_num_elements), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_num_elements
                    v._pbf_establish_parent_callback = self._establish_parentage_num_elements
    
        def _set_num_elements(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_num_elements(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field num_elements"
                raise ProtoValueError(list_assign_error)
            self._cache[6] = v
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _mod_num_elements(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _del_num_elements(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 6 in self._cache:
                del self._cache[6]
            if 6 in self._mods:
                del self._mods[6]
            self._buf_del(6)
    
        _pb_field_name_6 = "num_elements"
    
        num_elements = property(_get_num_elements, _set_num_elements, _del_num_elements)
    
        @property
        def num_elements__exists(self):
            return 6 in self._mods or self._buf_exists(6)
    
        @property
        def num_elements__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_num_elements(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(6)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(6)
    
        _pbf_finalizers.append(_finalize_num_elements)
    
        
        def _get_low_value(self):
            if 7 in self._cache:
                r = self._cache[7]
            else:
                r = self._buf_get(7, ProtoBase.TYPE_float, 'low_value')
                self._cache[7] = r
            return r
    
        def _establish_parentage_low_value(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_low_value), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_low_value
                    v._pbf_establish_parent_callback = self._establish_parentage_low_value
    
        def _set_low_value(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_low_value(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field low_value"
                raise ProtoValueError(list_assign_error)
            self._cache[7] = v
            self._mods[7] = ProtoBase.TYPE_float
    
        def _mod_low_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[7] = ProtoBase.TYPE_float
    
        def _del_low_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 7 in self._cache:
                del self._cache[7]
            if 7 in self._mods:
                del self._mods[7]
            self._buf_del(7)
    
        _pb_field_name_7 = "low_value"
    
        low_value = property(_get_low_value, _set_low_value, _del_low_value)
    
        @property
        def low_value__exists(self):
            return 7 in self._mods or self._buf_exists(7)
    
        @property
        def low_value__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_low_value(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(7)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(7)
    
        _pbf_finalizers.append(_finalize_low_value)
    
        
        def _get_high_value(self):
            if 8 in self._cache:
                r = self._cache[8]
            else:
                r = self._buf_get(8, ProtoBase.TYPE_float, 'high_value')
                self._cache[8] = r
            return r
    
        def _establish_parentage_high_value(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_high_value), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_high_value
                    v._pbf_establish_parent_callback = self._establish_parentage_high_value
    
        def _set_high_value(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_high_value(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field high_value"
                raise ProtoValueError(list_assign_error)
            self._cache[8] = v
            self._mods[8] = ProtoBase.TYPE_float
    
        def _mod_high_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[8] = ProtoBase.TYPE_float
    
        def _del_high_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 8 in self._cache:
                del self._cache[8]
            if 8 in self._mods:
                del self._mods[8]
            self._buf_del(8)
    
        _pb_field_name_8 = "high_value"
    
        high_value = property(_get_high_value, _set_high_value, _del_high_value)
    
        @property
        def high_value__exists(self):
            return 8 in self._mods or self._buf_exists(8)
    
        @property
        def high_value__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_high_value(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(8)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(8)
    
        _pbf_finalizers.append(_finalize_high_value)
    
        
        def _get_num_bits(self):
            if 9 in self._cache:
                r = self._cache[9]
            else:
                r = self._buf_get(9, ProtoBase.TYPE_int32, 'num_bits')
                self._cache[9] = r
            return r
    
        def _establish_parentage_num_bits(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_num_bits), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_num_bits
                    v._pbf_establish_parent_callback = self._establish_parentage_num_bits
    
        def _set_num_bits(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_num_bits(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field num_bits"
                raise ProtoValueError(list_assign_error)
            self._cache[9] = v
            self._mods[9] = ProtoBase.TYPE_int32
    
        def _mod_num_bits(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[9] = ProtoBase.TYPE_int32
    
        def _del_num_bits(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 9 in self._cache:
                del self._cache[9]
            if 9 in self._mods:
                del self._mods[9]
            self._buf_del(9)
    
        _pb_field_name_9 = "num_bits"
    
        num_bits = property(_get_num_bits, _set_num_bits, _del_num_bits)
    
        @property
        def num_bits__exists(self):
            return 9 in self._mods or self._buf_exists(9)
    
        @property
        def num_bits__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_num_bits(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(9)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(9)
    
        _pbf_finalizers.append(_finalize_num_bits)
    
        
    TYPE_sendprop_t = sendprop_t
    _PB_finalizers.append('CSVCMsg_SendTable.sendprop_t')
    
    TYPE_sendprop_t = sendprop_t

    def _get_is_end(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'is_end')
            self._cache[1] = r
        return r

    def _establish_parentage_is_end(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_end), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_end
                v._pbf_establish_parent_callback = self._establish_parentage_is_end

    def _set_is_end(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_end(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_end"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_is_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_is_end(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "is_end"

    is_end = property(_get_is_end, _set_is_end, _del_is_end)

    @property
    def is_end__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def is_end__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_end(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_is_end)


    def _get_net_table_name(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'net_table_name')
            self._cache[2] = r
        return r

    def _establish_parentage_net_table_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_net_table_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_net_table_name
                v._pbf_establish_parent_callback = self._establish_parentage_net_table_name

    def _set_net_table_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_net_table_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field net_table_name"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_net_table_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_net_table_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "net_table_name"

    net_table_name = property(_get_net_table_name, _set_net_table_name, _del_net_table_name)

    @property
    def net_table_name__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def net_table_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_net_table_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_net_table_name)


    def _get_needs_decoder(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'needs_decoder')
            self._cache[3] = r
        return r

    def _establish_parentage_needs_decoder(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_needs_decoder), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_needs_decoder
                v._pbf_establish_parent_callback = self._establish_parentage_needs_decoder

    def _set_needs_decoder(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_needs_decoder(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field needs_decoder"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_needs_decoder(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_needs_decoder(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "needs_decoder"

    needs_decoder = property(_get_needs_decoder, _set_needs_decoder, _del_needs_decoder)

    @property
    def needs_decoder__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def needs_decoder__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_needs_decoder(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_needs_decoder)


    class Repeated_props(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsg_SendTable.TYPE_sendprop_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_props = Repeated_props


    @property
    def props__stream(self):
        if 4 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[4]]
        return self._get_repeated(4, self.TYPE_Repeated_props, "props", lazy=True)

    def props__fast_append(self, value):
        self._append_to_repeated(4, self.TYPE_Repeated_props, value)

    def _get_props(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, self.TYPE_Repeated_props, 'props')
            self._cache[4] = r
        return r

    def _establish_parentage_props(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_props), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_props
                v._pbf_establish_parent_callback = self._establish_parentage_props

    def _set_props(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_props(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field props"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = self.TYPE_Repeated_props

    def _mod_props(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = self.TYPE_Repeated_props

    def _del_props(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "props"

    props = property(_get_props, _set_props, _del_props)

    @property
    def props__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def props__type(self):
        return self.TYPE_Repeated_props

    def _finalize_props(cls):
        if is_string(cls.TYPE_Repeated_props):
            cls._pbf_strings.append(4)
        elif _PB_type(cls.TYPE_Repeated_props) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_props, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_props.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_props)


TYPE_CSVCMsg_SendTable = CSVCMsg_SendTable
_PB_finalizers.append('CSVCMsg_SendTable')

class CSVCMsg_GameEventList(ProtoBase):
    _required = []
    _field_map = {'descriptors': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['descriptors']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class key_t(ProtoBase):
        _required = []
        _field_map = {'type': 1, 'name': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['type', 'name']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_type(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'type')
                self._cache[1] = r
            return r
    
        def _establish_parentage_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_type
                    v._pbf_establish_parent_callback = self._establish_parentage_type
    
        def _set_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field type"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "type"
    
        type = property(_get_type, _set_type, _del_type)
    
        @property
        def type__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_type)
    
        
        def _get_name(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'name')
                self._cache[2] = r
            return r
    
        def _establish_parentage_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_name
                    v._pbf_establish_parent_callback = self._establish_parentage_name
    
        def _set_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field name"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "name"
    
        name = property(_get_name, _set_name, _del_name)
    
        @property
        def name__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_name)
    
        
    TYPE_key_t = key_t
    _PB_finalizers.append('CSVCMsg_GameEventList.key_t')
    
    TYPE_key_t = key_t
    
    class descriptor_t(ProtoBase):
        _required = []
        _field_map = {'eventid': 1, 'keys': 3, 'name': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['eventid', 'name', 'keys']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_eventid(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'eventid')
                self._cache[1] = r
            return r
    
        def _establish_parentage_eventid(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_eventid), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_eventid
                    v._pbf_establish_parent_callback = self._establish_parentage_eventid
    
        def _set_eventid(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_eventid(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field eventid"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_eventid(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_eventid(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "eventid"
    
        eventid = property(_get_eventid, _set_eventid, _del_eventid)
    
        @property
        def eventid__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def eventid__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_eventid(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_eventid)
    
        
        def _get_name(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'name')
                self._cache[2] = r
            return r
    
        def _establish_parentage_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_name
                    v._pbf_establish_parent_callback = self._establish_parentage_name
    
        def _set_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field name"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "name"
    
        name = property(_get_name, _set_name, _del_name)
    
        @property
        def name__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_name)
    
        
        class Repeated_keys(RepeatedSequence):
            class pb_subtype(object):
                def __get__(self, instance, cls):
                    return CSVCMsg_GameEventList.TYPE_key_t
            pb_subtype = pb_subtype()
    
    
        TYPE_Repeated_keys = Repeated_keys
    
        
        @property
        def keys__stream(self):
            if 3 in self._cache:
                def acc(v):
                    v_ = lambda: v
                    return v_
                return [acc(v) for v in self._cache[3]]
            return self._get_repeated(3, self.TYPE_Repeated_keys, "keys", lazy=True)
    
        def keys__fast_append(self, value):
            self._append_to_repeated(3, self.TYPE_Repeated_keys, value)
        
        def _get_keys(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, self.TYPE_Repeated_keys, 'keys')
                self._cache[3] = r
            return r
    
        def _establish_parentage_keys(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_keys), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_keys
                    v._pbf_establish_parent_callback = self._establish_parentage_keys
    
        def _set_keys(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_keys(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field keys"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = self.TYPE_Repeated_keys
    
        def _mod_keys(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = self.TYPE_Repeated_keys
    
        def _del_keys(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "keys"
    
        keys = property(_get_keys, _set_keys, _del_keys)
    
        @property
        def keys__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def keys__type(self):
            return self.TYPE_Repeated_keys
    
        def _finalize_keys(cls):
            if is_string(cls.TYPE_Repeated_keys):
                cls._pbf_strings.append(3)
            elif _PB_type(cls.TYPE_Repeated_keys) is _PB_type:
                assert issubclass(cls.TYPE_Repeated_keys, RepeatedSequence)
                if is_string(cls.TYPE_Repeated_keys.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_keys)
    
        
    TYPE_descriptor_t = descriptor_t
    _PB_finalizers.append('CSVCMsg_GameEventList.descriptor_t')
    
    TYPE_descriptor_t = descriptor_t

    class Repeated_descriptors(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsg_GameEventList.TYPE_descriptor_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_descriptors = Repeated_descriptors


    @property
    def descriptors__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_descriptors, "descriptors", lazy=True)

    def descriptors__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_descriptors, value)

    def _get_descriptors(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_descriptors, 'descriptors')
            self._cache[1] = r
        return r

    def _establish_parentage_descriptors(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_descriptors), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_descriptors
                v._pbf_establish_parent_callback = self._establish_parentage_descriptors

    def _set_descriptors(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_descriptors(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field descriptors"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_descriptors

    def _mod_descriptors(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_descriptors

    def _del_descriptors(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "descriptors"

    descriptors = property(_get_descriptors, _set_descriptors, _del_descriptors)

    @property
    def descriptors__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def descriptors__type(self):
        return self.TYPE_Repeated_descriptors

    def _finalize_descriptors(cls):
        if is_string(cls.TYPE_Repeated_descriptors):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_descriptors) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_descriptors, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_descriptors.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_descriptors)


TYPE_CSVCMsg_GameEventList = CSVCMsg_GameEventList
_PB_finalizers.append('CSVCMsg_GameEventList')

class CSVCMsg_PacketEntities(ProtoBase):
    _required = []
    _field_map = {'baseline': 5, 'delta_from': 6, 'updated_entries': 2, 'max_entries': 1, 'is_delta': 3, 'entity_data': 7, 'update_baseline': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['max_entries', 'updated_entries', 'is_delta', 'update_baseline', 'baseline', 'delta_from', 'entity_data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_max_entries(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'max_entries')
            self._cache[1] = r
        return r

    def _establish_parentage_max_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_max_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_max_entries
                v._pbf_establish_parent_callback = self._establish_parentage_max_entries

    def _set_max_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_max_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field max_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_max_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_max_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "max_entries"

    max_entries = property(_get_max_entries, _set_max_entries, _del_max_entries)

    @property
    def max_entries__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def max_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_max_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_max_entries)


    def _get_updated_entries(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'updated_entries')
            self._cache[2] = r
        return r

    def _establish_parentage_updated_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_updated_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_updated_entries
                v._pbf_establish_parent_callback = self._establish_parentage_updated_entries

    def _set_updated_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_updated_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field updated_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_updated_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_updated_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "updated_entries"

    updated_entries = property(_get_updated_entries, _set_updated_entries, _del_updated_entries)

    @property
    def updated_entries__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def updated_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_updated_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_updated_entries)


    def _get_is_delta(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'is_delta')
            self._cache[3] = r
        return r

    def _establish_parentage_is_delta(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_is_delta), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_is_delta
                v._pbf_establish_parent_callback = self._establish_parentage_is_delta

    def _set_is_delta(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_is_delta(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field is_delta"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_is_delta(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_is_delta(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "is_delta"

    is_delta = property(_get_is_delta, _set_is_delta, _del_is_delta)

    @property
    def is_delta__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def is_delta__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_is_delta(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_is_delta)


    def _get_update_baseline(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'update_baseline')
            self._cache[4] = r
        return r

    def _establish_parentage_update_baseline(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_update_baseline), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_update_baseline
                v._pbf_establish_parent_callback = self._establish_parentage_update_baseline

    def _set_update_baseline(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_update_baseline(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field update_baseline"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_update_baseline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_update_baseline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "update_baseline"

    update_baseline = property(_get_update_baseline, _set_update_baseline, _del_update_baseline)

    @property
    def update_baseline__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def update_baseline__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_update_baseline(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_update_baseline)


    def _get_baseline(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'baseline')
            self._cache[5] = r
        return r

    def _establish_parentage_baseline(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_baseline), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_baseline
                v._pbf_establish_parent_callback = self._establish_parentage_baseline

    def _set_baseline(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_baseline(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field baseline"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_baseline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_baseline(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "baseline"

    baseline = property(_get_baseline, _set_baseline, _del_baseline)

    @property
    def baseline__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def baseline__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_baseline(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_baseline)


    def _get_delta_from(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_int32, 'delta_from')
            self._cache[6] = r
        return r

    def _establish_parentage_delta_from(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_delta_from), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_delta_from
                v._pbf_establish_parent_callback = self._establish_parentage_delta_from

    def _set_delta_from(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_delta_from(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field delta_from"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_int32

    def _mod_delta_from(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_int32

    def _del_delta_from(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "delta_from"

    delta_from = property(_get_delta_from, _set_delta_from, _del_delta_from)

    @property
    def delta_from__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def delta_from__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_delta_from(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_delta_from)


    def _get_entity_data(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_bytes, 'entity_data')
            self._cache[7] = r
        return r

    def _establish_parentage_entity_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_data
                v._pbf_establish_parent_callback = self._establish_parentage_entity_data

    def _set_entity_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_data"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_bytes

    def _mod_entity_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_bytes

    def _del_entity_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "entity_data"

    entity_data = property(_get_entity_data, _set_entity_data, _del_entity_data)

    @property
    def entity_data__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def entity_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_entity_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_entity_data)


TYPE_CSVCMsg_PacketEntities = CSVCMsg_PacketEntities
_PB_finalizers.append('CSVCMsg_PacketEntities')

class CSVCMsg_TempEntities(ProtoBase):
    _required = []
    _field_map = {'reliable': 1, 'num_entries': 2, 'entity_data': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['reliable', 'num_entries', 'entity_data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_reliable(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_bool, 'reliable')
            self._cache[1] = r
        return r

    def _establish_parentage_reliable(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_reliable), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_reliable
                v._pbf_establish_parent_callback = self._establish_parentage_reliable

    def _set_reliable(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_reliable(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field reliable"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_bool

    def _mod_reliable(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_bool

    def _del_reliable(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "reliable"

    reliable = property(_get_reliable, _set_reliable, _del_reliable)

    @property
    def reliable__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def reliable__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_reliable(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_reliable)


    def _get_num_entries(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'num_entries')
            self._cache[2] = r
        return r

    def _establish_parentage_num_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_entries
                v._pbf_establish_parent_callback = self._establish_parentage_num_entries

    def _set_num_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_num_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_num_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "num_entries"

    num_entries = property(_get_num_entries, _set_num_entries, _del_num_entries)

    @property
    def num_entries__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def num_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_num_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_num_entries)


    def _get_entity_data(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bytes, 'entity_data')
            self._cache[3] = r
        return r

    def _establish_parentage_entity_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_entity_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_entity_data
                v._pbf_establish_parent_callback = self._establish_parentage_entity_data

    def _set_entity_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_entity_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field entity_data"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bytes

    def _mod_entity_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bytes

    def _del_entity_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "entity_data"

    entity_data = property(_get_entity_data, _set_entity_data, _del_entity_data)

    @property
    def entity_data__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def entity_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_entity_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_entity_data)


TYPE_CSVCMsg_TempEntities = CSVCMsg_TempEntities
_PB_finalizers.append('CSVCMsg_TempEntities')

class CSVCMsg_CreateStringTable(ProtoBase):
    _required = []
    _field_map = {'user_data_size_bits': 6, 'name': 1, 'string_data': 8, 'max_entries': 2, 'num_entries': 3, 'flags': 7, 'user_data_size': 5, 'user_data_fixed_size': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['name', 'max_entries', 'num_entries', 'user_data_fixed_size', 'user_data_size', 'user_data_size_bits', 'flags', 'string_data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
            self._cache[1] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_name)


    def _get_max_entries(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'max_entries')
            self._cache[2] = r
        return r

    def _establish_parentage_max_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_max_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_max_entries
                v._pbf_establish_parent_callback = self._establish_parentage_max_entries

    def _set_max_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_max_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field max_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_max_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_max_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "max_entries"

    max_entries = property(_get_max_entries, _set_max_entries, _del_max_entries)

    @property
    def max_entries__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def max_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_max_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_max_entries)


    def _get_num_entries(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'num_entries')
            self._cache[3] = r
        return r

    def _establish_parentage_num_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_entries
                v._pbf_establish_parent_callback = self._establish_parentage_num_entries

    def _set_num_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_num_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_num_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "num_entries"

    num_entries = property(_get_num_entries, _set_num_entries, _del_num_entries)

    @property
    def num_entries__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def num_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_num_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_num_entries)


    def _get_user_data_fixed_size(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_bool, 'user_data_fixed_size')
            self._cache[4] = r
        return r

    def _establish_parentage_user_data_fixed_size(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_user_data_fixed_size), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_user_data_fixed_size
                v._pbf_establish_parent_callback = self._establish_parentage_user_data_fixed_size

    def _set_user_data_fixed_size(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_user_data_fixed_size(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field user_data_fixed_size"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_bool

    def _mod_user_data_fixed_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_bool

    def _del_user_data_fixed_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "user_data_fixed_size"

    user_data_fixed_size = property(_get_user_data_fixed_size, _set_user_data_fixed_size, _del_user_data_fixed_size)

    @property
    def user_data_fixed_size__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def user_data_fixed_size__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_user_data_fixed_size(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_user_data_fixed_size)


    def _get_user_data_size(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_int32, 'user_data_size')
            self._cache[5] = r
        return r

    def _establish_parentage_user_data_size(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_user_data_size), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_user_data_size
                v._pbf_establish_parent_callback = self._establish_parentage_user_data_size

    def _set_user_data_size(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_user_data_size(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field user_data_size"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_int32

    def _mod_user_data_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_int32

    def _del_user_data_size(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "user_data_size"

    user_data_size = property(_get_user_data_size, _set_user_data_size, _del_user_data_size)

    @property
    def user_data_size__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def user_data_size__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_user_data_size(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_user_data_size)


    def _get_user_data_size_bits(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_int32, 'user_data_size_bits')
            self._cache[6] = r
        return r

    def _establish_parentage_user_data_size_bits(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_user_data_size_bits), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_user_data_size_bits
                v._pbf_establish_parent_callback = self._establish_parentage_user_data_size_bits

    def _set_user_data_size_bits(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_user_data_size_bits(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field user_data_size_bits"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_int32

    def _mod_user_data_size_bits(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_int32

    def _del_user_data_size_bits(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "user_data_size_bits"

    user_data_size_bits = property(_get_user_data_size_bits, _set_user_data_size_bits, _del_user_data_size_bits)

    @property
    def user_data_size_bits__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def user_data_size_bits__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_user_data_size_bits(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_user_data_size_bits)


    def _get_flags(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_int32, 'flags')
            self._cache[7] = r
        return r

    def _establish_parentage_flags(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_flags), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_flags
                v._pbf_establish_parent_callback = self._establish_parentage_flags

    def _set_flags(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_flags(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field flags"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_int32

    def _mod_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_int32

    def _del_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "flags"

    flags = property(_get_flags, _set_flags, _del_flags)

    @property
    def flags__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def flags__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_flags(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_flags)


    def _get_string_data(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_bytes, 'string_data')
            self._cache[8] = r
        return r

    def _establish_parentage_string_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_string_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_string_data
                v._pbf_establish_parent_callback = self._establish_parentage_string_data

    def _set_string_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_string_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field string_data"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_bytes

    def _mod_string_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_bytes

    def _del_string_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "string_data"

    string_data = property(_get_string_data, _set_string_data, _del_string_data)

    @property
    def string_data__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def string_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_string_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_string_data)


TYPE_CSVCMsg_CreateStringTable = CSVCMsg_CreateStringTable
_PB_finalizers.append('CSVCMsg_CreateStringTable')

class CSVCMsg_UpdateStringTable(ProtoBase):
    _required = []
    _field_map = {'table_id': 1, 'string_data': 3, 'num_changed_entries': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['table_id', 'num_changed_entries', 'string_data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_table_id(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'table_id')
            self._cache[1] = r
        return r

    def _establish_parentage_table_id(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_table_id), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_table_id
                v._pbf_establish_parent_callback = self._establish_parentage_table_id

    def _set_table_id(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_table_id(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field table_id"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_table_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_table_id(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "table_id"

    table_id = property(_get_table_id, _set_table_id, _del_table_id)

    @property
    def table_id__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def table_id__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_table_id(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_table_id)


    def _get_num_changed_entries(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'num_changed_entries')
            self._cache[2] = r
        return r

    def _establish_parentage_num_changed_entries(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_changed_entries), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_changed_entries
                v._pbf_establish_parent_callback = self._establish_parentage_num_changed_entries

    def _set_num_changed_entries(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_changed_entries(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_changed_entries"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_num_changed_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_num_changed_entries(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "num_changed_entries"

    num_changed_entries = property(_get_num_changed_entries, _set_num_changed_entries, _del_num_changed_entries)

    @property
    def num_changed_entries__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def num_changed_entries__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_num_changed_entries(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_num_changed_entries)


    def _get_string_data(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bytes, 'string_data')
            self._cache[3] = r
        return r

    def _establish_parentage_string_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_string_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_string_data
                v._pbf_establish_parent_callback = self._establish_parentage_string_data

    def _set_string_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_string_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field string_data"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bytes

    def _mod_string_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bytes

    def _del_string_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "string_data"

    string_data = property(_get_string_data, _set_string_data, _del_string_data)

    @property
    def string_data__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def string_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_string_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_string_data)


TYPE_CSVCMsg_UpdateStringTable = CSVCMsg_UpdateStringTable
_PB_finalizers.append('CSVCMsg_UpdateStringTable')

class CSVCMsg_VoiceData(ProtoBase):
    _required = []
    _field_map = {'audible_mask': 4, 'format': 6, 'proximity': 2, 'client': 1, 'voice_data': 5, 'xuid': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['client', 'proximity', 'xuid', 'audible_mask', 'voice_data', 'format']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_client(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'client')
            self._cache[1] = r
        return r

    def _establish_parentage_client(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_client), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_client
                v._pbf_establish_parent_callback = self._establish_parentage_client

    def _set_client(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_client(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field client"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "client"

    client = property(_get_client, _set_client, _del_client)

    @property
    def client__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def client__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_client(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_client)


    def _get_proximity(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'proximity')
            self._cache[2] = r
        return r

    def _establish_parentage_proximity(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_proximity), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_proximity
                v._pbf_establish_parent_callback = self._establish_parentage_proximity

    def _set_proximity(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_proximity(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field proximity"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_proximity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_proximity(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "proximity"

    proximity = property(_get_proximity, _set_proximity, _del_proximity)

    @property
    def proximity__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def proximity__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_proximity(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_proximity)


    def _get_xuid(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_fixed64, 'xuid')
            self._cache[3] = r
        return r

    def _establish_parentage_xuid(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_xuid), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_xuid
                v._pbf_establish_parent_callback = self._establish_parentage_xuid

    def _set_xuid(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_xuid(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field xuid"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_fixed64

    def _mod_xuid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_fixed64

    def _del_xuid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "xuid"

    xuid = property(_get_xuid, _set_xuid, _del_xuid)

    @property
    def xuid__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def xuid__type(self):
        return ProtoBase.TYPE_fixed64

    def _finalize_xuid(cls):
        if is_string(ProtoBase.TYPE_fixed64):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_fixed64) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed64, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed64.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_xuid)


    def _get_audible_mask(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'audible_mask')
            self._cache[4] = r
        return r

    def _establish_parentage_audible_mask(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_audible_mask), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_audible_mask
                v._pbf_establish_parent_callback = self._establish_parentage_audible_mask

    def _set_audible_mask(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_audible_mask(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field audible_mask"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_audible_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_audible_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "audible_mask"

    audible_mask = property(_get_audible_mask, _set_audible_mask, _del_audible_mask)

    @property
    def audible_mask__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def audible_mask__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_audible_mask(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_audible_mask)


    def _get_voice_data(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_bytes, 'voice_data')
            self._cache[5] = r
        return r

    def _establish_parentage_voice_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_voice_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_voice_data
                v._pbf_establish_parent_callback = self._establish_parentage_voice_data

    def _set_voice_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_voice_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field voice_data"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_bytes

    def _mod_voice_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_bytes

    def _del_voice_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "voice_data"

    voice_data = property(_get_voice_data, _set_voice_data, _del_voice_data)

    @property
    def voice_data__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def voice_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_voice_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_voice_data)


    def _get_format(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            try:
                r = self._buf_get(6, TYPE_VoiceDataFormat_t, 'format')
            except:
                r = VOICEDATA_FORMAT_STEAM
            self._cache[6] = r
        return r

    def _establish_parentage_format(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_format), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_format
                v._pbf_establish_parent_callback = self._establish_parentage_format

    def _set_format(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_format(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field format"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = TYPE_VoiceDataFormat_t

    def _mod_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = TYPE_VoiceDataFormat_t

    def _del_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "format"

    format = property(_get_format, _set_format, _del_format)

    @property
    def format__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def format__type(self):
        return TYPE_VoiceDataFormat_t

    def _finalize_format(cls):
        if is_string(TYPE_VoiceDataFormat_t):
            cls._pbf_strings.append(6)
        elif _PB_type(TYPE_VoiceDataFormat_t) is _PB_type:
            assert issubclass(TYPE_VoiceDataFormat_t, RepeatedSequence)
            if is_string(TYPE_VoiceDataFormat_t.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_format)


TYPE_CSVCMsg_VoiceData = CSVCMsg_VoiceData
_PB_finalizers.append('CSVCMsg_VoiceData')

class CSVCMsg_PacketReliable(ProtoBase):
    _required = []
    _field_map = {'messagessize': 2, 'tick': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['tick', 'messagessize']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_tick(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'tick')
            self._cache[1] = r
        return r

    def _establish_parentage_tick(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_tick), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_tick
                v._pbf_establish_parent_callback = self._establish_parentage_tick

    def _set_tick(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_tick(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field tick"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_tick(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "tick"

    tick = property(_get_tick, _set_tick, _del_tick)

    @property
    def tick__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def tick__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_tick(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_tick)


    def _get_messagessize(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'messagessize')
            self._cache[2] = r
        return r

    def _establish_parentage_messagessize(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_messagessize), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_messagessize
                v._pbf_establish_parent_callback = self._establish_parentage_messagessize

    def _set_messagessize(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_messagessize(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field messagessize"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_messagessize(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_messagessize(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "messagessize"

    messagessize = property(_get_messagessize, _set_messagessize, _del_messagessize)

    @property
    def messagessize__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def messagessize__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_messagessize(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_messagessize)


TYPE_CSVCMsg_PacketReliable = CSVCMsg_PacketReliable
_PB_finalizers.append('CSVCMsg_PacketReliable')

class CMsgVector(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'z': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'z']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_float

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_float

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_z(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'z')
            self._cache[3] = r
        return r

    def _establish_parentage_z(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_z), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_z
                v._pbf_establish_parent_callback = self._establish_parentage_z

    def _set_z(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_z(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field z"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "z"

    z = property(_get_z, _set_z, _del_z)

    @property
    def z__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def z__type(self):
        return ProtoBase.TYPE_float

    def _finalize_z(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_z)


TYPE_CMsgVector = CMsgVector
_PB_finalizers.append('CMsgVector')

class CMsgVector2D(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_float

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_float

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


TYPE_CMsgVector2D = CMsgVector2D
_PB_finalizers.append('CMsgVector2D')

class CMsgQAngle(ProtoBase):
    _required = []
    _field_map = {'y': 2, 'x': 1, 'z': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['x', 'y', 'z']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_x(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'x')
            self._cache[1] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def x__type(self):
        return ProtoBase.TYPE_float

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'y')
            self._cache[2] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def y__type(self):
        return ProtoBase.TYPE_float

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_y)


    def _get_z(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'z')
            self._cache[3] = r
        return r

    def _establish_parentage_z(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_z), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_z
                v._pbf_establish_parent_callback = self._establish_parentage_z

    def _set_z(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_z(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field z"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_z(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "z"

    z = property(_get_z, _set_z, _del_z)

    @property
    def z__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def z__type(self):
        return ProtoBase.TYPE_float

    def _finalize_z(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_z)


TYPE_CMsgQAngle = CMsgQAngle
_PB_finalizers.append('CMsgQAngle')

class CSVCMsg_GameEvent(ProtoBase):
    _required = []
    _field_map = {'event_name': 1, 'eventid': 2, 'keys': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['event_name', 'eventid', 'keys']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class key_t(ProtoBase):
        _required = []
        _field_map = {'val_byte': 6, 'val_bool': 7, 'val_uint64': 8, 'val_long': 4, 'val_float': 3, 'val_string': 2, 'type': 1, 'val_short': 5}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['type', 'val_string', 'val_float', 'val_long', 'val_short', 'val_byte', 'val_bool', 'val_uint64']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_type(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'type')
                self._cache[1] = r
            return r
    
        def _establish_parentage_type(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_type), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_type
                    v._pbf_establish_parent_callback = self._establish_parentage_type
    
        def _set_type(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_type(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field type"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_type(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "type"
    
        type = property(_get_type, _set_type, _del_type)
    
        @property
        def type__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def type__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_type(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_type)
    
        
        def _get_val_string(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'val_string')
                self._cache[2] = r
            return r
    
        def _establish_parentage_val_string(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_string), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_string
                    v._pbf_establish_parent_callback = self._establish_parentage_val_string
    
        def _set_val_string(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_string(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_string"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_val_string(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_val_string(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "val_string"
    
        val_string = property(_get_val_string, _set_val_string, _del_val_string)
    
        @property
        def val_string__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def val_string__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_val_string(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_val_string)
    
        
        def _get_val_float(self):
            if 3 in self._cache:
                r = self._cache[3]
            else:
                r = self._buf_get(3, ProtoBase.TYPE_float, 'val_float')
                self._cache[3] = r
            return r
    
        def _establish_parentage_val_float(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_float), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_float
                    v._pbf_establish_parent_callback = self._establish_parentage_val_float
    
        def _set_val_float(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_float(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_float"
                raise ProtoValueError(list_assign_error)
            self._cache[3] = v
            self._mods[3] = ProtoBase.TYPE_float
    
        def _mod_val_float(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[3] = ProtoBase.TYPE_float
    
        def _del_val_float(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 3 in self._cache:
                del self._cache[3]
            if 3 in self._mods:
                del self._mods[3]
            self._buf_del(3)
    
        _pb_field_name_3 = "val_float"
    
        val_float = property(_get_val_float, _set_val_float, _del_val_float)
    
        @property
        def val_float__exists(self):
            return 3 in self._mods or self._buf_exists(3)
    
        @property
        def val_float__type(self):
            return ProtoBase.TYPE_float
    
        def _finalize_val_float(cls):
            if is_string(ProtoBase.TYPE_float):
                cls._pbf_strings.append(3)
            elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
                assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
                if is_string(ProtoBase.TYPE_float.pb_subtype):
                    cls._pbf_strings.append(3)
    
        _pbf_finalizers.append(_finalize_val_float)
    
        
        def _get_val_long(self):
            if 4 in self._cache:
                r = self._cache[4]
            else:
                r = self._buf_get(4, ProtoBase.TYPE_int32, 'val_long')
                self._cache[4] = r
            return r
    
        def _establish_parentage_val_long(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_long), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_long
                    v._pbf_establish_parent_callback = self._establish_parentage_val_long
    
        def _set_val_long(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_long(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_long"
                raise ProtoValueError(list_assign_error)
            self._cache[4] = v
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _mod_val_long(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[4] = ProtoBase.TYPE_int32
    
        def _del_val_long(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 4 in self._cache:
                del self._cache[4]
            if 4 in self._mods:
                del self._mods[4]
            self._buf_del(4)
    
        _pb_field_name_4 = "val_long"
    
        val_long = property(_get_val_long, _set_val_long, _del_val_long)
    
        @property
        def val_long__exists(self):
            return 4 in self._mods or self._buf_exists(4)
    
        @property
        def val_long__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_val_long(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(4)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(4)
    
        _pbf_finalizers.append(_finalize_val_long)
    
        
        def _get_val_short(self):
            if 5 in self._cache:
                r = self._cache[5]
            else:
                r = self._buf_get(5, ProtoBase.TYPE_int32, 'val_short')
                self._cache[5] = r
            return r
    
        def _establish_parentage_val_short(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_short), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_short
                    v._pbf_establish_parent_callback = self._establish_parentage_val_short
    
        def _set_val_short(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_short(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_short"
                raise ProtoValueError(list_assign_error)
            self._cache[5] = v
            self._mods[5] = ProtoBase.TYPE_int32
    
        def _mod_val_short(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[5] = ProtoBase.TYPE_int32
    
        def _del_val_short(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 5 in self._cache:
                del self._cache[5]
            if 5 in self._mods:
                del self._mods[5]
            self._buf_del(5)
    
        _pb_field_name_5 = "val_short"
    
        val_short = property(_get_val_short, _set_val_short, _del_val_short)
    
        @property
        def val_short__exists(self):
            return 5 in self._mods or self._buf_exists(5)
    
        @property
        def val_short__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_val_short(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(5)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(5)
    
        _pbf_finalizers.append(_finalize_val_short)
    
        
        def _get_val_byte(self):
            if 6 in self._cache:
                r = self._cache[6]
            else:
                r = self._buf_get(6, ProtoBase.TYPE_int32, 'val_byte')
                self._cache[6] = r
            return r
    
        def _establish_parentage_val_byte(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_byte), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_byte
                    v._pbf_establish_parent_callback = self._establish_parentage_val_byte
    
        def _set_val_byte(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_byte(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_byte"
                raise ProtoValueError(list_assign_error)
            self._cache[6] = v
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _mod_val_byte(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[6] = ProtoBase.TYPE_int32
    
        def _del_val_byte(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 6 in self._cache:
                del self._cache[6]
            if 6 in self._mods:
                del self._mods[6]
            self._buf_del(6)
    
        _pb_field_name_6 = "val_byte"
    
        val_byte = property(_get_val_byte, _set_val_byte, _del_val_byte)
    
        @property
        def val_byte__exists(self):
            return 6 in self._mods or self._buf_exists(6)
    
        @property
        def val_byte__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_val_byte(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(6)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(6)
    
        _pbf_finalizers.append(_finalize_val_byte)
    
        
        def _get_val_bool(self):
            if 7 in self._cache:
                r = self._cache[7]
            else:
                r = self._buf_get(7, ProtoBase.TYPE_bool, 'val_bool')
                self._cache[7] = r
            return r
    
        def _establish_parentage_val_bool(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_bool), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_bool
                    v._pbf_establish_parent_callback = self._establish_parentage_val_bool
    
        def _set_val_bool(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_bool(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_bool"
                raise ProtoValueError(list_assign_error)
            self._cache[7] = v
            self._mods[7] = ProtoBase.TYPE_bool
    
        def _mod_val_bool(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[7] = ProtoBase.TYPE_bool
    
        def _del_val_bool(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 7 in self._cache:
                del self._cache[7]
            if 7 in self._mods:
                del self._mods[7]
            self._buf_del(7)
    
        _pb_field_name_7 = "val_bool"
    
        val_bool = property(_get_val_bool, _set_val_bool, _del_val_bool)
    
        @property
        def val_bool__exists(self):
            return 7 in self._mods or self._buf_exists(7)
    
        @property
        def val_bool__type(self):
            return ProtoBase.TYPE_bool
    
        def _finalize_val_bool(cls):
            if is_string(ProtoBase.TYPE_bool):
                cls._pbf_strings.append(7)
            elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
                assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
                if is_string(ProtoBase.TYPE_bool.pb_subtype):
                    cls._pbf_strings.append(7)
    
        _pbf_finalizers.append(_finalize_val_bool)
    
        
        def _get_val_uint64(self):
            if 8 in self._cache:
                r = self._cache[8]
            else:
                r = self._buf_get(8, ProtoBase.TYPE_uint64, 'val_uint64')
                self._cache[8] = r
            return r
    
        def _establish_parentage_val_uint64(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_val_uint64), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_val_uint64
                    v._pbf_establish_parent_callback = self._establish_parentage_val_uint64
    
        def _set_val_uint64(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_val_uint64(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field val_uint64"
                raise ProtoValueError(list_assign_error)
            self._cache[8] = v
            self._mods[8] = ProtoBase.TYPE_uint64
    
        def _mod_val_uint64(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[8] = ProtoBase.TYPE_uint64
    
        def _del_val_uint64(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 8 in self._cache:
                del self._cache[8]
            if 8 in self._mods:
                del self._mods[8]
            self._buf_del(8)
    
        _pb_field_name_8 = "val_uint64"
    
        val_uint64 = property(_get_val_uint64, _set_val_uint64, _del_val_uint64)
    
        @property
        def val_uint64__exists(self):
            return 8 in self._mods or self._buf_exists(8)
    
        @property
        def val_uint64__type(self):
            return ProtoBase.TYPE_uint64
    
        def _finalize_val_uint64(cls):
            if is_string(ProtoBase.TYPE_uint64):
                cls._pbf_strings.append(8)
            elif _PB_type(ProtoBase.TYPE_uint64) is _PB_type:
                assert issubclass(ProtoBase.TYPE_uint64, RepeatedSequence)
                if is_string(ProtoBase.TYPE_uint64.pb_subtype):
                    cls._pbf_strings.append(8)
    
        _pbf_finalizers.append(_finalize_val_uint64)
    
        
    TYPE_key_t = key_t
    _PB_finalizers.append('CSVCMsg_GameEvent.key_t')
    
    TYPE_key_t = key_t

    def _get_event_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'event_name')
            self._cache[1] = r
        return r

    def _establish_parentage_event_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_event_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_event_name
                v._pbf_establish_parent_callback = self._establish_parentage_event_name

    def _set_event_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_event_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field event_name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_event_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_event_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "event_name"

    event_name = property(_get_event_name, _set_event_name, _del_event_name)

    @property
    def event_name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def event_name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_event_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_event_name)


    def _get_eventid(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'eventid')
            self._cache[2] = r
        return r

    def _establish_parentage_eventid(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_eventid), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_eventid
                v._pbf_establish_parent_callback = self._establish_parentage_eventid

    def _set_eventid(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_eventid(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field eventid"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_eventid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_eventid(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "eventid"

    eventid = property(_get_eventid, _set_eventid, _del_eventid)

    @property
    def eventid__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def eventid__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_eventid(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_eventid)


    class Repeated_keys(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsg_GameEvent.TYPE_key_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_keys = Repeated_keys


    @property
    def keys__stream(self):
        if 3 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[3]]
        return self._get_repeated(3, self.TYPE_Repeated_keys, "keys", lazy=True)

    def keys__fast_append(self, value):
        self._append_to_repeated(3, self.TYPE_Repeated_keys, value)

    def _get_keys(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, self.TYPE_Repeated_keys, 'keys')
            self._cache[3] = r
        return r

    def _establish_parentage_keys(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_keys), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_keys
                v._pbf_establish_parent_callback = self._establish_parentage_keys

    def _set_keys(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_keys(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field keys"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = self.TYPE_Repeated_keys

    def _mod_keys(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = self.TYPE_Repeated_keys

    def _del_keys(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "keys"

    keys = property(_get_keys, _set_keys, _del_keys)

    @property
    def keys__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def keys__type(self):
        return self.TYPE_Repeated_keys

    def _finalize_keys(cls):
        if is_string(cls.TYPE_Repeated_keys):
            cls._pbf_strings.append(3)
        elif _PB_type(cls.TYPE_Repeated_keys) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_keys, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_keys.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_keys)


TYPE_CSVCMsg_GameEvent = CSVCMsg_GameEvent
_PB_finalizers.append('CSVCMsg_GameEvent')

class CSVCMsgList_GameEvents(ProtoBase):
    _required = []
    _field_map = {'events': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['events']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class event_t(ProtoBase):
        _required = []
        _field_map = {'tick': 1, 'event': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['tick', 'event']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_tick(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'tick')
                self._cache[1] = r
            return r
    
        def _establish_parentage_tick(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_tick), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_tick
                    v._pbf_establish_parent_callback = self._establish_parentage_tick
    
        def _set_tick(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_tick(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field tick"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_tick(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_tick(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "tick"
    
        tick = property(_get_tick, _set_tick, _del_tick)
    
        @property
        def tick__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def tick__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_tick(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_tick)
    
        
        def _get_event(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CSVCMsg_GameEvent, 'event')
                self._cache[2] = r
            return r
    
        def _establish_parentage_event(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_event), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_event
                    v._pbf_establish_parent_callback = self._establish_parentage_event
    
        def _set_event(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_event(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field event"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CSVCMsg_GameEvent
    
        def _mod_event(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CSVCMsg_GameEvent
    
        def _del_event(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "event"
    
        event = property(_get_event, _set_event, _del_event)
    
        @property
        def event__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def event__type(self):
            return TYPE_CSVCMsg_GameEvent
    
        def _finalize_event(cls):
            if is_string(TYPE_CSVCMsg_GameEvent):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CSVCMsg_GameEvent) is _PB_type:
                assert issubclass(TYPE_CSVCMsg_GameEvent, RepeatedSequence)
                if is_string(TYPE_CSVCMsg_GameEvent.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_event)
    
        
    TYPE_event_t = event_t
    _PB_finalizers.append('CSVCMsgList_GameEvents.event_t')
    
    TYPE_event_t = event_t

    class Repeated_events(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsgList_GameEvents.TYPE_event_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_events = Repeated_events


    @property
    def events__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_events, "events", lazy=True)

    def events__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_events, value)

    def _get_events(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_events, 'events')
            self._cache[1] = r
        return r

    def _establish_parentage_events(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_events), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_events
                v._pbf_establish_parent_callback = self._establish_parentage_events

    def _set_events(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_events(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field events"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_events

    def _mod_events(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_events

    def _del_events(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "events"

    events = property(_get_events, _set_events, _del_events)

    @property
    def events__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def events__type(self):
        return self.TYPE_Repeated_events

    def _finalize_events(cls):
        if is_string(cls.TYPE_Repeated_events):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_events) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_events, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_events.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_events)


TYPE_CSVCMsgList_GameEvents = CSVCMsgList_GameEvents
_PB_finalizers.append('CSVCMsgList_GameEvents')

class CSVCMsg_UserMessage(ProtoBase):
    _required = []
    _field_map = {'msg_data': 2, 'msg_type': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['msg_type', 'msg_data']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_msg_type(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'msg_type')
            self._cache[1] = r
        return r

    def _establish_parentage_msg_type(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_msg_type), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_msg_type
                v._pbf_establish_parent_callback = self._establish_parentage_msg_type

    def _set_msg_type(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_msg_type(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field msg_type"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_msg_type(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "msg_type"

    msg_type = property(_get_msg_type, _set_msg_type, _del_msg_type)

    @property
    def msg_type__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def msg_type__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_msg_type(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_msg_type)


    def _get_msg_data(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bytes, 'msg_data')
            self._cache[2] = r
        return r

    def _establish_parentage_msg_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_msg_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_msg_data
                v._pbf_establish_parent_callback = self._establish_parentage_msg_data

    def _set_msg_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_msg_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field msg_data"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bytes

    def _mod_msg_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bytes

    def _del_msg_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "msg_data"

    msg_data = property(_get_msg_data, _set_msg_data, _del_msg_data)

    @property
    def msg_data__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def msg_data__type(self):
        return ProtoBase.TYPE_bytes

    def _finalize_msg_data(cls):
        if is_string(ProtoBase.TYPE_bytes):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bytes) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bytes, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bytes.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_msg_data)


TYPE_CSVCMsg_UserMessage = CSVCMsg_UserMessage
_PB_finalizers.append('CSVCMsg_UserMessage')

class CSVCMsgList_UserMessages(ProtoBase):
    _required = []
    _field_map = {'usermsgs': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['usermsgs']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class usermsg_t(ProtoBase):
        _required = []
        _field_map = {'msg': 2, 'tick': 1}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['tick', 'msg']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_tick(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_int32, 'tick')
                self._cache[1] = r
            return r
    
        def _establish_parentage_tick(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_tick), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_tick
                    v._pbf_establish_parent_callback = self._establish_parentage_tick
    
        def _set_tick(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_tick(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field tick"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _mod_tick(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_int32
    
        def _del_tick(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "tick"
    
        tick = property(_get_tick, _set_tick, _del_tick)
    
        @property
        def tick__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def tick__type(self):
            return ProtoBase.TYPE_int32
    
        def _finalize_tick(cls):
            if is_string(ProtoBase.TYPE_int32):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
                assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
                if is_string(ProtoBase.TYPE_int32.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_tick)
    
        
        def _get_msg(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, TYPE_CSVCMsg_UserMessage, 'msg')
                self._cache[2] = r
            return r
    
        def _establish_parentage_msg(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_msg), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_msg
                    v._pbf_establish_parent_callback = self._establish_parentage_msg
    
        def _set_msg(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_msg(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field msg"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = TYPE_CSVCMsg_UserMessage
    
        def _mod_msg(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = TYPE_CSVCMsg_UserMessage
    
        def _del_msg(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "msg"
    
        msg = property(_get_msg, _set_msg, _del_msg)
    
        @property
        def msg__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def msg__type(self):
            return TYPE_CSVCMsg_UserMessage
    
        def _finalize_msg(cls):
            if is_string(TYPE_CSVCMsg_UserMessage):
                cls._pbf_strings.append(2)
            elif _PB_type(TYPE_CSVCMsg_UserMessage) is _PB_type:
                assert issubclass(TYPE_CSVCMsg_UserMessage, RepeatedSequence)
                if is_string(TYPE_CSVCMsg_UserMessage.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_msg)
    
        
    TYPE_usermsg_t = usermsg_t
    _PB_finalizers.append('CSVCMsgList_UserMessages.usermsg_t')
    
    TYPE_usermsg_t = usermsg_t

    class Repeated_usermsgs(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CSVCMsgList_UserMessages.TYPE_usermsg_t
        pb_subtype = pb_subtype()


    TYPE_Repeated_usermsgs = Repeated_usermsgs


    @property
    def usermsgs__stream(self):
        if 1 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[1]]
        return self._get_repeated(1, self.TYPE_Repeated_usermsgs, "usermsgs", lazy=True)

    def usermsgs__fast_append(self, value):
        self._append_to_repeated(1, self.TYPE_Repeated_usermsgs, value)

    def _get_usermsgs(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_usermsgs, 'usermsgs')
            self._cache[1] = r
        return r

    def _establish_parentage_usermsgs(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_usermsgs), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_usermsgs
                v._pbf_establish_parent_callback = self._establish_parentage_usermsgs

    def _set_usermsgs(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_usermsgs(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field usermsgs"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_usermsgs

    def _mod_usermsgs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_usermsgs

    def _del_usermsgs(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "usermsgs"

    usermsgs = property(_get_usermsgs, _set_usermsgs, _del_usermsgs)

    @property
    def usermsgs__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def usermsgs__type(self):
        return self.TYPE_Repeated_usermsgs

    def _finalize_usermsgs(cls):
        if is_string(cls.TYPE_Repeated_usermsgs):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_usermsgs) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_usermsgs, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_usermsgs.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_usermsgs)


TYPE_CSVCMsgList_UserMessages = CSVCMsgList_UserMessages
_PB_finalizers.append('CSVCMsgList_UserMessages')

class CUserMsg_AchievementEvent(ProtoBase):
    _required = []
    _field_map = {'achievement': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['achievement']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_achievement(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'achievement')
            self._cache[1] = r
        return r

    def _establish_parentage_achievement(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_achievement), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_achievement
                v._pbf_establish_parent_callback = self._establish_parentage_achievement

    def _set_achievement(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_achievement(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field achievement"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_achievement(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_achievement(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "achievement"

    achievement = property(_get_achievement, _set_achievement, _del_achievement)

    @property
    def achievement__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def achievement__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_achievement(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_achievement)


TYPE_CUserMsg_AchievementEvent = CUserMsg_AchievementEvent
_PB_finalizers.append('CUserMsg_AchievementEvent')

class CUserMsg_CloseCaption(ProtoBase):
    _required = []
    _field_map = {'duration': 2, 'from_player': 3, 'hash': 1, 'ent_index': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['hash', 'duration', 'from_player', 'ent_index']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_hash(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_fixed32, 'hash')
            self._cache[1] = r
        return r

    def _establish_parentage_hash(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hash), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hash
                v._pbf_establish_parent_callback = self._establish_parentage_hash

    def _set_hash(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hash(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hash"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_fixed32

    def _mod_hash(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_fixed32

    def _del_hash(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "hash"

    hash = property(_get_hash, _set_hash, _del_hash)

    @property
    def hash__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def hash__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_hash(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_hash)


    def _get_duration(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'duration')
            self._cache[2] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_duration)


    def _get_from_player(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'from_player')
            self._cache[3] = r
        return r

    def _establish_parentage_from_player(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_from_player), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_from_player
                v._pbf_establish_parent_callback = self._establish_parentage_from_player

    def _set_from_player(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_from_player(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field from_player"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_from_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_from_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "from_player"

    from_player = property(_get_from_player, _set_from_player, _del_from_player)

    @property
    def from_player__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def from_player__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_from_player(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_from_player)


    def _get_ent_index(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_int32, 'ent_index')
            self._cache[4] = r
        return r

    def _establish_parentage_ent_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ent_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ent_index
                v._pbf_establish_parent_callback = self._establish_parentage_ent_index

    def _set_ent_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ent_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ent_index"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_int32

    def _mod_ent_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_int32

    def _del_ent_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "ent_index"

    ent_index = property(_get_ent_index, _set_ent_index, _del_ent_index)

    @property
    def ent_index__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def ent_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_ent_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_ent_index)


TYPE_CUserMsg_CloseCaption = CUserMsg_CloseCaption
_PB_finalizers.append('CUserMsg_CloseCaption')

class CUserMsg_CurrentTimescale(ProtoBase):
    _required = []
    _field_map = {'current': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['current']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_current(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'current')
            self._cache[1] = r
        return r

    def _establish_parentage_current(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_current), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_current
                v._pbf_establish_parent_callback = self._establish_parentage_current

    def _set_current(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_current(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field current"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_current(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_current(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "current"

    current = property(_get_current, _set_current, _del_current)

    @property
    def current__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def current__type(self):
        return ProtoBase.TYPE_float

    def _finalize_current(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_current)


TYPE_CUserMsg_CurrentTimescale = CUserMsg_CurrentTimescale
_PB_finalizers.append('CUserMsg_CurrentTimescale')

class CUserMsg_DesiredTimescale(ProtoBase):
    _required = []
    _field_map = {'duration': 2, 'desired': 1, 'start_blend_time': 4, 'interpolator': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['desired', 'duration', 'interpolator', 'start_blend_time']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_desired(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_float, 'desired')
            self._cache[1] = r
        return r

    def _establish_parentage_desired(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_desired), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_desired
                v._pbf_establish_parent_callback = self._establish_parentage_desired

    def _set_desired(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_desired(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field desired"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_float

    def _mod_desired(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_float

    def _del_desired(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "desired"

    desired = property(_get_desired, _set_desired, _del_desired)

    @property
    def desired__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def desired__type(self):
        return ProtoBase.TYPE_float

    def _finalize_desired(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_desired)


    def _get_duration(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'duration')
            self._cache[2] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_duration)


    def _get_interpolator(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'interpolator')
            self._cache[3] = r
        return r

    def _establish_parentage_interpolator(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_interpolator), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_interpolator
                v._pbf_establish_parent_callback = self._establish_parentage_interpolator

    def _set_interpolator(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_interpolator(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field interpolator"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_interpolator(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_interpolator(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "interpolator"

    interpolator = property(_get_interpolator, _set_interpolator, _del_interpolator)

    @property
    def interpolator__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def interpolator__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_interpolator(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_interpolator)


    def _get_start_blend_time(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_float, 'start_blend_time')
            self._cache[4] = r
        return r

    def _establish_parentage_start_blend_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_start_blend_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_start_blend_time
                v._pbf_establish_parent_callback = self._establish_parentage_start_blend_time

    def _set_start_blend_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_start_blend_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field start_blend_time"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_float

    def _mod_start_blend_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_float

    def _del_start_blend_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "start_blend_time"

    start_blend_time = property(_get_start_blend_time, _set_start_blend_time, _del_start_blend_time)

    @property
    def start_blend_time__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def start_blend_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_start_blend_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_start_blend_time)


TYPE_CUserMsg_DesiredTimescale = CUserMsg_DesiredTimescale
_PB_finalizers.append('CUserMsg_DesiredTimescale')

class CUserMsg_Fade(ProtoBase):
    _required = []
    _field_map = {'duration': 1, 'flags': 3, 'hold_time': 2, 'color': 4}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['duration', 'hold_time', 'flags', 'color']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_duration(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'duration')
            self._cache[1] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_duration)


    def _get_hold_time(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_uint32, 'hold_time')
            self._cache[2] = r
        return r

    def _establish_parentage_hold_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hold_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hold_time
                v._pbf_establish_parent_callback = self._establish_parentage_hold_time

    def _set_hold_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hold_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hold_time"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_uint32

    def _mod_hold_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_uint32

    def _del_hold_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "hold_time"

    hold_time = property(_get_hold_time, _set_hold_time, _del_hold_time)

    @property
    def hold_time__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def hold_time__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_hold_time(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_hold_time)


    def _get_flags(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_uint32, 'flags')
            self._cache[3] = r
        return r

    def _establish_parentage_flags(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_flags), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_flags
                v._pbf_establish_parent_callback = self._establish_parentage_flags

    def _set_flags(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_flags(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field flags"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_uint32

    def _mod_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_uint32

    def _del_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "flags"

    flags = property(_get_flags, _set_flags, _del_flags)

    @property
    def flags__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def flags__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_flags(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_flags)


    def _get_color(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_fixed32, 'color')
            self._cache[4] = r
        return r

    def _establish_parentage_color(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color
                v._pbf_establish_parent_callback = self._establish_parentage_color

    def _set_color(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_fixed32

    def _mod_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_fixed32

    def _del_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "color"

    color = property(_get_color, _set_color, _del_color)

    @property
    def color__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def color__type(self):
        return ProtoBase.TYPE_fixed32

    def _finalize_color(cls):
        if is_string(ProtoBase.TYPE_fixed32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_fixed32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_fixed32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_fixed32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_color)


TYPE_CUserMsg_Fade = CUserMsg_Fade
_PB_finalizers.append('CUserMsg_Fade')

class CUserMsg_Shake(ProtoBase):
    _required = []
    _field_map = {'duration': 4, 'frequency': 3, 'command': 1, 'amplitude': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['command', 'amplitude', 'frequency', 'duration']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_command(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'command')
            self._cache[1] = r
        return r

    def _establish_parentage_command(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_command), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_command
                v._pbf_establish_parent_callback = self._establish_parentage_command

    def _set_command(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_command(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field command"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "command"

    command = property(_get_command, _set_command, _del_command)

    @property
    def command__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def command__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_command(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_command)


    def _get_amplitude(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'amplitude')
            self._cache[2] = r
        return r

    def _establish_parentage_amplitude(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_amplitude), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_amplitude
                v._pbf_establish_parent_callback = self._establish_parentage_amplitude

    def _set_amplitude(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_amplitude(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field amplitude"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_amplitude(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_amplitude(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "amplitude"

    amplitude = property(_get_amplitude, _set_amplitude, _del_amplitude)

    @property
    def amplitude__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def amplitude__type(self):
        return ProtoBase.TYPE_float

    def _finalize_amplitude(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_amplitude)


    def _get_frequency(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'frequency')
            self._cache[3] = r
        return r

    def _establish_parentage_frequency(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_frequency), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_frequency
                v._pbf_establish_parent_callback = self._establish_parentage_frequency

    def _set_frequency(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_frequency(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field frequency"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_frequency(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_frequency(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "frequency"

    frequency = property(_get_frequency, _set_frequency, _del_frequency)

    @property
    def frequency__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def frequency__type(self):
        return ProtoBase.TYPE_float

    def _finalize_frequency(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_frequency)


    def _get_duration(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_float, 'duration')
            self._cache[4] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_duration)


TYPE_CUserMsg_Shake = CUserMsg_Shake
_PB_finalizers.append('CUserMsg_Shake')

class CUserMsg_ShakeDir(ProtoBase):
    _required = []
    _field_map = {'direction': 2, 'shake': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['shake', 'direction']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_shake(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, TYPE_CUserMsg_Shake, 'shake')
            self._cache[1] = r
        return r

    def _establish_parentage_shake(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_shake), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_shake
                v._pbf_establish_parent_callback = self._establish_parentage_shake

    def _set_shake(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_shake(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field shake"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = TYPE_CUserMsg_Shake

    def _mod_shake(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = TYPE_CUserMsg_Shake

    def _del_shake(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "shake"

    shake = property(_get_shake, _set_shake, _del_shake)

    @property
    def shake__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def shake__type(self):
        return TYPE_CUserMsg_Shake

    def _finalize_shake(cls):
        if is_string(TYPE_CUserMsg_Shake):
            cls._pbf_strings.append(1)
        elif _PB_type(TYPE_CUserMsg_Shake) is _PB_type:
            assert issubclass(TYPE_CUserMsg_Shake, RepeatedSequence)
            if is_string(TYPE_CUserMsg_Shake.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_shake)


    def _get_direction(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, TYPE_CMsgVector, 'direction')
            self._cache[2] = r
        return r

    def _establish_parentage_direction(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_direction), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_direction
                v._pbf_establish_parent_callback = self._establish_parentage_direction

    def _set_direction(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_direction(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field direction"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = TYPE_CMsgVector

    def _mod_direction(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = TYPE_CMsgVector

    def _del_direction(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "direction"

    direction = property(_get_direction, _set_direction, _del_direction)

    @property
    def direction__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def direction__type(self):
        return TYPE_CMsgVector

    def _finalize_direction(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(2)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_direction)


TYPE_CUserMsg_ShakeDir = CUserMsg_ShakeDir
_PB_finalizers.append('CUserMsg_ShakeDir')

class CUserMsg_Tilt(ProtoBase):
    _required = []
    _field_map = {'duration': 4, 'angle': 3, 'ease_in_out': 2, 'command': 1, 'time': 5}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['command', 'ease_in_out', 'angle', 'duration', 'time']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_command(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'command')
            self._cache[1] = r
        return r

    def _establish_parentage_command(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_command), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_command
                v._pbf_establish_parent_callback = self._establish_parentage_command

    def _set_command(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_command(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field command"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_command(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "command"

    command = property(_get_command, _set_command, _del_command)

    @property
    def command__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def command__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_command(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_command)


    def _get_ease_in_out(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'ease_in_out')
            self._cache[2] = r
        return r

    def _establish_parentage_ease_in_out(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ease_in_out), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ease_in_out
                v._pbf_establish_parent_callback = self._establish_parentage_ease_in_out

    def _set_ease_in_out(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ease_in_out(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ease_in_out"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_ease_in_out(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_ease_in_out(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "ease_in_out"

    ease_in_out = property(_get_ease_in_out, _set_ease_in_out, _del_ease_in_out)

    @property
    def ease_in_out__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def ease_in_out__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_ease_in_out(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_ease_in_out)


    def _get_angle(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, TYPE_CMsgVector, 'angle')
            self._cache[3] = r
        return r

    def _establish_parentage_angle(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_angle), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_angle
                v._pbf_establish_parent_callback = self._establish_parentage_angle

    def _set_angle(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_angle(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field angle"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = TYPE_CMsgVector

    def _mod_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = TYPE_CMsgVector

    def _del_angle(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "angle"

    angle = property(_get_angle, _set_angle, _del_angle)

    @property
    def angle__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def angle__type(self):
        return TYPE_CMsgVector

    def _finalize_angle(cls):
        if is_string(TYPE_CMsgVector):
            cls._pbf_strings.append(3)
        elif _PB_type(TYPE_CMsgVector) is _PB_type:
            assert issubclass(TYPE_CMsgVector, RepeatedSequence)
            if is_string(TYPE_CMsgVector.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_angle)


    def _get_duration(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_float, 'duration')
            self._cache[4] = r
        return r

    def _establish_parentage_duration(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_duration), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_duration
                v._pbf_establish_parent_callback = self._establish_parentage_duration

    def _set_duration(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_duration(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field duration"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_float

    def _mod_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_float

    def _del_duration(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "duration"

    duration = property(_get_duration, _set_duration, _del_duration)

    @property
    def duration__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def duration__type(self):
        return ProtoBase.TYPE_float

    def _finalize_duration(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_duration)


    def _get_time(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_float, 'time')
            self._cache[5] = r
        return r

    def _establish_parentage_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_time
                v._pbf_establish_parent_callback = self._establish_parentage_time

    def _set_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field time"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_float

    def _mod_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_float

    def _del_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "time"

    time = property(_get_time, _set_time, _del_time)

    @property
    def time__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_time)


TYPE_CUserMsg_Tilt = CUserMsg_Tilt
_PB_finalizers.append('CUserMsg_Tilt')

class CUserMsg_SayText(ProtoBase):
    _required = []
    _field_map = {'text': 2, 'client': 1, 'chat': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['client', 'text', 'chat']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_client(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'client')
            self._cache[1] = r
        return r

    def _establish_parentage_client(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_client), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_client
                v._pbf_establish_parent_callback = self._establish_parentage_client

    def _set_client(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_client(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field client"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "client"

    client = property(_get_client, _set_client, _del_client)

    @property
    def client__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def client__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_client(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_client)


    def _get_text(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'text')
            self._cache[2] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_text)


    def _get_chat(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_bool, 'chat')
            self._cache[3] = r
        return r

    def _establish_parentage_chat(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_chat), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_chat
                v._pbf_establish_parent_callback = self._establish_parentage_chat

    def _set_chat(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_chat(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field chat"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_bool

    def _mod_chat(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_bool

    def _del_chat(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "chat"

    chat = property(_get_chat, _set_chat, _del_chat)

    @property
    def chat__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def chat__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_chat(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_chat)


TYPE_CUserMsg_SayText = CUserMsg_SayText
_PB_finalizers.append('CUserMsg_SayText')

class CUserMsg_SayText2(ProtoBase):
    _required = []
    _field_map = {'format': 3, 'text': 5, 'prefix': 4, 'client': 1, 'location': 6, 'chat': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['client', 'chat', 'format', 'prefix', 'text', 'location']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_client(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'client')
            self._cache[1] = r
        return r

    def _establish_parentage_client(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_client), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_client
                v._pbf_establish_parent_callback = self._establish_parentage_client

    def _set_client(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_client(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field client"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_client(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "client"

    client = property(_get_client, _set_client, _del_client)

    @property
    def client__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def client__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_client(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_client)


    def _get_chat(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'chat')
            self._cache[2] = r
        return r

    def _establish_parentage_chat(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_chat), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_chat
                v._pbf_establish_parent_callback = self._establish_parentage_chat

    def _set_chat(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_chat(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field chat"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_chat(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_chat(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "chat"

    chat = property(_get_chat, _set_chat, _del_chat)

    @property
    def chat__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def chat__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_chat(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_chat)


    def _get_format(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'format')
            self._cache[3] = r
        return r

    def _establish_parentage_format(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_format), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_format
                v._pbf_establish_parent_callback = self._establish_parentage_format

    def _set_format(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_format(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field format"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_format(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "format"

    format = property(_get_format, _set_format, _del_format)

    @property
    def format__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def format__type(self):
        return ProtoBase.TYPE_string

    def _finalize_format(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_format)


    def _get_prefix(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_string, 'prefix')
            self._cache[4] = r
        return r

    def _establish_parentage_prefix(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_prefix), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_prefix
                v._pbf_establish_parent_callback = self._establish_parentage_prefix

    def _set_prefix(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_prefix(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field prefix"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_string

    def _mod_prefix(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_string

    def _del_prefix(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "prefix"

    prefix = property(_get_prefix, _set_prefix, _del_prefix)

    @property
    def prefix__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def prefix__type(self):
        return ProtoBase.TYPE_string

    def _finalize_prefix(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_prefix)


    def _get_text(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_string, 'text')
            self._cache[5] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_text)


    def _get_location(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_string, 'location')
            self._cache[6] = r
        return r

    def _establish_parentage_location(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_location), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_location
                v._pbf_establish_parent_callback = self._establish_parentage_location

    def _set_location(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_location(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field location"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_string

    def _mod_location(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_string

    def _del_location(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "location"

    location = property(_get_location, _set_location, _del_location)

    @property
    def location__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def location__type(self):
        return ProtoBase.TYPE_string

    def _finalize_location(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_location)


TYPE_CUserMsg_SayText2 = CUserMsg_SayText2
_PB_finalizers.append('CUserMsg_SayText2')

class CUserMsg_HudMsg(ProtoBase):
    _required = []
    _field_map = {'fade_in_time': 7, 'fade_out_time': 8, 'effect': 6, 'color1': 4, 'color2': 5, 'fx_time': 10, 'y': 3, 'x': 2, 'message': 11, 'hold_time': 9, 'channel': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['channel', 'x', 'y', 'color1', 'color2', 'effect', 'fade_in_time', 'fade_out_time', 'hold_time', 'fx_time', 'message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_channel(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'channel')
            self._cache[1] = r
        return r

    def _establish_parentage_channel(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_channel), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_channel
                v._pbf_establish_parent_callback = self._establish_parentage_channel

    def _set_channel(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_channel(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field channel"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_channel(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_channel(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "channel"

    channel = property(_get_channel, _set_channel, _del_channel)

    @property
    def channel__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def channel__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_channel(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_channel)


    def _get_x(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_float, 'x')
            self._cache[2] = r
        return r

    def _establish_parentage_x(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_x), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_x
                v._pbf_establish_parent_callback = self._establish_parentage_x

    def _set_x(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_x(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field x"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_float

    def _mod_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_float

    def _del_x(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "x"

    x = property(_get_x, _set_x, _del_x)

    @property
    def x__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def x__type(self):
        return ProtoBase.TYPE_float

    def _finalize_x(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_x)


    def _get_y(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_float, 'y')
            self._cache[3] = r
        return r

    def _establish_parentage_y(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_y), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_y
                v._pbf_establish_parent_callback = self._establish_parentage_y

    def _set_y(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_y(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field y"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_float

    def _mod_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_float

    def _del_y(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "y"

    y = property(_get_y, _set_y, _del_y)

    @property
    def y__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def y__type(self):
        return ProtoBase.TYPE_float

    def _finalize_y(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_y)


    def _get_color1(self):
        if 4 in self._cache:
            r = self._cache[4]
        else:
            r = self._buf_get(4, ProtoBase.TYPE_uint32, 'color1')
            self._cache[4] = r
        return r

    def _establish_parentage_color1(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color1), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color1
                v._pbf_establish_parent_callback = self._establish_parentage_color1

    def _set_color1(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color1(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color1"
            raise ProtoValueError(list_assign_error)
        self._cache[4] = v
        self._mods[4] = ProtoBase.TYPE_uint32

    def _mod_color1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[4] = ProtoBase.TYPE_uint32

    def _del_color1(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 4 in self._cache:
            del self._cache[4]
        if 4 in self._mods:
            del self._mods[4]
        self._buf_del(4)

    _pb_field_name_4 = "color1"

    color1 = property(_get_color1, _set_color1, _del_color1)

    @property
    def color1__exists(self):
        return 4 in self._mods or self._buf_exists(4)

    @property
    def color1__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_color1(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(4)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(4)

    _pbf_finalizers.append(_finalize_color1)


    def _get_color2(self):
        if 5 in self._cache:
            r = self._cache[5]
        else:
            r = self._buf_get(5, ProtoBase.TYPE_uint32, 'color2')
            self._cache[5] = r
        return r

    def _establish_parentage_color2(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color2), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color2
                v._pbf_establish_parent_callback = self._establish_parentage_color2

    def _set_color2(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color2(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color2"
            raise ProtoValueError(list_assign_error)
        self._cache[5] = v
        self._mods[5] = ProtoBase.TYPE_uint32

    def _mod_color2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[5] = ProtoBase.TYPE_uint32

    def _del_color2(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 5 in self._cache:
            del self._cache[5]
        if 5 in self._mods:
            del self._mods[5]
        self._buf_del(5)

    _pb_field_name_5 = "color2"

    color2 = property(_get_color2, _set_color2, _del_color2)

    @property
    def color2__exists(self):
        return 5 in self._mods or self._buf_exists(5)

    @property
    def color2__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_color2(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(5)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(5)

    _pbf_finalizers.append(_finalize_color2)


    def _get_effect(self):
        if 6 in self._cache:
            r = self._cache[6]
        else:
            r = self._buf_get(6, ProtoBase.TYPE_uint32, 'effect')
            self._cache[6] = r
        return r

    def _establish_parentage_effect(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_effect), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_effect
                v._pbf_establish_parent_callback = self._establish_parentage_effect

    def _set_effect(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_effect(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field effect"
            raise ProtoValueError(list_assign_error)
        self._cache[6] = v
        self._mods[6] = ProtoBase.TYPE_uint32

    def _mod_effect(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[6] = ProtoBase.TYPE_uint32

    def _del_effect(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 6 in self._cache:
            del self._cache[6]
        if 6 in self._mods:
            del self._mods[6]
        self._buf_del(6)

    _pb_field_name_6 = "effect"

    effect = property(_get_effect, _set_effect, _del_effect)

    @property
    def effect__exists(self):
        return 6 in self._mods or self._buf_exists(6)

    @property
    def effect__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_effect(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(6)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(6)

    _pbf_finalizers.append(_finalize_effect)


    def _get_fade_in_time(self):
        if 7 in self._cache:
            r = self._cache[7]
        else:
            r = self._buf_get(7, ProtoBase.TYPE_float, 'fade_in_time')
            self._cache[7] = r
        return r

    def _establish_parentage_fade_in_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fade_in_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fade_in_time
                v._pbf_establish_parent_callback = self._establish_parentage_fade_in_time

    def _set_fade_in_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fade_in_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fade_in_time"
            raise ProtoValueError(list_assign_error)
        self._cache[7] = v
        self._mods[7] = ProtoBase.TYPE_float

    def _mod_fade_in_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[7] = ProtoBase.TYPE_float

    def _del_fade_in_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 7 in self._cache:
            del self._cache[7]
        if 7 in self._mods:
            del self._mods[7]
        self._buf_del(7)

    _pb_field_name_7 = "fade_in_time"

    fade_in_time = property(_get_fade_in_time, _set_fade_in_time, _del_fade_in_time)

    @property
    def fade_in_time__exists(self):
        return 7 in self._mods or self._buf_exists(7)

    @property
    def fade_in_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_fade_in_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(7)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(7)

    _pbf_finalizers.append(_finalize_fade_in_time)


    def _get_fade_out_time(self):
        if 8 in self._cache:
            r = self._cache[8]
        else:
            r = self._buf_get(8, ProtoBase.TYPE_float, 'fade_out_time')
            self._cache[8] = r
        return r

    def _establish_parentage_fade_out_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fade_out_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fade_out_time
                v._pbf_establish_parent_callback = self._establish_parentage_fade_out_time

    def _set_fade_out_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fade_out_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fade_out_time"
            raise ProtoValueError(list_assign_error)
        self._cache[8] = v
        self._mods[8] = ProtoBase.TYPE_float

    def _mod_fade_out_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[8] = ProtoBase.TYPE_float

    def _del_fade_out_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 8 in self._cache:
            del self._cache[8]
        if 8 in self._mods:
            del self._mods[8]
        self._buf_del(8)

    _pb_field_name_8 = "fade_out_time"

    fade_out_time = property(_get_fade_out_time, _set_fade_out_time, _del_fade_out_time)

    @property
    def fade_out_time__exists(self):
        return 8 in self._mods or self._buf_exists(8)

    @property
    def fade_out_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_fade_out_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(8)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(8)

    _pbf_finalizers.append(_finalize_fade_out_time)


    def _get_hold_time(self):
        if 9 in self._cache:
            r = self._cache[9]
        else:
            r = self._buf_get(9, ProtoBase.TYPE_float, 'hold_time')
            self._cache[9] = r
        return r

    def _establish_parentage_hold_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_hold_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_hold_time
                v._pbf_establish_parent_callback = self._establish_parentage_hold_time

    def _set_hold_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_hold_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field hold_time"
            raise ProtoValueError(list_assign_error)
        self._cache[9] = v
        self._mods[9] = ProtoBase.TYPE_float

    def _mod_hold_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[9] = ProtoBase.TYPE_float

    def _del_hold_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 9 in self._cache:
            del self._cache[9]
        if 9 in self._mods:
            del self._mods[9]
        self._buf_del(9)

    _pb_field_name_9 = "hold_time"

    hold_time = property(_get_hold_time, _set_hold_time, _del_hold_time)

    @property
    def hold_time__exists(self):
        return 9 in self._mods or self._buf_exists(9)

    @property
    def hold_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_hold_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(9)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(9)

    _pbf_finalizers.append(_finalize_hold_time)


    def _get_fx_time(self):
        if 10 in self._cache:
            r = self._cache[10]
        else:
            r = self._buf_get(10, ProtoBase.TYPE_float, 'fx_time')
            self._cache[10] = r
        return r

    def _establish_parentage_fx_time(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_fx_time), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_fx_time
                v._pbf_establish_parent_callback = self._establish_parentage_fx_time

    def _set_fx_time(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_fx_time(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field fx_time"
            raise ProtoValueError(list_assign_error)
        self._cache[10] = v
        self._mods[10] = ProtoBase.TYPE_float

    def _mod_fx_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[10] = ProtoBase.TYPE_float

    def _del_fx_time(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 10 in self._cache:
            del self._cache[10]
        if 10 in self._mods:
            del self._mods[10]
        self._buf_del(10)

    _pb_field_name_10 = "fx_time"

    fx_time = property(_get_fx_time, _set_fx_time, _del_fx_time)

    @property
    def fx_time__exists(self):
        return 10 in self._mods or self._buf_exists(10)

    @property
    def fx_time__type(self):
        return ProtoBase.TYPE_float

    def _finalize_fx_time(cls):
        if is_string(ProtoBase.TYPE_float):
            cls._pbf_strings.append(10)
        elif _PB_type(ProtoBase.TYPE_float) is _PB_type:
            assert issubclass(ProtoBase.TYPE_float, RepeatedSequence)
            if is_string(ProtoBase.TYPE_float.pb_subtype):
                cls._pbf_strings.append(10)

    _pbf_finalizers.append(_finalize_fx_time)


    def _get_message(self):
        if 11 in self._cache:
            r = self._cache[11]
        else:
            r = self._buf_get(11, ProtoBase.TYPE_string, 'message')
            self._cache[11] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[11] = v
        self._mods[11] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[11] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 11 in self._cache:
            del self._cache[11]
        if 11 in self._mods:
            del self._mods[11]
        self._buf_del(11)

    _pb_field_name_11 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 11 in self._mods or self._buf_exists(11)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(11)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(11)

    _pbf_finalizers.append(_finalize_message)


TYPE_CUserMsg_HudMsg = CUserMsg_HudMsg
_PB_finalizers.append('CUserMsg_HudMsg')

class CUserMsg_HudText(ProtoBase):
    _required = []
    _field_map = {'message': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


TYPE_CUserMsg_HudText = CUserMsg_HudText
_PB_finalizers.append('CUserMsg_HudText')

class CUserMsg_TextMsg(ProtoBase):
    _required = []
    _field_map = {'dest': 1, 'param': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['dest', 'param']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_dest(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'dest')
            self._cache[1] = r
        return r

    def _establish_parentage_dest(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_dest), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_dest
                v._pbf_establish_parent_callback = self._establish_parentage_dest

    def _set_dest(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_dest(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field dest"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_dest(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_dest(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "dest"

    dest = property(_get_dest, _set_dest, _del_dest)

    @property
    def dest__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def dest__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_dest(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_dest)


    class Repeated_param(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_param = Repeated_param


    def _get_param(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, self.TYPE_Repeated_param, 'param')
            self._cache[2] = r
        return r

    def _establish_parentage_param(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_param), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_param
                v._pbf_establish_parent_callback = self._establish_parentage_param

    def _set_param(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_param(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field param"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = self.TYPE_Repeated_param

    def _mod_param(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = self.TYPE_Repeated_param

    def _del_param(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "param"

    param = property(_get_param, _set_param, _del_param)

    @property
    def param__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def param__type(self):
        return self.TYPE_Repeated_param

    def _finalize_param(cls):
        if is_string(cls.TYPE_Repeated_param):
            cls._pbf_strings.append(2)
        elif _PB_type(cls.TYPE_Repeated_param) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_param, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_param.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_param)


TYPE_CUserMsg_TextMsg = CUserMsg_TextMsg
_PB_finalizers.append('CUserMsg_TextMsg')

class CUserMsg_GameTitle(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CUserMsg_GameTitle = CUserMsg_GameTitle
_PB_finalizers.append('CUserMsg_GameTitle')

class CUserMsg_ResetHUD(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CUserMsg_ResetHUD = CUserMsg_ResetHUD
_PB_finalizers.append('CUserMsg_ResetHUD')

class CUserMsg_SendAudio(ProtoBase):
    _required = []
    _field_map = {'stop': 2, 'name': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['stop', 'name']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_stop(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'stop')
            self._cache[2] = r
        return r

    def _establish_parentage_stop(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_stop), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_stop
                v._pbf_establish_parent_callback = self._establish_parentage_stop

    def _set_stop(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_stop(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field stop"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_stop(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_stop(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "stop"

    stop = property(_get_stop, _set_stop, _del_stop)

    @property
    def stop__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def stop__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_stop(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_stop)


    def _get_name(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'name')
            self._cache[3] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_name)


TYPE_CUserMsg_SendAudio = CUserMsg_SendAudio
_PB_finalizers.append('CUserMsg_SendAudio')

class CUserMsg_VoiceMask(ProtoBase):
    _required = []
    _field_map = {'audible_players_mask': 1, 'player_mod_enabled': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['audible_players_mask', 'player_mod_enabled']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_audible_players_mask(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_int32
        pb_subtype = pb_subtype()


    TYPE_Repeated_audible_players_mask = Repeated_audible_players_mask


    def _get_audible_players_mask(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_audible_players_mask, 'audible_players_mask')
            self._cache[1] = r
        return r

    def _establish_parentage_audible_players_mask(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_audible_players_mask), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_audible_players_mask
                v._pbf_establish_parent_callback = self._establish_parentage_audible_players_mask

    def _set_audible_players_mask(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_audible_players_mask(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field audible_players_mask"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_audible_players_mask

    def _mod_audible_players_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_audible_players_mask

    def _del_audible_players_mask(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "audible_players_mask"

    audible_players_mask = property(_get_audible_players_mask, _set_audible_players_mask, _del_audible_players_mask)

    @property
    def audible_players_mask__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def audible_players_mask__type(self):
        return self.TYPE_Repeated_audible_players_mask

    def _finalize_audible_players_mask(cls):
        if is_string(cls.TYPE_Repeated_audible_players_mask):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_audible_players_mask) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_audible_players_mask, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_audible_players_mask.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_audible_players_mask)


    def _get_player_mod_enabled(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'player_mod_enabled')
            self._cache[2] = r
        return r

    def _establish_parentage_player_mod_enabled(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player_mod_enabled), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player_mod_enabled
                v._pbf_establish_parent_callback = self._establish_parentage_player_mod_enabled

    def _set_player_mod_enabled(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player_mod_enabled(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player_mod_enabled"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_player_mod_enabled(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_player_mod_enabled(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "player_mod_enabled"

    player_mod_enabled = property(_get_player_mod_enabled, _set_player_mod_enabled, _del_player_mod_enabled)

    @property
    def player_mod_enabled__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def player_mod_enabled__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_player_mod_enabled(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_player_mod_enabled)


TYPE_CUserMsg_VoiceMask = CUserMsg_VoiceMask
_PB_finalizers.append('CUserMsg_VoiceMask')

class CUserMsg_RequestState(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CUserMsg_RequestState = CUserMsg_RequestState
_PB_finalizers.append('CUserMsg_RequestState')

class CUserMsg_HintText(ProtoBase):
    _required = []
    _field_map = {'message': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['message']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_message(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'message')
            self._cache[1] = r
        return r

    def _establish_parentage_message(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_message), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_message
                v._pbf_establish_parent_callback = self._establish_parentage_message

    def _set_message(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_message(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field message"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_message(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "message"

    message = property(_get_message, _set_message, _del_message)

    @property
    def message__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def message__type(self):
        return ProtoBase.TYPE_string

    def _finalize_message(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_message)


TYPE_CUserMsg_HintText = CUserMsg_HintText
_PB_finalizers.append('CUserMsg_HintText')

class CUserMsg_KeyHintText(ProtoBase):
    _required = []
    _field_map = {'messages': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['messages']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    class Repeated_messages(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return ProtoBase.TYPE_string
        pb_subtype = pb_subtype()


    TYPE_Repeated_messages = Repeated_messages


    def _get_messages(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, self.TYPE_Repeated_messages, 'messages')
            self._cache[1] = r
        return r

    def _establish_parentage_messages(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_messages), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_messages
                v._pbf_establish_parent_callback = self._establish_parentage_messages

    def _set_messages(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_messages(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field messages"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = self.TYPE_Repeated_messages

    def _mod_messages(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = self.TYPE_Repeated_messages

    def _del_messages(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "messages"

    messages = property(_get_messages, _set_messages, _del_messages)

    @property
    def messages__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def messages__type(self):
        return self.TYPE_Repeated_messages

    def _finalize_messages(cls):
        if is_string(cls.TYPE_Repeated_messages):
            cls._pbf_strings.append(1)
        elif _PB_type(cls.TYPE_Repeated_messages) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_messages, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_messages.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_messages)


TYPE_CUserMsg_KeyHintText = CUserMsg_KeyHintText
_PB_finalizers.append('CUserMsg_KeyHintText')

class CUserMsg_StatsCrawlMsg(ProtoBase):
    _required = []
    _field_map = {}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

TYPE_CUserMsg_StatsCrawlMsg = CUserMsg_StatsCrawlMsg
_PB_finalizers.append('CUserMsg_StatsCrawlMsg')

class CUserMsg_StatsSkipState(ProtoBase):
    _required = []
    _field_map = {'num_skips': 1, 'num_players': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['num_skips', 'num_players']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_num_skips(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'num_skips')
            self._cache[1] = r
        return r

    def _establish_parentage_num_skips(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_skips), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_skips
                v._pbf_establish_parent_callback = self._establish_parentage_num_skips

    def _set_num_skips(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_skips(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_skips"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_num_skips(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_num_skips(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "num_skips"

    num_skips = property(_get_num_skips, _set_num_skips, _del_num_skips)

    @property
    def num_skips__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def num_skips__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_num_skips(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_num_skips)


    def _get_num_players(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'num_players')
            self._cache[2] = r
        return r

    def _establish_parentage_num_players(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_num_players), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_num_players
                v._pbf_establish_parent_callback = self._establish_parentage_num_players

    def _set_num_players(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_num_players(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field num_players"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_num_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_num_players(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "num_players"

    num_players = property(_get_num_players, _set_num_players, _del_num_players)

    @property
    def num_players__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def num_players__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_num_players(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_num_players)


TYPE_CUserMsg_StatsSkipState = CUserMsg_StatsSkipState
_PB_finalizers.append('CUserMsg_StatsSkipState')

class CUserMsg_VoiceSubtitle(ProtoBase):
    _required = []
    _field_map = {'menu': 2, 'item': 3, 'ent_index': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['ent_index', 'menu', 'item']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_ent_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'ent_index')
            self._cache[1] = r
        return r

    def _establish_parentage_ent_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_ent_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_ent_index
                v._pbf_establish_parent_callback = self._establish_parentage_ent_index

    def _set_ent_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_ent_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field ent_index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_ent_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_ent_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "ent_index"

    ent_index = property(_get_ent_index, _set_ent_index, _del_ent_index)

    @property
    def ent_index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def ent_index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_ent_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_ent_index)


    def _get_menu(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'menu')
            self._cache[2] = r
        return r

    def _establish_parentage_menu(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_menu), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_menu
                v._pbf_establish_parent_callback = self._establish_parentage_menu

    def _set_menu(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_menu(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field menu"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_menu(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_menu(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "menu"

    menu = property(_get_menu, _set_menu, _del_menu)

    @property
    def menu__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def menu__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_menu(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_menu)


    def _get_item(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'item')
            self._cache[3] = r
        return r

    def _establish_parentage_item(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_item), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_item
                v._pbf_establish_parent_callback = self._establish_parentage_item

    def _set_item(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_item(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field item"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_item(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_item(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "item"

    item = property(_get_item, _set_item, _del_item)

    @property
    def item__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def item__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_item(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_item)


TYPE_CUserMsg_VoiceSubtitle = CUserMsg_VoiceSubtitle
_PB_finalizers.append('CUserMsg_VoiceSubtitle')

class CUserMsg_VGUIMenu(ProtoBase):
    _required = []
    _field_map = {'keys': 3, 'name': 1, 'show': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['name', 'show', 'keys']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))
    
    class Keys(ProtoBase):
        _required = []
        _field_map = {'name': 1, 'value': 2}
        
        def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
            self._pbf_parent_callback = _pbf_parent_callback
            self._cache = {}
            self._pbf_establish_parent_callback = None
            ProtoBase.__init__(self, _pbf_buf, **kw)
    
        @classmethod
        def _pbf_finalize(cls):
            for c in cls._pbf_finalizers:
                c(cls)
            del cls._pbf_finalizers
    
        @classmethod
        def fields(cls):
            return ['name', 'value']
    
        def modified(self):
            return self._evermod
    
        def __contains__(self, item):
            try:
                return getattr(self, '%s__exists' % item)
            except AttributeError:
                return False
    
        _pbf_strings = []
        _pbf_finalizers = []
    
        def __str__(self):
            return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                              if getattr(self, '%s__exists' % f))
        
        def _get_name(self):
            if 1 in self._cache:
                r = self._cache[1]
            else:
                r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
                self._cache[1] = r
            return r
    
        def _establish_parentage_name(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_name
                    v._pbf_establish_parent_callback = self._establish_parentage_name
    
        def _set_name(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_name(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field name"
                raise ProtoValueError(list_assign_error)
            self._cache[1] = v
            self._mods[1] = ProtoBase.TYPE_string
    
        def _mod_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[1] = ProtoBase.TYPE_string
    
        def _del_name(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 1 in self._cache:
                del self._cache[1]
            if 1 in self._mods:
                del self._mods[1]
            self._buf_del(1)
    
        _pb_field_name_1 = "name"
    
        name = property(_get_name, _set_name, _del_name)
    
        @property
        def name__exists(self):
            return 1 in self._mods or self._buf_exists(1)
    
        @property
        def name__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_name(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(1)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(1)
    
        _pbf_finalizers.append(_finalize_name)
    
        
        def _get_value(self):
            if 2 in self._cache:
                r = self._cache[2]
            else:
                r = self._buf_get(2, ProtoBase.TYPE_string, 'value')
                self._cache[2] = r
            return r
    
        def _establish_parentage_value(self, v):
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                if v._pbf_parent_callback:
                    assert (v._pbf_parent_callback == self._mod_value), "subobjects can only have one parent--use copy()?"
                else:
                    v._pbf_parent_callback = self._mod_value
                    v._pbf_establish_parent_callback = self._establish_parentage_value
    
        def _set_value(self, v, modifying=True):
            self._evermod = modifying or self._evermod
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if isinstance(v, (ProtoBase, RepeatedSequence)):
                self._establish_parentage_value(v)
            elif isinstance(v, list):
                list_assign_error = "Can't assign list to repeated field value"
                raise ProtoValueError(list_assign_error)
            self._cache[2] = v
            self._mods[2] = ProtoBase.TYPE_string
    
        def _mod_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            self._mods[2] = ProtoBase.TYPE_string
    
        def _del_value(self):
            self._evermod = True
            if self._pbf_parent_callback:
                self._pbf_parent_callback()
            if 2 in self._cache:
                del self._cache[2]
            if 2 in self._mods:
                del self._mods[2]
            self._buf_del(2)
    
        _pb_field_name_2 = "value"
    
        value = property(_get_value, _set_value, _del_value)
    
        @property
        def value__exists(self):
            return 2 in self._mods or self._buf_exists(2)
    
        @property
        def value__type(self):
            return ProtoBase.TYPE_string
    
        def _finalize_value(cls):
            if is_string(ProtoBase.TYPE_string):
                cls._pbf_strings.append(2)
            elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
                assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
                if is_string(ProtoBase.TYPE_string.pb_subtype):
                    cls._pbf_strings.append(2)
    
        _pbf_finalizers.append(_finalize_value)
    
        
    TYPE_Keys = Keys
    _PB_finalizers.append('CUserMsg_VGUIMenu.Keys')
    
    TYPE_Keys = Keys

    def _get_name(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_string, 'name')
            self._cache[1] = r
        return r

    def _establish_parentage_name(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_name), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_name
                v._pbf_establish_parent_callback = self._establish_parentage_name

    def _set_name(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_name(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field name"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_string

    def _mod_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_string

    def _del_name(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "name"

    name = property(_get_name, _set_name, _del_name)

    @property
    def name__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def name__type(self):
        return ProtoBase.TYPE_string

    def _finalize_name(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_name)


    def _get_show(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_bool, 'show')
            self._cache[2] = r
        return r

    def _establish_parentage_show(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_show), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_show
                v._pbf_establish_parent_callback = self._establish_parentage_show

    def _set_show(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_show(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field show"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_bool

    def _mod_show(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_bool

    def _del_show(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "show"

    show = property(_get_show, _set_show, _del_show)

    @property
    def show__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def show__type(self):
        return ProtoBase.TYPE_bool

    def _finalize_show(cls):
        if is_string(ProtoBase.TYPE_bool):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_bool) is _PB_type:
            assert issubclass(ProtoBase.TYPE_bool, RepeatedSequence)
            if is_string(ProtoBase.TYPE_bool.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_show)


    class Repeated_keys(RepeatedSequence):
        class pb_subtype(object):
            def __get__(self, instance, cls):
                return CUserMsg_VGUIMenu.TYPE_Keys
        pb_subtype = pb_subtype()


    TYPE_Repeated_keys = Repeated_keys


    @property
    def keys__stream(self):
        if 3 in self._cache:
            def acc(v):
                v_ = lambda: v
                return v_
            return [acc(v) for v in self._cache[3]]
        return self._get_repeated(3, self.TYPE_Repeated_keys, "keys", lazy=True)

    def keys__fast_append(self, value):
        self._append_to_repeated(3, self.TYPE_Repeated_keys, value)

    def _get_keys(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, self.TYPE_Repeated_keys, 'keys')
            self._cache[3] = r
        return r

    def _establish_parentage_keys(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_keys), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_keys
                v._pbf_establish_parent_callback = self._establish_parentage_keys

    def _set_keys(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_keys(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field keys"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = self.TYPE_Repeated_keys

    def _mod_keys(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = self.TYPE_Repeated_keys

    def _del_keys(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "keys"

    keys = property(_get_keys, _set_keys, _del_keys)

    @property
    def keys__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def keys__type(self):
        return self.TYPE_Repeated_keys

    def _finalize_keys(cls):
        if is_string(cls.TYPE_Repeated_keys):
            cls._pbf_strings.append(3)
        elif _PB_type(cls.TYPE_Repeated_keys) is _PB_type:
            assert issubclass(cls.TYPE_Repeated_keys, RepeatedSequence)
            if is_string(cls.TYPE_Repeated_keys.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_keys)


TYPE_CUserMsg_VGUIMenu = CUserMsg_VGUIMenu
_PB_finalizers.append('CUserMsg_VGUIMenu')

class CUserMsg_Geiger(ProtoBase):
    _required = []
    _field_map = {'range': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['range']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_range(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'range')
            self._cache[1] = r
        return r

    def _establish_parentage_range(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_range), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_range
                v._pbf_establish_parent_callback = self._establish_parentage_range

    def _set_range(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_range(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field range"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_range(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_range(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "range"

    range = property(_get_range, _set_range, _del_range)

    @property
    def range__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def range__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_range(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_range)


TYPE_CUserMsg_Geiger = CUserMsg_Geiger
_PB_finalizers.append('CUserMsg_Geiger')

class CUserMsg_Rumble(ProtoBase):
    _required = []
    _field_map = {'index': 1, 'data': 2, 'flags': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['index', 'data', 'flags']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_index(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'index')
            self._cache[1] = r
        return r

    def _establish_parentage_index(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_index), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_index
                v._pbf_establish_parent_callback = self._establish_parentage_index

    def _set_index(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_index(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field index"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_index(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "index"

    index = property(_get_index, _set_index, _del_index)

    @property
    def index__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def index__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_index(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_index)


    def _get_data(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'data')
            self._cache[2] = r
        return r

    def _establish_parentage_data(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_data), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_data
                v._pbf_establish_parent_callback = self._establish_parentage_data

    def _set_data(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_data(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field data"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_data(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "data"

    data = property(_get_data, _set_data, _del_data)

    @property
    def data__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def data__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_data(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_data)


    def _get_flags(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_int32, 'flags')
            self._cache[3] = r
        return r

    def _establish_parentage_flags(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_flags), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_flags
                v._pbf_establish_parent_callback = self._establish_parentage_flags

    def _set_flags(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_flags(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field flags"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_int32

    def _mod_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_int32

    def _del_flags(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "flags"

    flags = property(_get_flags, _set_flags, _del_flags)

    @property
    def flags__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def flags__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_flags(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_flags)


TYPE_CUserMsg_Rumble = CUserMsg_Rumble
_PB_finalizers.append('CUserMsg_Rumble')

class CUserMsg_Train(ProtoBase):
    _required = []
    _field_map = {'train': 1}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['train']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_train(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'train')
            self._cache[1] = r
        return r

    def _establish_parentage_train(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_train), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_train
                v._pbf_establish_parent_callback = self._establish_parentage_train

    def _set_train(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_train(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field train"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_train(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_train(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "train"

    train = property(_get_train, _set_train, _del_train)

    @property
    def train__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def train__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_train(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_train)


TYPE_CUserMsg_Train = CUserMsg_Train
_PB_finalizers.append('CUserMsg_Train')

class CUserMsg_SayTextChannel(ProtoBase):
    _required = []
    _field_map = {'player': 1, 'channel': 2, 'text': 3}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['player', 'channel', 'text']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_player(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_int32, 'player')
            self._cache[1] = r
        return r

    def _establish_parentage_player(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_player), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_player
                v._pbf_establish_parent_callback = self._establish_parentage_player

    def _set_player(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_player(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field player"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_int32

    def _mod_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_int32

    def _del_player(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "player"

    player = property(_get_player, _set_player, _del_player)

    @property
    def player__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def player__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_player(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_player)


    def _get_channel(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_int32, 'channel')
            self._cache[2] = r
        return r

    def _establish_parentage_channel(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_channel), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_channel
                v._pbf_establish_parent_callback = self._establish_parentage_channel

    def _set_channel(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_channel(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field channel"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_int32

    def _mod_channel(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_int32

    def _del_channel(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "channel"

    channel = property(_get_channel, _set_channel, _del_channel)

    @property
    def channel__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def channel__type(self):
        return ProtoBase.TYPE_int32

    def _finalize_channel(cls):
        if is_string(ProtoBase.TYPE_int32):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_int32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_int32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_int32.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_channel)


    def _get_text(self):
        if 3 in self._cache:
            r = self._cache[3]
        else:
            r = self._buf_get(3, ProtoBase.TYPE_string, 'text')
            self._cache[3] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[3] = v
        self._mods[3] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[3] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 3 in self._cache:
            del self._cache[3]
        if 3 in self._mods:
            del self._mods[3]
        self._buf_del(3)

    _pb_field_name_3 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 3 in self._mods or self._buf_exists(3)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(3)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(3)

    _pbf_finalizers.append(_finalize_text)


TYPE_CUserMsg_SayTextChannel = CUserMsg_SayTextChannel
_PB_finalizers.append('CUserMsg_SayTextChannel')

class CUserMsg_MessageText(ProtoBase):
    _required = []
    _field_map = {'color': 1, 'text': 2}
    
    def __init__(self, _pbf_buf='', _pbf_parent_callback=None, **kw):
        self._pbf_parent_callback = _pbf_parent_callback
        self._cache = {}
        self._pbf_establish_parent_callback = None
        ProtoBase.__init__(self, _pbf_buf, **kw)

    @classmethod
    def _pbf_finalize(cls):
        for c in cls._pbf_finalizers:
            c(cls)
        del cls._pbf_finalizers

    @classmethod
    def fields(cls):
        return ['color', 'text']

    def modified(self):
        return self._evermod

    def __contains__(self, item):
        try:
            return getattr(self, '%s__exists' % item)
        except AttributeError:
            return False

    _pbf_strings = []
    _pbf_finalizers = []

    def __str__(self):
        return '\n'.join('%s: %s' % (f, repr(getattr(self, '_get_%s' % f)())) for f in self.fields()
                          if getattr(self, '%s__exists' % f))

    def _get_color(self):
        if 1 in self._cache:
            r = self._cache[1]
        else:
            r = self._buf_get(1, ProtoBase.TYPE_uint32, 'color')
            self._cache[1] = r
        return r

    def _establish_parentage_color(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_color), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_color
                v._pbf_establish_parent_callback = self._establish_parentage_color

    def _set_color(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_color(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field color"
            raise ProtoValueError(list_assign_error)
        self._cache[1] = v
        self._mods[1] = ProtoBase.TYPE_uint32

    def _mod_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[1] = ProtoBase.TYPE_uint32

    def _del_color(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 1 in self._cache:
            del self._cache[1]
        if 1 in self._mods:
            del self._mods[1]
        self._buf_del(1)

    _pb_field_name_1 = "color"

    color = property(_get_color, _set_color, _del_color)

    @property
    def color__exists(self):
        return 1 in self._mods or self._buf_exists(1)

    @property
    def color__type(self):
        return ProtoBase.TYPE_uint32

    def _finalize_color(cls):
        if is_string(ProtoBase.TYPE_uint32):
            cls._pbf_strings.append(1)
        elif _PB_type(ProtoBase.TYPE_uint32) is _PB_type:
            assert issubclass(ProtoBase.TYPE_uint32, RepeatedSequence)
            if is_string(ProtoBase.TYPE_uint32.pb_subtype):
                cls._pbf_strings.append(1)

    _pbf_finalizers.append(_finalize_color)


    def _get_text(self):
        if 2 in self._cache:
            r = self._cache[2]
        else:
            r = self._buf_get(2, ProtoBase.TYPE_string, 'text')
            self._cache[2] = r
        return r

    def _establish_parentage_text(self, v):
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            if v._pbf_parent_callback:
                assert (v._pbf_parent_callback == self._mod_text), "subobjects can only have one parent--use copy()?"
            else:
                v._pbf_parent_callback = self._mod_text
                v._pbf_establish_parent_callback = self._establish_parentage_text

    def _set_text(self, v, modifying=True):
        self._evermod = modifying or self._evermod
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if isinstance(v, (ProtoBase, RepeatedSequence)):
            self._establish_parentage_text(v)
        elif isinstance(v, list):
            list_assign_error = "Can't assign list to repeated field text"
            raise ProtoValueError(list_assign_error)
        self._cache[2] = v
        self._mods[2] = ProtoBase.TYPE_string

    def _mod_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        self._mods[2] = ProtoBase.TYPE_string

    def _del_text(self):
        self._evermod = True
        if self._pbf_parent_callback:
            self._pbf_parent_callback()
        if 2 in self._cache:
            del self._cache[2]
        if 2 in self._mods:
            del self._mods[2]
        self._buf_del(2)

    _pb_field_name_2 = "text"

    text = property(_get_text, _set_text, _del_text)

    @property
    def text__exists(self):
        return 2 in self._mods or self._buf_exists(2)

    @property
    def text__type(self):
        return ProtoBase.TYPE_string

    def _finalize_text(cls):
        if is_string(ProtoBase.TYPE_string):
            cls._pbf_strings.append(2)
        elif _PB_type(ProtoBase.TYPE_string) is _PB_type:
            assert issubclass(ProtoBase.TYPE_string, RepeatedSequence)
            if is_string(ProtoBase.TYPE_string.pb_subtype):
                cls._pbf_strings.append(2)

    _pbf_finalizers.append(_finalize_text)


TYPE_CUserMsg_MessageText = CUserMsg_MessageText
_PB_finalizers.append('CUserMsg_MessageText')


for cname in _PB_finalizers:
    eval(cname)._pbf_finalize()

del _PB_finalizers
